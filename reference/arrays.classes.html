

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>11.1.6. Standard array subclasses &mdash; Numpy API</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Numpy API" href="../index.html"/>
        <link rel="up" title="11.1. Array objects" href="arrays.html"/>
        <link rel="next" title="11.1.6.2.1. numpy.matrix.T" href="generated/numpy.matrix.T.html"/>
        <link rel="prev" title="11.1.5. Iterating Over Arrays" href="arrays.nditer.html"/> 

  
  <script src="../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../index.html" class="icon icon-home"> Numpy API
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.html">1. NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.doc.html">2. <code class="docutils literal"><span class="pre">numpy.doc</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.lib.html">3. <code class="docutils literal"><span class="pre">numpy.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.random.html">4. <code class="docutils literal"><span class="pre">numpy.random</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.linalg.html">5. <code class="docutils literal"><span class="pre">numpy.linalg</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../api.fft.html">6. Discrete Fourier Transform (<code class="docutils literal"><span class="pre">numpy.fft</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.polynomial.html">7. <code class="docutils literal"><span class="pre">numpy.polynomial</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.testing.html">8. <code class="docutils literal"><span class="pre">numpy.testing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.f2py.html">9. <code class="docutils literal"><span class="pre">numpy.f2py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../generated/numpy.distutils.html">10. <code class="docutils literal"><span class="pre">numpy.distutils</span></code></a></li>
<li class="toctree-l1 current"><a class="reference internal" href="index.html">11. NumPy Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="arrays.html">11.1. Array objects</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="arrays.ndarray.html">11.1.1. The N-dimensional array (<code class="docutils literal"><span class="pre">ndarray</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.scalars.html">11.1.2. Scalars</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.dtypes.html">11.1.3. Data type objects (<code class="docutils literal"><span class="pre">dtype</span></code>)</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.indexing.html">11.1.4. Indexing</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.nditer.html">11.1.5. Iterating Over Arrays</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="">11.1.6. Standard array subclasses</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#special-attributes-and-methods">11.1.6.1. Special attributes and methods</a></li>
<li class="toctree-l4"><a class="reference internal" href="#matrix-objects">11.1.6.2. Matrix objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-mapped-file-arrays">11.1.6.3. Memory-mapped file arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#character-arrays-numpy-char">11.1.6.4. Character arrays (<code class="docutils literal"><span class="pre">numpy.char</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#record-arrays-numpy-rec">11.1.6.5. Record arrays (<code class="docutils literal"><span class="pre">numpy.rec</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#masked-arrays-numpy-ma">11.1.6.6. Masked arrays (<code class="docutils literal"><span class="pre">numpy.ma</span></code>)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#standard-container-class">11.1.6.7. Standard container class</a></li>
<li class="toctree-l4"><a class="reference internal" href="#array-iterators">11.1.6.8. Array Iterators</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="maskedarray.html">11.1.7. Masked arrays</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.interface.html">11.1.8. The Array Interface</a></li>
<li class="toctree-l3"><a class="reference internal" href="arrays.datetime.html">11.1.9. Datetimes and Timedeltas</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="ufuncs.html">11.2. Universal functions (<code class="docutils literal"><span class="pre">ufunc</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="routines.html">11.3. Routines</a></li>
<li class="toctree-l2"><a class="reference internal" href="distutils.html">11.4. Packaging (<code class="docutils literal"><span class="pre">numpy.distutils</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="c-api.html">11.5. Numpy C-API</a></li>
<li class="toctree-l2"><a class="reference internal" href="internals.html">11.6. Numpy internals</a></li>
<li class="toctree-l2"><a class="reference internal" href="swig.html">11.7. Numpy and SWIG</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#acknowledgements">11.8. Acknowledgements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../glossary.html">12. Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Numpy API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">11. NumPy Reference</a> &raquo;</li>
        
          <li><a href="arrays.html">11.1. Array objects</a> &raquo;</li>
        
      <li>11.1.6. Standard array subclasses</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/reference/arrays.classes.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="standard-array-subclasses">
<span id="arrays-classes"></span><h1>11.1.6. Standard array subclasses<a class="headerlink" href="#standard-array-subclasses" title="Permalink to this headline">¶</a></h1>
<p>The <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> in NumPy is a &#8220;new-style&#8221; Python
built-in-type. Therefore, it can be inherited from (in Python or in C)
if desired. Therefore, it can form a foundation for many useful
classes. Often whether to sub-class the array object or to simply use
the core array component as an internal part of a new class is a
difficult decision, and can be simply a matter of choice. NumPy has
several tools for simplifying how your new object interacts with other
array objects, and so the choice may not be significant in the
end. One way to simplify the question is by asking yourself if the
object you are interested in can be replaced as a single array or does
it really require two or more arrays at its core.</p>
<p>Note that <a class="reference internal" href="generated/numpy.asarray.html#numpy.asarray" title="numpy.asarray"><code class="xref py py-func docutils literal"><span class="pre">asarray()</span></code></a> always returns the base-class ndarray. If
you are confident that your use of the array object can handle any
subclass of an ndarray, then <a class="reference internal" href="generated/numpy.asanyarray.html#numpy.asanyarray" title="numpy.asanyarray"><code class="xref py py-func docutils literal"><span class="pre">asanyarray()</span></code></a> can be used to allow
subclasses to propagate more cleanly through your subroutine. In
principal a subclass could redefine any aspect of the array and
therefore, under strict guidelines, <a class="reference internal" href="generated/numpy.asanyarray.html#numpy.asanyarray" title="numpy.asanyarray"><code class="xref py py-func docutils literal"><span class="pre">asanyarray()</span></code></a> would rarely be
useful. However, most subclasses of the array object will not
redefine certain aspects of the array object such as the buffer
interface, or the attributes of the array. One important example,
however, of why your subroutine may not be able to handle an arbitrary
subclass of an array is that matrices redefine the &#8220;*&#8221; operator to be
matrix-multiplication, rather than element-by-element multiplication.</p>
<div class="section" id="special-attributes-and-methods">
<h2>11.1.6.1. Special attributes and methods<a class="headerlink" href="#special-attributes-and-methods" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><span class="xref std std-ref">Subclassing ndarray</span></p>
</div>
<p>Numpy provides several hooks that classes can customize:</p>
<dl class="method">
<dt id="numpy.class.__numpy_ufunc__">
<code class="descclassname">class.</code><code class="descname">__numpy_ufunc__</code><span class="sig-paren">(</span><em>ufunc</em>, <em>method</em>, <em>i</em>, <em>inputs</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.class.__numpy_ufunc__" title="Permalink to this definition">¶</a></dt>
<dd><div class="versionadded">
<p><span class="versionmodified">New in version 1.11.</span></p>
</div>
<p>Any class (ndarray subclass or not) can define this method to
override behavior of Numpy&#8217;s ufuncs. This works quite similarly to
Python&#8217;s <code class="docutils literal"><span class="pre">__mul__</span></code> and other binary operation routines.</p>
<ul class="simple">
<li><em>ufunc</em> is the ufunc object that was called.</li>
<li><em>method</em> is a string indicating which Ufunc method was called
(one of <code class="docutils literal"><span class="pre">&quot;__call__&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;reduce&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;reduceat&quot;</span></code>,
<code class="docutils literal"><span class="pre">&quot;accumulate&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;outer&quot;</span></code>, <code class="docutils literal"><span class="pre">&quot;inner&quot;</span></code>).</li>
<li><em>i</em> is the index of <em>self</em> in <em>inputs</em>.</li>
<li><em>inputs</em> is a tuple of the input arguments to the <code class="docutils literal"><span class="pre">ufunc</span></code></li>
<li><em>kwargs</em> is a dictionary containing the optional input arguments
of the ufunc. The <code class="docutils literal"><span class="pre">out</span></code> argument is always contained in
<em>kwargs</em>, if given. See the discussion in <a class="reference internal" href="ufuncs.html#ufuncs"><span>Universal functions (ufunc)</span></a> for
details.</li>
</ul>
<p>The method should return either the result of the operation, or
<code class="xref py py-obj docutils literal"><span class="pre">NotImplemented</span></code> if the operation requested is not
implemented.</p>
<p>If one of the arguments has a <a class="reference internal" href="#numpy.class.__numpy_ufunc__" title="numpy.class.__numpy_ufunc__"><code class="xref py py-func docutils literal"><span class="pre">__numpy_ufunc__()</span></code></a> method, it is
executed <em>instead</em> of the ufunc.  If more than one of the input
arguments implements <a class="reference internal" href="#numpy.class.__numpy_ufunc__" title="numpy.class.__numpy_ufunc__"><code class="xref py py-func docutils literal"><span class="pre">__numpy_ufunc__()</span></code></a>, they are tried in the
order: subclasses before superclasses, otherwise left to right. The
first routine returning something else than <code class="xref py py-obj docutils literal"><span class="pre">NotImplemented</span></code>
determines the result. If all of the <a class="reference internal" href="#numpy.class.__numpy_ufunc__" title="numpy.class.__numpy_ufunc__"><code class="xref py py-func docutils literal"><span class="pre">__numpy_ufunc__()</span></code></a>
operations return <code class="xref py py-obj docutils literal"><span class="pre">NotImplemented</span></code>, a <code class="xref py py-exc docutils literal"><span class="pre">TypeError</span></code> is
raised.</p>
<p>If an <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> subclass defines the <a class="reference internal" href="#numpy.class.__numpy_ufunc__" title="numpy.class.__numpy_ufunc__"><code class="xref py py-func docutils literal"><span class="pre">__numpy_ufunc__()</span></code></a>
method, this disables the <a class="reference internal" href="#numpy.class.__array_wrap__" title="numpy.class.__array_wrap__"><code class="xref py py-func docutils literal"><span class="pre">__array_wrap__()</span></code></a>,
<a class="reference internal" href="#numpy.class.__array_prepare__" title="numpy.class.__array_prepare__"><code class="xref py py-func docutils literal"><span class="pre">__array_prepare__()</span></code></a>, <a class="reference internal" href="#numpy.class.__array_priority__" title="numpy.class.__array_priority__"><code class="xref py py-data docutils literal"><span class="pre">__array_priority__</span></code></a> mechanism
described below.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In addition to ufuncs, <a class="reference internal" href="#numpy.class.__numpy_ufunc__" title="numpy.class.__numpy_ufunc__"><code class="xref py py-func docutils literal"><span class="pre">__numpy_ufunc__()</span></code></a> also
overrides the behavior of <a class="reference internal" href="generated/numpy.dot.html#numpy.dot" title="numpy.dot"><code class="xref py py-func docutils literal"><span class="pre">numpy.dot()</span></code></a> even though it is
not an Ufunc.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>If you also define right-hand binary operator override
methods (such as <code class="docutils literal"><span class="pre">__rmul__</span></code>) or comparison operations (such as
<code class="docutils literal"><span class="pre">__gt__</span></code>) in your class, they take precedence over the
<a class="reference internal" href="#numpy.class.__numpy_ufunc__" title="numpy.class.__numpy_ufunc__"><code class="xref py py-func docutils literal"><span class="pre">__numpy_ufunc__()</span></code></a> mechanism when resolving results of
binary operations (such as <code class="docutils literal"><span class="pre">ndarray_obj</span> <span class="pre">*</span> <span class="pre">your_obj</span></code>).</p>
<p>The technical special case is: <code class="docutils literal"><span class="pre">ndarray.__mul__</span></code> returns
<code class="docutils literal"><span class="pre">NotImplemented</span></code> if the other object is <em>not</em> a subclass of
<a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>, and defines both <code class="docutils literal"><span class="pre">__numpy_ufunc__</span></code> and
<code class="docutils literal"><span class="pre">__rmul__</span></code>. Similar exception applies for the other operations
than multiplication.</p>
<p>In such a case, when computing a binary operation such as
<code class="docutils literal"><span class="pre">ndarray_obj</span> <span class="pre">*</span> <span class="pre">your_obj</span></code>, your <code class="docutils literal"><span class="pre">__numpy_ufunc__</span></code> method
<em>will not</em> be called.  Instead, the execution passes on to your
right-hand <code class="docutils literal"><span class="pre">__rmul__</span></code> operation, as per standard Python
operator override rules.</p>
<p>Similar special case applies to <em>in-place operations</em>: If you
define <code class="docutils literal"><span class="pre">__rmul__</span></code>, then <code class="docutils literal"><span class="pre">ndarray_obj</span> <span class="pre">*=</span> <span class="pre">your_obj</span></code> <em>will not</em>
call your <code class="docutils literal"><span class="pre">__numpy_ufunc__</span></code> implementation. Instead, the
default Python behavior <code class="docutils literal"><span class="pre">ndarray_obj</span> <span class="pre">=</span> <span class="pre">ndarray_obj</span> <span class="pre">*</span> <span class="pre">your_obj</span></code>
occurs.</p>
<p class="last">Note that the above discussion applies only to Python&#8217;s builtin
binary operation mechanism. <code class="docutils literal"><span class="pre">np.multiply(ndarray_obj,</span>
<span class="pre">your_obj)</span></code> always calls only your <code class="docutils literal"><span class="pre">__numpy_ufunc__</span></code>, as
expected.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="numpy.class.__array_finalize__">
<code class="descclassname">class.</code><code class="descname">__array_finalize__</code><span class="sig-paren">(</span><em>obj</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.class.__array_finalize__" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called whenever the system internally allocates a
new array from <em>obj</em>, where <em>obj</em> is a subclass (subtype) of the
<a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>. It can be used to change attributes of <em>self</em>
after construction (so as to ensure a 2-d matrix for example), or
to update meta-information from the &#8220;parent.&#8221; Subclasses inherit
a default implementation of this method that does nothing.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.class.__array_prepare__">
<code class="descclassname">class.</code><code class="descname">__array_prepare__</code><span class="sig-paren">(</span><em>array</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.class.__array_prepare__" title="Permalink to this definition">¶</a></dt>
<dd><p>At the beginning of every <a class="reference internal" href="ufuncs.html#ufuncs-output-type"><span>ufunc</span></a>, this
method is called on the input object with the highest array
priority, or the output object if one was specified. The output
array is passed in and whatever is returned is passed to the ufunc.
Subclasses inherit a default implementation of this method which
simply returns the output array unmodified. Subclasses may opt to
use this method to transform the output array into an instance of
the subclass and update metadata before returning the array to the
ufunc for computation.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.class.__array_wrap__">
<code class="descclassname">class.</code><code class="descname">__array_wrap__</code><span class="sig-paren">(</span><em>array</em>, <em>context=None</em><span class="sig-paren">)</span><a class="headerlink" href="#numpy.class.__array_wrap__" title="Permalink to this definition">¶</a></dt>
<dd><p>At the end of every <a class="reference internal" href="ufuncs.html#ufuncs-output-type"><span>ufunc</span></a>, this method
is called on the input object with the highest array priority, or
the output object if one was specified. The ufunc-computed array
is passed in and whatever is returned is passed to the user.
Subclasses inherit a default implementation of this method, which
transforms the array into a new instance of the object&#8217;s class.
Subclasses may opt to use this method to transform the output array
into an instance of the subclass and update metadata before
returning the array to the user.</p>
</dd></dl>

<dl class="data">
<dt id="numpy.class.__array_priority__">
<code class="descclassname">class.</code><code class="descname">__array_priority__</code><a class="headerlink" href="#numpy.class.__array_priority__" title="Permalink to this definition">¶</a></dt>
<dd><p>The value of this attribute is used to determine what type of
object to return in situations where there is more than one
possibility for the Python type of the returned object. Subclasses
inherit a default value of 0.0 for this attribute.</p>
</dd></dl>

<dl class="method">
<dt id="numpy.class.__array__">
<code class="descclassname">class.</code><code class="descname">__array__</code><span class="sig-paren">(</span><span class="optional">[</span><em>dtype</em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#numpy.class.__array__" title="Permalink to this definition">¶</a></dt>
<dd><p>If a class (ndarray subclass or not) having the <a class="reference internal" href="#numpy.class.__array__" title="numpy.class.__array__"><code class="xref py py-func docutils literal"><span class="pre">__array__()</span></code></a>
method is used as the output object of an <a class="reference internal" href="ufuncs.html#ufuncs-output-type"><span>ufunc</span></a>, results will be written to the object
returned by <a class="reference internal" href="#numpy.class.__array__" title="numpy.class.__array__"><code class="xref py py-func docutils literal"><span class="pre">__array__()</span></code></a>. Similar conversion is done on
input arrays.</p>
</dd></dl>

</div>
<div class="section" id="matrix-objects">
<h2>11.1.6.2. Matrix objects<a class="headerlink" href="#matrix-objects" title="Permalink to this headline">¶</a></h2>
<p id="index-0"><a class="reference internal" href="generated/numpy.matrix.html#numpy.matrix" title="numpy.matrix"><code class="xref py py-class docutils literal"><span class="pre">matrix</span></code></a> objects inherit from the ndarray and therefore, they
have the same attributes and methods of ndarrays. There are six
important differences of matrix objects, however, that may lead to
unexpected results when you use matrices but expect them to act like
arrays:</p>
<ol class="arabic">
<li><p class="first">Matrix objects can be created using a string notation to allow
Matlab-style syntax where spaces separate columns and semicolons
(&#8216;;&#8217;) separate rows.</p>
</li>
<li><p class="first">Matrix objects are always two-dimensional. This has far-reaching
implications, in that m.ravel() is still two-dimensional (with a 1
in the first dimension) and item selection returns two-dimensional
objects so that sequence behavior is fundamentally different than
arrays.</p>
</li>
<li><p class="first">Matrix objects over-ride multiplication to be
matrix-multiplication. <strong>Make sure you understand this for
functions that you may want to receive matrices. Especially in
light of the fact that asanyarray(m) returns a matrix when m is
a matrix.</strong></p>
</li>
<li><p class="first">Matrix objects over-ride power to be matrix raised to a power. The
same warning about using power inside a function that uses
asanyarray(...) to get an array object holds for this fact.</p>
</li>
<li><p class="first">The default __array_priority__ of matrix objects is 10.0, and
therefore mixed operations with ndarrays always produce matrices.</p>
</li>
<li><p class="first">Matrices have special attributes which make calculations easier.
These are</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.matrix.T.html#numpy.matrix.T" title="numpy.matrix.T"><code class="xref py py-obj docutils literal"><span class="pre">matrix.T</span></code></a></td>
<td>Returns the transpose of the matrix.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.matrix.H.html#numpy.matrix.H" title="numpy.matrix.H"><code class="xref py py-obj docutils literal"><span class="pre">matrix.H</span></code></a></td>
<td>Returns the (complex) conjugate transpose of <cite>self</cite>.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.matrix.I.html#numpy.matrix.I" title="numpy.matrix.I"><code class="xref py py-obj docutils literal"><span class="pre">matrix.I</span></code></a></td>
<td>Returns the (multiplicative) inverse of invertible <cite>self</cite>.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.matrix.A.html#numpy.matrix.A" title="numpy.matrix.A"><code class="xref py py-obj docutils literal"><span class="pre">matrix.A</span></code></a></td>
<td>Return <cite>self</cite> as an <cite>ndarray</cite> object.</td>
</tr>
</tbody>
</table>
</li>
</ol>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Matrix objects over-ride multiplication, &#8216;*&#8217;, and power, &#8216;**&#8217;, to
be matrix-multiplication and matrix power, respectively. If your
subroutine can accept sub-classes and you do not convert to base-
class arrays, then you must use the ufuncs multiply and power to
be sure that you are performing the correct operation for all
inputs.</p>
</div>
<p>The matrix class is a Python subclass of the ndarray and can be used
as a reference for how to construct your own subclass of the ndarray.
Matrices can be created from other matrices, strings, and anything
else that can be converted to an <code class="docutils literal"><span class="pre">ndarray</span></code> . The name &#8220;mat &#8220;is an
alias for &#8220;matrix &#8220;in NumPy.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.matrix.html#numpy.matrix" title="numpy.matrix"><code class="xref py py-obj docutils literal"><span class="pre">matrix</span></code></a></td>
<td>Returns a matrix from an array-like object, or from a string of data.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.asmatrix.html#numpy.asmatrix" title="numpy.asmatrix"><code class="xref py py-obj docutils literal"><span class="pre">asmatrix</span></code></a>(data[,&nbsp;dtype])</td>
<td>Interpret the input as a matrix.</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.bmat.html#numpy.bmat" title="numpy.bmat"><code class="xref py py-obj docutils literal"><span class="pre">bmat</span></code></a>(obj[,&nbsp;ldict,&nbsp;gdict])</td>
<td>Build a matrix object from a string, nested sequence, or array.</td>
</tr>
</tbody>
</table>
<p>Example 1: Matrix creation from a string</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="o">=</span><span class="n">mat</span><span class="p">(</span><span class="s1">&#39;1 2 3; 4 5 3&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="p">(</span><span class="n">a</span><span class="o">*</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">I</span>
<span class="go">[[ 0.2924 -0.1345]</span>
<span class="go"> [-0.1345  0.0819]]</span>
</pre></div>
</div>
<p>Example 2: Matrix creation from nested sequence</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">10</span><span class="p">],[</span><span class="mf">1.0</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4j</span><span class="p">]])</span>
<span class="go">matrix([[  1.+0.j,   5.+0.j,  10.+0.j],</span>
<span class="go">        [  1.+0.j,   3.+0.j,   0.+4.j]])</span>
</pre></div>
</div>
<p>Example 3: Matrix creation from an array</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mat</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
<span class="go">matrix([[ 0.7699,  0.7922,  0.3294],</span>
<span class="go">        [ 0.2792,  0.0101,  0.9219],</span>
<span class="go">        [ 0.3398,  0.7571,  0.8197]])</span>
</pre></div>
</div>
</div>
<div class="section" id="memory-mapped-file-arrays">
<h2>11.1.6.3. Memory-mapped file arrays<a class="headerlink" href="#memory-mapped-file-arrays" title="Permalink to this headline">¶</a></h2>
<p id="index-1">Memory-mapped files are useful for reading and/or modifying small
segments of a large file with regular layout, without reading the
entire file into memory. A simple subclass of the ndarray uses a
memory-mapped file for the data buffer of the array. For small files,
the over-head of reading the entire file into memory is typically not
significant, however for large files using memory mapping can save
considerable resources.</p>
<p>Memory-mapped-file arrays have one additional method (besides those
they inherit from the ndarray): <a class="reference internal" href="generated/numpy.memmap.flush.html#numpy.memmap.flush" title="numpy.memmap.flush"><code class="xref py py-meth docutils literal"><span class="pre">.flush()</span></code></a> which
must be called manually by the user to ensure that any changes to the
array actually get written to disk.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.memmap.html#numpy.memmap" title="numpy.memmap"><code class="xref py py-obj docutils literal"><span class="pre">memmap</span></code></a></td>
<td>Create a memory-map to an array stored in a <em>binary</em> file on disk.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.memmap.flush.html#numpy.memmap.flush" title="numpy.memmap.flush"><code class="xref py py-obj docutils literal"><span class="pre">memmap.flush</span></code></a>()</td>
<td>Write any changes in the array to the file on disk.</td>
</tr>
</tbody>
</table>
<p>Example:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;newfile.dat&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;w+&#39;</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span> <span class="o">=</span> <span class="mf">30.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">a</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">fromfile</span><span class="p">(</span><span class="s1">&#39;newfile.dat&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">b</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span>
<span class="go">10.0 30.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">memmap</span><span class="p">(</span><span class="s1">&#39;newfile.dat&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">print</span> <span class="n">a</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">30</span><span class="p">]</span>
<span class="go">10.0 30.0</span>
</pre></div>
</div>
</div>
<div class="section" id="character-arrays-numpy-char">
<h2>11.1.6.4. Character arrays (<code class="xref py py-mod docutils literal"><span class="pre">numpy.char</span></code>)<a class="headerlink" href="#character-arrays-numpy-char" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="routines.array-creation.html#routines-array-creation-char"><span>Creating character arrays (numpy.char)</span></a></p>
</div>
<div class="admonition note" id="index-2">
<p class="first admonition-title">Note</p>
<p class="last">The <cite>chararray</cite> class exists for backwards compatibility with
Numarray, it is not recommended for new development. Starting from numpy
1.4, if one needs arrays of strings, it is recommended to use arrays of
<cite>dtype</cite> <cite>object_</cite>, <cite>string_</cite> or <cite>unicode_</cite>, and use the free functions
in the <cite>numpy.char</cite> module for fast vectorized string operations.</p>
</div>
<p>These are enhanced arrays of either <a class="reference internal" href="../generated/generated/numpy.string_.html#numpy.string_" title="numpy.string_"><code class="xref py py-class docutils literal"><span class="pre">string_</span></code></a> type or
<a class="reference internal" href="../generated/generated/numpy.unicode_.html#numpy.unicode_" title="numpy.unicode_"><code class="xref py py-class docutils literal"><span class="pre">unicode_</span></code></a> type.  These arrays inherit from the
<a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a>, but specially-define the operations <code class="docutils literal"><span class="pre">+</span></code>, <code class="docutils literal"><span class="pre">*</span></code>,
and <code class="docutils literal"><span class="pre">%</span></code> on a (broadcasting) element-by-element basis.  These
operations are not available on the standard <a class="reference internal" href="generated/numpy.ndarray.html#numpy.ndarray" title="numpy.ndarray"><code class="xref py py-class docutils literal"><span class="pre">ndarray</span></code></a> of
character type. In addition, the <a class="reference internal" href="generated/numpy.chararray.html#numpy.chararray" title="numpy.chararray"><code class="xref py py-class docutils literal"><span class="pre">chararray</span></code></a> has all of the
standard <a class="reference internal" href="../generated/generated/numpy.str.html#numpy.str" title="numpy.str"><code class="xref py py-class docutils literal"><span class="pre">string</span></code></a> (and <a class="reference internal" href="../generated/generated/numpy.unicode.html#numpy.unicode" title="numpy.unicode"><code class="xref py py-class docutils literal"><span class="pre">unicode</span></code></a>) methods,
executing them on an element-by-element basis. Perhaps the easiest
way to create a chararray is to use <a class="reference internal" href="generated/numpy.ndarray.view.html#numpy.ndarray.view" title="numpy.ndarray.view"><code class="xref py py-meth docutils literal"><span class="pre">self.view(chararray)</span></code></a> where <em>self</em> is an ndarray of str or unicode
data-type. However, a chararray can also be created using the
<a class="reference internal" href="generated/numpy.chararray.html#numpy.chararray" title="numpy.chararray"><code class="xref py py-meth docutils literal"><span class="pre">numpy.chararray()</span></code></a> constructor, or via the
<a class="reference internal" href="generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array" title="numpy.core.defchararray.array"><code class="xref py py-func docutils literal"><span class="pre">numpy.char.array</span></code></a> function:</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.chararray.html#numpy.chararray" title="numpy.chararray"><code class="xref py py-obj docutils literal"><span class="pre">chararray</span></code></a></td>
<td>Provides a convenient view on arrays of string and unicode values.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.core.defchararray.array.html#numpy.core.defchararray.array" title="numpy.core.defchararray.array"><code class="xref py py-obj docutils literal"><span class="pre">core.defchararray.array</span></code></a>(obj[,&nbsp;itemsize,&nbsp;...])</td>
<td>Create a <cite>chararray</cite>.</td>
</tr>
</tbody>
</table>
<p>Another difference with the standard ndarray of str data-type is
that the chararray inherits the feature introduced by Numarray that
white-space at the end of any element in the array will be ignored
on item retrieval and comparison operations.</p>
</div>
<div class="section" id="record-arrays-numpy-rec">
<span id="arrays-classes-rec"></span><h2>11.1.6.5. Record arrays (<code class="xref py py-mod docutils literal"><span class="pre">numpy.rec</span></code>)<a class="headerlink" href="#record-arrays-numpy-rec" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="routines.array-creation.html#routines-array-creation-rec"><span>Creating record arrays (numpy.rec)</span></a>, <a class="reference internal" href="routines.dtype.html#routines-dtype"><span>Data type routines</span></a>,
<a class="reference internal" href="arrays.dtypes.html#arrays-dtypes"><span>Data type objects (dtype)</span></a>.</p>
</div>
<p>Numpy provides the <a class="reference internal" href="generated/numpy.recarray.html#numpy.recarray" title="numpy.recarray"><code class="xref py py-class docutils literal"><span class="pre">recarray</span></code></a> class which allows accessing the
fields of a structured array as attributes, and a corresponding
scalar data type object <a class="reference internal" href="generated/numpy.record.html#numpy.record" title="numpy.record"><code class="xref py py-class docutils literal"><span class="pre">record</span></code></a>.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.recarray.html#numpy.recarray" title="numpy.recarray"><code class="xref py py-obj docutils literal"><span class="pre">recarray</span></code></a></td>
<td>Construct an ndarray that allows field access using attributes.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="generated/numpy.record.html#numpy.record" title="numpy.record"><code class="xref py py-obj docutils literal"><span class="pre">record</span></code></a></td>
<td>A data-type scalar that allows field access as attribute lookup.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="masked-arrays-numpy-ma">
<h2>11.1.6.6. Masked arrays (<code class="xref py py-mod docutils literal"><span class="pre">numpy.ma</span></code>)<a class="headerlink" href="#masked-arrays-numpy-ma" title="Permalink to this headline">¶</a></h2>
<div class="admonition seealso">
<p class="first admonition-title">See also</p>
<p class="last"><a class="reference internal" href="maskedarray.html#maskedarray"><span>Masked arrays</span></a></p>
</div>
</div>
<div class="section" id="standard-container-class">
<h2>11.1.6.7. Standard container class<a class="headerlink" href="#standard-container-class" title="Permalink to this headline">¶</a></h2>
<p>For backward compatibility and as a standard &#8220;container &#8220;class, the
UserArray from Numeric has been brought over to NumPy and named
<a class="reference internal" href="generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container" title="numpy.lib.user_array.container"><code class="xref py py-class docutils literal"><span class="pre">numpy.lib.user_array.container</span></code></a> The container class is a
Python class whose self.array attribute is an ndarray. Multiple
inheritance is probably easier with numpy.lib.user_array.container
than with the ndarray itself and so it is included by default. It is
not documented here beyond mentioning its existence because you are
encouraged to use the ndarray class directly if you can.</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.lib.user_array.container.html#numpy.lib.user_array.container" title="numpy.lib.user_array.container"><code class="xref py py-obj docutils literal"><span class="pre">numpy.lib.user_array.container</span></code></a>(data[,&nbsp;...])</td>
<td>Standard container-class for easy multiple-inheritance.</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="array-iterators">
<span id="index-3"></span><h2>11.1.6.8. Array Iterators<a class="headerlink" href="#array-iterators" title="Permalink to this headline">¶</a></h2>
<p id="index-4">Iterators are a powerful concept for array processing. Essentially,
iterators implement a generalized for-loop. If <em>myiter</em> is an iterator
object, then the Python code:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span>for val in myiter:
    ...
    some code involving val
    ...
</pre></div>
</div>
<p>calls <code class="docutils literal"><span class="pre">val</span> <span class="pre">=</span> <span class="pre">myiter.next()</span></code> repeatedly until <code class="xref py py-exc docutils literal"><span class="pre">StopIteration</span></code> is
raised by the iterator. There are several ways to iterate over an
array that may be useful: default iteration, flat iteration, and
<span class="math">\(N\)</span>-dimensional enumeration.</p>
<div class="section" id="default-iteration">
<h3>11.1.6.8.1. Default iteration<a class="headerlink" href="#default-iteration" title="Permalink to this headline">¶</a></h3>
<p>The default iterator of an ndarray object is the default Python
iterator of a sequence type. Thus, when the array object itself is
used as an iterator. The default behavior is equivalent to:</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>This default iterator selects a sub-array of dimension <span class="math">\(N-1\)</span>
from the array. This can be a useful construct for defining recursive
algorithms. To loop over the entire array requires <span class="math">\(N\)</span> for-loops.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">arange</span><span class="p">(</span><span class="mi">24</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">a</span><span class="p">:</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="s1">&#39;item:&#39;</span><span class="p">,</span> <span class="n">val</span>
<span class="go">item: [[10 11 12 13]</span>
<span class="go"> [14 15 16 17]]</span>
<span class="go">item: [[18 19 20 21]</span>
<span class="go"> [22 23 24 25]]</span>
<span class="go">item: [[26 27 28 29]</span>
<span class="go"> [30 31 32 33]]</span>
</pre></div>
</div>
</div>
<div class="section" id="flat-iteration">
<h3>11.1.6.8.2. Flat iteration<a class="headerlink" href="#flat-iteration" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ndarray.flat.html#numpy.ndarray.flat" title="numpy.ndarray.flat"><code class="xref py py-obj docutils literal"><span class="pre">ndarray.flat</span></code></a></td>
<td>A 1-D iterator over the array.</td>
</tr>
</tbody>
</table>
<p>As mentioned previously, the flat attribute of ndarray objects returns
an iterator that will cycle over the entire array in C-style
contiguous order.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">flat</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="n">i</span><span class="o">%</span><span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span>
<span class="go">0 10</span>
<span class="go">5 15</span>
<span class="go">10 20</span>
<span class="go">15 25</span>
<span class="go">20 30</span>
</pre></div>
</div>
<p>Here, I&#8217;ve used the built-in enumerate iterator to return the iterator
index as well as the value.</p>
</div>
<div class="section" id="n-dimensional-enumeration">
<h3>11.1.6.8.3. N-dimensional enumeration<a class="headerlink" href="#n-dimensional-enumeration" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.ndenumerate.html#numpy.ndenumerate" title="numpy.ndenumerate"><code class="xref py py-obj docutils literal"><span class="pre">ndenumerate</span></code></a>(arr)</td>
<td>Multidimensional index iterator.</td>
</tr>
</tbody>
</table>
<p>Sometimes it may be useful to get the N-dimensional index while
iterating. The ndenumerate iterator can achieve this.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">ndenumerate</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">%</span><span class="mi">5</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="k">print</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span>
<span class="go">(0, 0, 0) 10</span>
<span class="go">(1, 1, 3) 25</span>
<span class="go">(2, 0, 3) 29</span>
<span class="go">(2, 1, 2) 32</span>
</pre></div>
</div>
</div>
<div class="section" id="iterator-for-broadcasting">
<h3>11.1.6.8.4. Iterator for broadcasting<a class="headerlink" href="#iterator-for-broadcasting" title="Permalink to this headline">¶</a></h3>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="generated/numpy.broadcast.html#numpy.broadcast" title="numpy.broadcast"><code class="xref py py-obj docutils literal"><span class="pre">broadcast</span></code></a></td>
<td>Produce an object that mimics broadcasting.</td>
</tr>
</tbody>
</table>
<p>The general concept of broadcasting is also available from Python
using the <a class="reference internal" href="generated/numpy.broadcast.html#numpy.broadcast" title="numpy.broadcast"><code class="xref py py-class docutils literal"><span class="pre">broadcast</span></code></a> iterator. This object takes <span class="math">\(N\)</span>
objects as inputs and returns an iterator that returns tuples
providing each of the input sequence elements in the broadcasted
result.</p>
<div class="highlight-python"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">broadcast</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],[</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]):</span>
<span class="gp">... </span>    <span class="k">print</span> <span class="n">val</span>
<span class="go">(1, 0)</span>
<span class="go">(0, 1)</span>
<span class="go">(2, 0)</span>
<span class="go">(3, 1)</span>
</pre></div>
</div>
</div>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="generated/numpy.matrix.T.html" class="btn btn-neutral float-right" title="11.1.6.2.1. numpy.matrix.T" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="arrays.nditer.html" class="btn btn-neutral" title="11.1.5. Iterating Over Arrays" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>