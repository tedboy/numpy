

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>numpy.linalg.linalg &mdash; Numpy API</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Numpy API" href="../../../index.html"/>
        <link rel="up" title="numpy" href="../../numpy.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Numpy API
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.html">1. NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.doc.html">2. <code class="docutils literal"><span class="pre">numpy.doc</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.lib.html">3. <code class="docutils literal"><span class="pre">numpy.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.random.html">4. <code class="docutils literal"><span class="pre">numpy.random</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.linalg.html">5. <code class="docutils literal"><span class="pre">numpy.linalg</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.fft.html">6. Discrete Fourier Transform (<code class="docutils literal"><span class="pre">numpy.fft</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.polynomial.html">7. <code class="docutils literal"><span class="pre">numpy.polynomial</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.testing.html">8. <code class="docutils literal"><span class="pre">numpy.testing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.f2py.html">9. <code class="docutils literal"><span class="pre">numpy.f2py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.distutils.html">10. <code class="docutils literal"><span class="pre">numpy.distutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">11. NumPy Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">12. Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Numpy API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../numpy.html">numpy</a> &raquo;</li>
        
      <li>numpy.linalg.linalg</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for numpy.linalg.linalg</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Lite version of scipy.linalg.</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">This module is a lite version of the linalg.py module in SciPy which</span>
<span class="sd">contains high-level Python interface to the LAPACK library.  The lite</span>
<span class="sd">version only accesses the following LAPACK functions: dgesv, zgesv,</span>
<span class="sd">dgeev, zgeev, dgesdd, zgesdd, dgelsd, zgelsd, dsyevd, zheevd, dgetrf,</span>
<span class="sd">zgetrf, dpotrf, zpotrf, dgeqrf, zgeqrf, zungqr, dorgqr.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;matrix_power&#39;</span><span class="p">,</span> <span class="s1">&#39;solve&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorsolve&#39;</span><span class="p">,</span> <span class="s1">&#39;tensorinv&#39;</span><span class="p">,</span> <span class="s1">&#39;inv&#39;</span><span class="p">,</span>
           <span class="s1">&#39;cholesky&#39;</span><span class="p">,</span> <span class="s1">&#39;eigvals&#39;</span><span class="p">,</span> <span class="s1">&#39;eigvalsh&#39;</span><span class="p">,</span> <span class="s1">&#39;pinv&#39;</span><span class="p">,</span> <span class="s1">&#39;slogdet&#39;</span><span class="p">,</span> <span class="s1">&#39;det&#39;</span><span class="p">,</span>
           <span class="s1">&#39;svd&#39;</span><span class="p">,</span> <span class="s1">&#39;eig&#39;</span><span class="p">,</span> <span class="s1">&#39;eigh&#39;</span><span class="p">,</span> <span class="s1">&#39;lstsq&#39;</span><span class="p">,</span> <span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="s1">&#39;qr&#39;</span><span class="p">,</span> <span class="s1">&#39;cond&#39;</span><span class="p">,</span> <span class="s1">&#39;matrix_rank&#39;</span><span class="p">,</span>
           <span class="s1">&#39;LinAlgError&#39;</span><span class="p">,</span> <span class="s1">&#39;multi_dot&#39;</span><span class="p">]</span>

<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">numpy.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">array</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">empty_like</span><span class="p">,</span> <span class="n">transpose</span><span class="p">,</span> <span class="n">intc</span><span class="p">,</span> <span class="n">single</span><span class="p">,</span> <span class="n">double</span><span class="p">,</span>
    <span class="n">csingle</span><span class="p">,</span> <span class="n">cdouble</span><span class="p">,</span> <span class="n">inexact</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">,</span> <span class="n">newaxis</span><span class="p">,</span> <span class="n">ravel</span><span class="p">,</span> <span class="nb">all</span><span class="p">,</span> <span class="n">Inf</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span>
    <span class="n">add</span><span class="p">,</span> <span class="n">multiply</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">maximum</span><span class="p">,</span> <span class="n">fastCopyAndTranspose</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">isfinite</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
    <span class="n">finfo</span><span class="p">,</span> <span class="n">errstate</span><span class="p">,</span> <span class="n">geterrobj</span><span class="p">,</span> <span class="n">longdouble</span><span class="p">,</span> <span class="n">rollaxis</span><span class="p">,</span> <span class="n">amin</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="n">product</span><span class="p">,</span> <span class="nb">abs</span><span class="p">,</span>
    <span class="n">broadcast</span><span class="p">,</span> <span class="n">atleast_2d</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span> <span class="n">asanyarray</span><span class="p">,</span> <span class="n">isscalar</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy.lib</span> <span class="kn">import</span> <span class="n">triu</span><span class="p">,</span> <span class="n">asfarray</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">lapack_lite</span><span class="p">,</span> <span class="n">_umath_linalg</span>
<span class="kn">from</span> <span class="nn">numpy.matrixlib.defmatrix</span> <span class="kn">import</span> <span class="n">matrix_power</span>
<span class="kn">from</span> <span class="nn">numpy.compat</span> <span class="kn">import</span> <span class="n">asbytes</span>

<span class="c1"># For Python2/3 compatibility</span>
<span class="n">_N</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;N&#39;</span><span class="p">)</span>
<span class="n">_V</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;V&#39;</span><span class="p">)</span>
<span class="n">_A</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span>
<span class="n">_S</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">)</span>
<span class="n">_L</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">)</span>

<span class="n">fortran_int</span> <span class="o">=</span> <span class="n">intc</span>

<span class="c1"># Error object</span>
<div class="viewcode-block" id="LinAlgError"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.LinAlgError.html#numpy.linalg.LinAlgError">[docs]</a><span class="k">class</span> <span class="nc">LinAlgError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic Python-exception-derived object raised by linalg functions.</span>

<span class="sd">    General purpose exception class, derived from Python&#39;s exception.Exception</span>
<span class="sd">    class, programmatically raised in linalg functions when a Linear</span>
<span class="sd">    Algebra-related condition would prevent further correct execution of the</span>
<span class="sd">    function.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    None</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; LA.inv(np.zeros((2,2)))</span>
<span class="sd">    Traceback (most recent call last):</span>
<span class="sd">      File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">      File &quot;...linalg.py&quot;, line 350,</span>
<span class="sd">        in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))</span>
<span class="sd">      File &quot;...linalg.py&quot;, line 249,</span>
<span class="sd">        in solve</span>
<span class="sd">        raise LinAlgError(&#39;Singular matrix&#39;)</span>
<span class="sd">    numpy.linalg.LinAlgError: Singular matrix</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>

<span class="c1"># Dealing with errors in _umath_linalg</span>

<span class="n">_linalg_error_extobj</span> <span class="o">=</span> <span class="bp">None</span>

<span class="k">def</span> <span class="nf">_determine_error_states</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">_linalg_error_extobj</span>
    <span class="n">errobj</span> <span class="o">=</span> <span class="n">geterrobj</span><span class="p">()</span>
    <span class="n">bufsize</span> <span class="o">=</span> <span class="n">errobj</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">with</span> <span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;call&#39;</span><span class="p">,</span> <span class="n">over</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span>
                  <span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">under</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">invalid_call_errmask</span> <span class="o">=</span> <span class="n">geterrobj</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">_linalg_error_extobj</span> <span class="o">=</span> <span class="p">[</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">invalid_call_errmask</span><span class="p">,</span> <span class="bp">None</span><span class="p">]</span>

<span class="n">_determine_error_states</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">_raise_linalgerror_singular</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Singular matrix&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_raise_linalgerror_nonposdef</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Matrix is not positive definite&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_raise_linalgerror_eigenvalues_nonconvergence</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Eigenvalues did not converge&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_raise_linalgerror_svd_nonconvergence</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;SVD did not converge&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_linalg_error_extobj</span><span class="p">(</span><span class="n">callback</span><span class="p">):</span>
    <span class="n">extobj</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_linalg_error_extobj</span><span class="p">)</span>
    <span class="n">extobj</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">callback</span>
    <span class="k">return</span> <span class="n">extobj</span>

<span class="k">def</span> <span class="nf">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">wrap</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s2">&quot;__array_prepare__&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">__array_wrap__</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new</span><span class="p">,</span> <span class="n">wrap</span>

<span class="k">def</span> <span class="nf">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">complexfloating</span><span class="p">)</span>

<span class="n">_real_types_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">single</span> <span class="p">:</span> <span class="n">single</span><span class="p">,</span>
                   <span class="n">double</span> <span class="p">:</span> <span class="n">double</span><span class="p">,</span>
                   <span class="n">csingle</span> <span class="p">:</span> <span class="n">single</span><span class="p">,</span>
                   <span class="n">cdouble</span> <span class="p">:</span> <span class="n">double</span><span class="p">}</span>

<span class="n">_complex_types_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">single</span> <span class="p">:</span> <span class="n">csingle</span><span class="p">,</span>
                      <span class="n">double</span> <span class="p">:</span> <span class="n">cdouble</span><span class="p">,</span>
                      <span class="n">csingle</span> <span class="p">:</span> <span class="n">csingle</span><span class="p">,</span>
                      <span class="n">cdouble</span> <span class="p">:</span> <span class="n">cdouble</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">_realType</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">double</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_real_types_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_complexType</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">cdouble</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">_complex_types_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_linalgRealType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Cast the type t to either double or cdouble.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">double</span>

<span class="n">_complex_types_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">single</span> <span class="p">:</span> <span class="n">csingle</span><span class="p">,</span>
                      <span class="n">double</span> <span class="p">:</span> <span class="n">cdouble</span><span class="p">,</span>
                      <span class="n">csingle</span> <span class="p">:</span> <span class="n">csingle</span><span class="p">,</span>
                      <span class="n">cdouble</span> <span class="p">:</span> <span class="n">cdouble</span><span class="p">}</span>

<span class="k">def</span> <span class="nf">_commonType</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="c1"># in lite version, use higher precision (always double or cdouble)</span>
    <span class="n">result_type</span> <span class="o">=</span> <span class="n">single</span>
    <span class="n">is_complex</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">inexact</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">):</span>
                <span class="n">is_complex</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">_realType</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rt</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># unsupported inexact scalar</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;array type </span><span class="si">%s</span><span class="s2"> is unsupported in linalg&quot;</span> <span class="o">%</span>
                        <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">name</span><span class="p">,))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rt</span> <span class="o">=</span> <span class="n">double</span>
        <span class="k">if</span> <span class="n">rt</span> <span class="ow">is</span> <span class="n">double</span><span class="p">:</span>
            <span class="n">result_type</span> <span class="o">=</span> <span class="n">double</span>
    <span class="k">if</span> <span class="n">is_complex</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">cdouble</span>
        <span class="n">result_type</span> <span class="o">=</span> <span class="n">_complex_types_map</span><span class="p">[</span><span class="n">result_type</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">double</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">result_type</span>


<span class="c1"># _fastCopyAndTranpose assumes the input is 2D (as all the calls in here are).</span>

<span class="n">_fastCT</span> <span class="o">=</span> <span class="n">fastCopyAndTranspose</span>

<span class="k">def</span> <span class="nf">_to_native_byte_order</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">arr</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">byteorder</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="s1">&#39;|&#39;</span><span class="p">):</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">newbyteorder</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ret</span>

<span class="k">def</span> <span class="nf">_fastCopyAndTranspose</span><span class="p">(</span><span class="nb">type</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="n">cast_arrays</span> <span class="o">=</span> <span class="p">()</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">:</span>
            <span class="n">cast_arrays</span> <span class="o">=</span> <span class="n">cast_arrays</span> <span class="o">+</span> <span class="p">(</span><span class="n">_fastCT</span><span class="p">(</span><span class="n">a</span><span class="p">),)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cast_arrays</span> <span class="o">=</span> <span class="n">cast_arrays</span> <span class="o">+</span> <span class="p">(</span><span class="n">_fastCT</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">type</span><span class="p">)),)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cast_arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cast_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cast_arrays</span>

<span class="k">def</span> <span class="nf">_assertRank2</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-dimensional array given. Array must be &#39;</span>
                    <span class="s1">&#39;two-dimensional&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_assertRankAtLeast2</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-dimensional array given. Array must be &#39;</span>
                    <span class="s1">&#39;at least two-dimensional&#39;</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">_assertSquareness</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;Array must be square&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_assertNdSquareness</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span> <span class="o">!=</span> <span class="nb">min</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]):</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;Last 2 dimensions of the array must be square&#39;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_assertFinite</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Array must not contain infs or NaNs&quot;</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_assertNoEmpty2d</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">product</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s2">&quot;Arrays cannot be empty&quot;</span><span class="p">)</span>


<span class="c1"># Linear equations</span>

<div class="viewcode-block" id="tensorsolve"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.tensorsolve.html#numpy.linalg.tensorsolve">[docs]</a><span class="k">def</span> <span class="nf">tensorsolve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve the tensor equation ``a x = b`` for x.</span>

<span class="sd">    It is assumed that all indices of `x` are summed over in the product,</span>
<span class="sd">    together with the rightmost indices of `a`, as is done in, for example,</span>
<span class="sd">    ``tensordot(a, x, axes=len(b.shape))``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals</span>
<span class="sd">        the shape of that sub-tensor of `a` consisting of the appropriate</span>
<span class="sd">        number of its rightmost indices, and must be such that</span>
<span class="sd">        ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be</span>
<span class="sd">        &#39;square&#39;).</span>
<span class="sd">    b : array_like</span>
<span class="sd">        Right-hand tensor, which can be of any shape.</span>
<span class="sd">    axes : tuple of ints, optional</span>
<span class="sd">        Axes in `a` to reorder to the right, before inversion.</span>
<span class="sd">        If None (default), no reordering is done.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : ndarray, shape Q</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If `a` is singular or not &#39;square&#39; (in the above sense).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    tensordot, tensorinv, einsum</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.eye(2*3*4)</span>
<span class="sd">    &gt;&gt;&gt; a.shape = (2*3, 4, 2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; b = np.random.randn(2*3, 4)</span>
<span class="sd">    &gt;&gt;&gt; x = np.linalg.tensorsolve(a, b)</span>
<span class="sd">    &gt;&gt;&gt; x.shape</span>
<span class="sd">    (2, 3, 4)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.tensordot(a, x, axes=3), b)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">an</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>

    <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">allaxes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">an</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
            <span class="n">allaxes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">allaxes</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">an</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">allaxes</span><span class="p">)</span>

    <span class="n">oldshape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="p">(</span><span class="n">an</span><span class="o">-</span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span><span class="p">):]</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldshape</span><span class="p">:</span>
        <span class="n">prod</span> <span class="o">*=</span> <span class="n">k</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">prod</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">wrap</span><span class="p">(</span><span class="n">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
    <span class="n">res</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">oldshape</span>
    <span class="k">return</span> <span class="n">res</span></div>

<div class="viewcode-block" id="solve"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.solve.html#numpy.linalg.solve">[docs]</a><span class="k">def</span> <span class="nf">solve</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solve a linear matrix equation, or system of linear scalar equations.</span>

<span class="sd">    Computes the &quot;exact&quot; solution, `x`, of the well-determined, i.e., full</span>
<span class="sd">    rank, linear matrix equation `ax = b`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        Coefficient matrix.</span>
<span class="sd">    b : {(..., M,), (..., M, K)}, array_like</span>
<span class="sd">        Ordinate or &quot;dependent variable&quot; values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : {(..., M,), (..., M, K)} ndarray</span>
<span class="sd">        Solution to the system a x = b.  Returned shape is identical to `b`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If `a` is singular or not square.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    The solutions are computed using LAPACK routine _gesv</span>

<span class="sd">    `a` must be square and of full-rank, i.e., all rows (or, equivalently,</span>
<span class="sd">    columns) must be linearly independent; if either is not true, use</span>
<span class="sd">    `lstsq` for the least-squares best &quot;solution&quot; of the</span>
<span class="sd">    system/equation.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,</span>
<span class="sd">           FL, Academic Press, Inc., 1980, pg. 22.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[3,1], [1,2]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([9,8])</span>
<span class="sd">    &gt;&gt;&gt; x = np.linalg.solve(a, b)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 2.,  3.])</span>

<span class="sd">    Check that the solution is correct:</span>

<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(a, x), b)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="c1"># We use the b = (..., M,) logic, only if the number of extra dimensions</span>
    <span class="c1"># match exactly</span>
    <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Legal, but the ufunc cannot handle the 0-sized inner dims</span>
            <span class="c1"># let the ufunc handle all wrong cases.</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">empty</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_t</span><span class="p">))</span>

        <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">solve1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="p">[:,:</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="p">,))</span>
                <span class="n">bc</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">empty</span><span class="p">(</span><span class="n">bc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_t</span><span class="p">))</span>

        <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">solve</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;DD-&gt;D&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;dd-&gt;d&#39;</span>
    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span><span class="n">_raise_linalgerror_singular</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">gufunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span></div>


<div class="viewcode-block" id="tensorinv"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.tensorinv.html#numpy.linalg.tensorinv">[docs]</a><span class="k">def</span> <span class="nf">tensorinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ind</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the &#39;inverse&#39; of an N-dimensional array.</span>

<span class="sd">    The result is an inverse for `a` relative to the tensordot operation</span>
<span class="sd">    ``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,</span>
<span class="sd">    ``tensordot(tensorinv(a), a, ind)`` is the &quot;identity&quot; tensor for the</span>
<span class="sd">    tensordot operation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Tensor to &#39;invert&#39;. Its shape must be &#39;square&#39;, i. e.,</span>
<span class="sd">        ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.</span>
<span class="sd">    ind : int, optional</span>
<span class="sd">        Number of first indices that are involved in the inverse sum.</span>
<span class="sd">        Must be a positive integer, default is 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : ndarray</span>
<span class="sd">        `a`&#39;s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If `a` is singular or not &#39;square&#39; (in the above sense).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    tensordot, tensorsolve</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.eye(4*6)</span>
<span class="sd">    &gt;&gt;&gt; a.shape = (4, 6, 8, 3)</span>
<span class="sd">    &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=2)</span>
<span class="sd">    &gt;&gt;&gt; ainv.shape</span>
<span class="sd">    (8, 3, 4, 6)</span>
<span class="sd">    &gt;&gt;&gt; b = np.random.randn(4, 6)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))</span>
<span class="sd">    True</span>

<span class="sd">    &gt;&gt;&gt; a = np.eye(4*6)</span>
<span class="sd">    &gt;&gt;&gt; a.shape = (24, 8, 3)</span>
<span class="sd">    &gt;&gt;&gt; ainv = np.linalg.tensorinv(a, ind=1)</span>
<span class="sd">    &gt;&gt;&gt; ainv.shape</span>
<span class="sd">    (8, 3, 24)</span>
<span class="sd">    &gt;&gt;&gt; b = np.random.randn(24)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">oldshape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">prod</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">ind</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">invshape</span> <span class="o">=</span> <span class="n">oldshape</span><span class="p">[</span><span class="n">ind</span><span class="p">:]</span> <span class="o">+</span> <span class="n">oldshape</span><span class="p">[:</span><span class="n">ind</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">oldshape</span><span class="p">[</span><span class="n">ind</span><span class="p">:]:</span>
            <span class="n">prod</span> <span class="o">*=</span> <span class="n">k</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid ind argument.&quot;</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">prod</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ia</span> <span class="o">=</span> <span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ia</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">invshape</span><span class="p">)</span></div>


<span class="c1"># Matrix inversion</span>

<div class="viewcode-block" id="inv"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.inv.html#numpy.linalg.inv">[docs]</a><span class="k">def</span> <span class="nf">inv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the (multiplicative) inverse of a matrix.</span>

<span class="sd">    Given a square matrix `a`, return the matrix `ainv` satisfying</span>
<span class="sd">    ``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        Matrix to be inverted.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ainv : (..., M, M) ndarray or matrix</span>
<span class="sd">        (Multiplicative) inverse of the matrix `a`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If `a` is not square or inversion fails.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.linalg import inv</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1., 2.], [3., 4.]])</span>
<span class="sd">    &gt;&gt;&gt; ainv = inv(a)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(a, ainv), np.eye(2))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(np.dot(ainv, a), np.eye(2))</span>
<span class="sd">    True</span>

<span class="sd">    If a is a matrix object, then the return value is a matrix as well:</span>

<span class="sd">    &gt;&gt;&gt; ainv = inv(np.matrix(a))</span>
<span class="sd">    &gt;&gt;&gt; ainv</span>
<span class="sd">    matrix([[-2. ,  1. ],</span>
<span class="sd">            [ 1.5, -0.5]])</span>

<span class="sd">    Inverses of several matrices can be computed at once:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])</span>
<span class="sd">    &gt;&gt;&gt; inv(a)</span>
<span class="sd">    array([[[-2. ,  1. ],</span>
<span class="sd">            [ 1.5, -0.5]],</span>
<span class="sd">           [[-5. ,  2. ],</span>
<span class="sd">            [ 3. , -1. ]]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># The inner array is 0x0, the ufunc cannot handle this case</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">empty_like</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_t</span><span class="p">))</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;D&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;d&#39;</span>
    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span><span class="n">_raise_linalgerror_singular</span><span class="p">)</span>
    <span class="n">ainv</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">ainv</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span></div>


<span class="c1"># Cholesky decomposition</span>

<div class="viewcode-block" id="cholesky"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.cholesky.html#numpy.linalg.cholesky">[docs]</a><span class="k">def</span> <span class="nf">cholesky</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cholesky decomposition.</span>

<span class="sd">    Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,</span>
<span class="sd">    where `L` is lower-triangular and .H is the conjugate transpose operator</span>
<span class="sd">    (which is the ordinary transpose if `a` is real-valued).  `a` must be</span>
<span class="sd">    Hermitian (symmetric if real-valued) and positive-definite.  Only `L` is</span>
<span class="sd">    actually returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        Hermitian (symmetric if all elements are real), positive-definite</span>
<span class="sd">        input matrix.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    L : (..., M, M) array_like</span>
<span class="sd">        Upper or lower-triangular Cholesky factor of `a`.  Returns a</span>
<span class="sd">        matrix object if `a` is a matrix object.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">       If the decomposition fails, for example, if `a` is not</span>
<span class="sd">       positive-definite.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    The Cholesky decomposition is often used as a fast way of solving</span>

<span class="sd">    .. math:: A \\mathbf{x} = \\mathbf{b}</span>

<span class="sd">    (when `A` is both Hermitian/symmetric and positive-definite).</span>

<span class="sd">    First, we solve for :math:`\\mathbf{y}` in</span>

<span class="sd">    .. math:: L \\mathbf{y} = \\mathbf{b},</span>

<span class="sd">    and then for :math:`\\mathbf{x}` in</span>

<span class="sd">    .. math:: L.H \\mathbf{x} = \\mathbf{y}.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; A = np.array([[1,-2j],[2j,5]])</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[ 1.+0.j,  0.-2.j],</span>
<span class="sd">           [ 0.+2.j,  5.+0.j]])</span>
<span class="sd">    &gt;&gt;&gt; L = np.linalg.cholesky(A)</span>
<span class="sd">    &gt;&gt;&gt; L</span>
<span class="sd">    array([[ 1.+0.j,  0.+0.j],</span>
<span class="sd">           [ 0.+2.j,  1.+0.j]])</span>
<span class="sd">    &gt;&gt;&gt; np.dot(L, L.T.conj()) # verify that L * L.H = A</span>
<span class="sd">    array([[ 1.+0.j,  0.-2.j],</span>
<span class="sd">           [ 0.+2.j,  5.+0.j]])</span>
<span class="sd">    &gt;&gt;&gt; A = [[1,-2j],[2j,5]] # what happens if A is only array_like?</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.cholesky(A) # an ndarray object is returned</span>
<span class="sd">    array([[ 1.+0.j,  0.+0.j],</span>
<span class="sd">           [ 0.+2.j,  1.+0.j]])</span>
<span class="sd">    &gt;&gt;&gt; # But a matrix object is returned if A is a matrix object</span>
<span class="sd">    &gt;&gt;&gt; LA.cholesky(np.matrix(A))</span>
<span class="sd">    matrix([[ 1.+0.j,  0.+0.j],</span>
<span class="sd">            [ 0.+2.j,  1.+0.j]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span><span class="n">_raise_linalgerror_nonposdef</span><span class="p">)</span>
    <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">cholesky_lo</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;D&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;d&#39;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">gufunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span></div>

<span class="c1"># QR decompostion</span>

<div class="viewcode-block" id="qr"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.qr.html#numpy.linalg.qr">[docs]</a><span class="k">def</span> <span class="nf">qr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;reduced&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the qr factorization of a matrix.</span>

<span class="sd">    Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is</span>
<span class="sd">    upper-triangular.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like, shape (M, N)</span>
<span class="sd">        Matrix to be factored.</span>
<span class="sd">    mode : {&#39;reduced&#39;, &#39;complete&#39;, &#39;r&#39;, &#39;raw&#39;, &#39;full&#39;, &#39;economic&#39;}, optional</span>
<span class="sd">        If K = min(M, N), then</span>

<span class="sd">        &#39;reduced&#39;  : returns q, r with dimensions (M, K), (K, N) (default)</span>
<span class="sd">        &#39;complete&#39; : returns q, r with dimensions (M, M), (M, N)</span>
<span class="sd">        &#39;r&#39;        : returns r only with dimensions (K, N)</span>
<span class="sd">        &#39;raw&#39;      : returns h, tau with dimensions (N, M), (K,)</span>
<span class="sd">        &#39;full&#39;     : alias of &#39;reduced&#39;, deprecated</span>
<span class="sd">        &#39;economic&#39; : returns h from &#39;raw&#39;, deprecated.</span>

<span class="sd">        The options &#39;reduced&#39;, &#39;complete, and &#39;raw&#39; are new in numpy 1.8,</span>
<span class="sd">        see the notes for more information. The default is &#39;reduced&#39; and to</span>
<span class="sd">        maintain backward compatibility with earlier versions of numpy both</span>
<span class="sd">        it and the old default &#39;full&#39; can be omitted. Note that array h</span>
<span class="sd">        returned in &#39;raw&#39; mode is transposed for calling Fortran. The</span>
<span class="sd">        &#39;economic&#39; mode is deprecated.  The modes &#39;full&#39; and &#39;economic&#39; may</span>
<span class="sd">        be passed using only the first letter for backwards compatibility,</span>
<span class="sd">        but all others must be spelled out. See the Notes for more</span>
<span class="sd">        explanation.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    q : ndarray of float or complex, optional</span>
<span class="sd">        A matrix with orthonormal columns. When mode = &#39;complete&#39; the</span>
<span class="sd">        result is an orthogonal/unitary matrix depending on whether or not</span>
<span class="sd">        a is real/complex. The determinant may be either +/- 1 in that</span>
<span class="sd">        case.</span>
<span class="sd">    r : ndarray of float or complex, optional</span>
<span class="sd">        The upper-triangular matrix.</span>
<span class="sd">    (h, tau) : ndarrays of np.double or np.cdouble, optional</span>
<span class="sd">        The array h contains the Householder reflectors that generate q</span>
<span class="sd">        along with r. The tau array contains scaling factors for the</span>
<span class="sd">        reflectors. In the deprecated  &#39;economic&#39; mode only h is returned.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If factoring fails.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is an interface to the LAPACK routines dgeqrf, zgeqrf,</span>
<span class="sd">    dorgqr, and zungqr.</span>

<span class="sd">    For more information on the qr factorization, see for example:</span>
<span class="sd">    http://en.wikipedia.org/wiki/QR_factorization</span>

<span class="sd">    Subclasses of `ndarray` are preserved except for the &#39;raw&#39; mode. So if</span>
<span class="sd">    `a` is of type `matrix`, all the return values will be matrices too.</span>

<span class="sd">    New &#39;reduced&#39;, &#39;complete&#39;, and &#39;raw&#39; options for mode were added in</span>
<span class="sd">    Numpy 1.8 and the old option &#39;full&#39; was made an alias of &#39;reduced&#39;.  In</span>
<span class="sd">    addition the options &#39;full&#39; and &#39;economic&#39; were deprecated.  Because</span>
<span class="sd">    &#39;full&#39; was the previous default and &#39;reduced&#39; is the new default,</span>
<span class="sd">    backward compatibility can be maintained by letting `mode` default.</span>
<span class="sd">    The &#39;raw&#39; option was added so that LAPACK routines that can multiply</span>
<span class="sd">    arrays by q using the Householder reflectors can be used. Note that in</span>
<span class="sd">    this case the returned arrays are of type np.double or np.cdouble and</span>
<span class="sd">    the h array is transposed to be FORTRAN compatible.  No routines using</span>
<span class="sd">    the &#39;raw&#39; return are currently exposed by numpy, but some are available</span>
<span class="sd">    in lapack_lite and just await the necessary work.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.randn(9, 6)</span>
<span class="sd">    &gt;&gt;&gt; q, r = np.linalg.qr(a)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(q, r))  # a does equal qr</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; r2 = np.linalg.qr(a, mode=&#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; r3 = np.linalg.qr(a, mode=&#39;economic&#39;)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(r, r2)  # mode=&#39;r&#39; returns the same r as mode=&#39;full&#39;</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; # But only triu parts are guaranteed equal when mode=&#39;economic&#39;</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(r, np.triu(r3[:6,:6], k=0))</span>
<span class="sd">    True</span>

<span class="sd">    Example illustrating a common use of `qr`: solving of least squares</span>
<span class="sd">    problems</span>

<span class="sd">    What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for</span>
<span class="sd">    the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points</span>
<span class="sd">    and you&#39;ll see that it should be y0 = 0, m = 1.)  The answer is provided</span>
<span class="sd">    by solving the over-determined matrix equation ``Ax = b``, where::</span>

<span class="sd">      A = array([[0, 1], [1, 1], [1, 1], [2, 1]])</span>
<span class="sd">      x = array([[y0], [m]])</span>
<span class="sd">      b = array([[1], [0], [2], [1]])</span>

<span class="sd">    If A = qr such that q is orthonormal (which is always possible via</span>
<span class="sd">    Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,</span>
<span class="sd">    however, we simply use `lstsq`.)</span>

<span class="sd">    &gt;&gt;&gt; A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[0, 1],</span>
<span class="sd">           [1, 1],</span>
<span class="sd">           [1, 1],</span>
<span class="sd">           [2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; b = np.array([1, 0, 2, 1])</span>
<span class="sd">    &gt;&gt;&gt; q, r = LA.qr(A)</span>
<span class="sd">    &gt;&gt;&gt; p = np.dot(q.T, b)</span>
<span class="sd">    &gt;&gt;&gt; np.dot(LA.inv(r), p)</span>
<span class="sd">    array([  1.1e-16,   1.0e+00])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;reduced&#39;</span><span class="p">,</span> <span class="s1">&#39;complete&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="s1">&#39;raw&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;full&#39;</span><span class="p">):</span>
            <span class="c1"># 2013-04-01, 1.8</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span>
                    <span class="s2">&quot;The &#39;full&#39; option is deprecated in favor of &#39;reduced&#39;.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;For backward compatibility let mode default.&quot;</span><span class="p">))</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;reduced&#39;</span>
        <span class="k">elif</span> <span class="n">mode</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;economic&#39;</span><span class="p">):</span>
            <span class="c1"># 2013-04-01, 1.8</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The &#39;economic&#39; option is deprecated.&quot;</span><span class="p">,</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s1">&#39;economic&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unrecognized mode &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="n">mode</span><span class="p">)</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRank2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNoEmpty2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">m</span><span class="p">,</span> <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_fastCopyAndTranspose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_to_native_byte_order</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mn</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">tau</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">mn</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">lapack_routine</span> <span class="o">=</span> <span class="n">lapack_lite</span><span class="o">.</span><span class="n">zgeqrf</span>
        <span class="n">routine_name</span> <span class="o">=</span> <span class="s1">&#39;zgeqrf&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lapack_routine</span> <span class="o">=</span> <span class="n">lapack_lite</span><span class="o">.</span><span class="n">dgeqrf</span>
        <span class="n">routine_name</span> <span class="o">=</span> <span class="s1">&#39;dgeqrf&#39;</span>

    <span class="c1"># calculate optimal size of work data &#39;work&#39;</span>
    <span class="n">lwork</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> returns </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">routine_name</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]))</span>

    <span class="c1"># do qr decomposition</span>
    <span class="n">lwork</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">work</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">lwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> returns </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">routine_name</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]))</span>

    <span class="c1"># handle modes that don&#39;t return q</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_fastCopyAndTranspose</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="n">mn</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">triu</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;raw&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">tau</span>

    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;economic&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">result_t</span> <span class="p">:</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="c1">#  generate q from a</span>
    <span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="s1">&#39;complete&#39;</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
        <span class="n">mc</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">empty</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mc</span> <span class="o">=</span> <span class="n">mn</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">q</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>

    <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">lapack_routine</span> <span class="o">=</span> <span class="n">lapack_lite</span><span class="o">.</span><span class="n">zungqr</span>
        <span class="n">routine_name</span> <span class="o">=</span> <span class="s1">&#39;zungqr&#39;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lapack_routine</span> <span class="o">=</span> <span class="n">lapack_lite</span><span class="o">.</span><span class="n">dorgqr</span>
        <span class="n">routine_name</span> <span class="o">=</span> <span class="s1">&#39;dorgqr&#39;</span>

    <span class="c1"># determine optimal lwork</span>
    <span class="n">lwork</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mc</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> returns </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">routine_name</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]))</span>

    <span class="c1"># compute q</span>
    <span class="n">lwork</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">work</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">mc</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">lwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> returns </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">routine_name</span><span class="p">,</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]))</span>

    <span class="n">q</span> <span class="o">=</span> <span class="n">_fastCopyAndTranspose</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">q</span><span class="p">[:</span><span class="n">mc</span><span class="p">])</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">_fastCopyAndTranspose</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">a</span><span class="p">[:,</span> <span class="p">:</span><span class="n">mc</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">q</span><span class="p">),</span> <span class="n">wrap</span><span class="p">(</span><span class="n">triu</span><span class="p">(</span><span class="n">r</span><span class="p">))</span></div>


<span class="c1"># Eigenvalues</span>


<div class="viewcode-block" id="eigvals"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.eigvals.html#numpy.linalg.eigvals">[docs]</a><span class="k">def</span> <span class="nf">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenvalues of a general matrix.</span>

<span class="sd">    Main difference between `eigvals` and `eig`: the eigenvectors aren&#39;t</span>
<span class="sd">    returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        A complex- or real-valued matrix whose eigenvalues will be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (..., M,) ndarray</span>
<span class="sd">        The eigenvalues, each repeated according to its multiplicity.</span>
<span class="sd">        They are not necessarily ordered, nor are they necessarily</span>
<span class="sd">        real for real matrices.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If the eigenvalue computation does not converge.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    eig : eigenvalues and right eigenvectors of general arrays</span>
<span class="sd">    eigvalsh : eigenvalues of symmetric or Hermitian arrays.</span>
<span class="sd">    eigh : eigenvalues and eigenvectors of symmetric/Hermitian arrays.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    This is implemented using the _geev LAPACK routines which compute</span>
<span class="sd">    the eigenvalues and eigenvectors of general square arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Illustration, using the fact that the eigenvalues of a diagonal matrix</span>
<span class="sd">    are its diagonal elements, that multiplying a matrix on the left</span>
<span class="sd">    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose</span>
<span class="sd">    of `Q`), preserves the eigenvalues of the &quot;middle&quot; matrix.  In other words,</span>
<span class="sd">    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as</span>
<span class="sd">    ``A``:</span>

<span class="sd">    &gt;&gt;&gt; from numpy import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; x = np.random.random()</span>
<span class="sd">    &gt;&gt;&gt; Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])</span>
<span class="sd">    (1.0, 1.0, 0.0)</span>

<span class="sd">    Now multiply a diagonal matrix by Q on one side and by Q.T on the other:</span>

<span class="sd">    &gt;&gt;&gt; D = np.diag((-1,1))</span>
<span class="sd">    &gt;&gt;&gt; LA.eigvals(D)</span>
<span class="sd">    array([-1.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; A = np.dot(Q, D)</span>
<span class="sd">    &gt;&gt;&gt; A = np.dot(A, Q.T)</span>
<span class="sd">    &gt;&gt;&gt; LA.eigvals(A)</span>
<span class="sd">    array([ 1., -1.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNoEmpty2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertFinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span>
        <span class="n">_raise_linalgerror_eigenvalues_nonconvergence</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;D&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;D&#39;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">eigvals</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">real</span>
            <span class="n">result_t</span> <span class="o">=</span> <span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result_t</span> <span class="o">=</span> <span class="n">_complexType</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="eigvalsh"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.eigvalsh.html#numpy.linalg.eigvalsh">[docs]</a><span class="k">def</span> <span class="nf">eigvalsh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenvalues of a Hermitian or real symmetric matrix.</span>

<span class="sd">    Main difference from eigh: the eigenvectors are not computed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        A complex- or real-valued matrix whose eigenvalues are to be</span>
<span class="sd">        computed.</span>
<span class="sd">    UPLO : {&#39;L&#39;, &#39;U&#39;}, optional</span>
<span class="sd">        Same as `lower`, with &#39;L&#39; for lower and &#39;U&#39; for upper triangular.</span>
<span class="sd">        Deprecated.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (..., M,) ndarray</span>
<span class="sd">        The eigenvalues in ascending order, each repeated according to</span>
<span class="sd">        its multiplicity.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If the eigenvalue computation does not converge.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    eigh : eigenvalues and eigenvectors of symmetric/Hermitian arrays.</span>
<span class="sd">    eigvals : eigenvalues of general real or complex arrays.</span>
<span class="sd">    eig : eigenvalues and right eigenvectors of general real or complex</span>
<span class="sd">          arrays.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    The eigenvalues are computed using LAPACK routines _syevd, _heevd</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])</span>
<span class="sd">    &gt;&gt;&gt; LA.eigvalsh(a)</span>
<span class="sd">    array([ 0.17157288,  5.82842712])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">UPLO</span> <span class="o">=</span> <span class="n">UPLO</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">UPLO</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UPLO argument must be &#39;L&#39; or &#39;U&#39;&quot;</span><span class="p">)</span>

    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span>
        <span class="n">_raise_linalgerror_eigenvalues_nonconvergence</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">UPLO</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">eigvalsh_lo</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">eigvalsh_up</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNoEmpty2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;d&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;d&#39;</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">gufunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_convertarray</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">_fastCT</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span>


<span class="c1"># Eigenvectors</span>


<div class="viewcode-block" id="eig"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.eig.html#numpy.linalg.eig">[docs]</a><span class="k">def</span> <span class="nf">eig</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the eigenvalues and right eigenvectors of a square array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array</span>
<span class="sd">        Matrices for which the eigenvalues and right eigenvectors will</span>
<span class="sd">        be computed</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (..., M) array</span>
<span class="sd">        The eigenvalues, each repeated according to its multiplicity.</span>
<span class="sd">        The eigenvalues are not necessarily ordered. The resulting</span>
<span class="sd">        array will be of complex type, unless the imaginary part is</span>
<span class="sd">        zero in which case it will be cast to a real type. When `a`</span>
<span class="sd">        is real the resulting eigenvalues will be real (0 imaginary</span>
<span class="sd">        part) or occur in conjugate pairs</span>

<span class="sd">    v : (..., M, M) array</span>
<span class="sd">        The normalized (unit &quot;length&quot;) eigenvectors, such that the</span>
<span class="sd">        column ``v[:,i]`` is the eigenvector corresponding to the</span>
<span class="sd">        eigenvalue ``w[i]``.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If the eigenvalue computation does not converge.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    eigvals : eigenvalues of a non-symmetric array.</span>

<span class="sd">    eigh : eigenvalues and eigenvectors of a symmetric or Hermitian</span>
<span class="sd">           (conjugate symmetric) array.</span>

<span class="sd">    eigvalsh : eigenvalues of a symmetric or Hermitian (conjugate symmetric)</span>
<span class="sd">               array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    This is implemented using the _geev LAPACK routines which compute</span>
<span class="sd">    the eigenvalues and eigenvectors of general square arrays.</span>

<span class="sd">    The number `w` is an eigenvalue of `a` if there exists a vector</span>
<span class="sd">    `v` such that ``dot(a,v) = w * v``. Thus, the arrays `a`, `w`, and</span>
<span class="sd">    `v` satisfy the equations ``dot(a[:,:], v[:,i]) = w[i] * v[:,i]``</span>
<span class="sd">    for :math:`i \\in \\{0,...,M-1\\}`.</span>

<span class="sd">    The array `v` of eigenvectors may not be of maximum rank, that is, some</span>
<span class="sd">    of the columns may be linearly dependent, although round-off error may</span>
<span class="sd">    obscure that fact. If the eigenvalues are all different, then theoretically</span>
<span class="sd">    the eigenvectors are linearly independent. Likewise, the (complex-valued)</span>
<span class="sd">    matrix of eigenvectors `v` is unitary if the matrix `a` is normal, i.e.,</span>
<span class="sd">    if ``dot(a, a.H) = dot(a.H, a)``, where `a.H` denotes the conjugate</span>
<span class="sd">    transpose of `a`.</span>

<span class="sd">    Finally, it is emphasized that `v` consists of the *right* (as in</span>
<span class="sd">    right-hand side) eigenvectors of `a`.  A vector `y` satisfying</span>
<span class="sd">    ``dot(y.T, a) = z * y.T`` for some number `z` is called a *left*</span>
<span class="sd">    eigenvector of `a`, and, in general, the left and right eigenvectors</span>
<span class="sd">    of a matrix are not necessarily the (perhaps conjugate) transposes</span>
<span class="sd">    of each other.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,</span>
<span class="sd">    Academic Press, Inc., 1980, Various pp.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import linalg as LA</span>

<span class="sd">    (Almost) trivial example with real e-values and e-vectors.</span>

<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(np.diag((1, 2, 3)))</span>
<span class="sd">    &gt;&gt;&gt; w; v</span>
<span class="sd">    array([ 1.,  2.,  3.])</span>
<span class="sd">    array([[ 1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.]])</span>

<span class="sd">    Real matrix possessing complex e-values and e-vectors; note that the</span>
<span class="sd">    e-values are complex conjugates of each other.</span>

<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(np.array([[1, -1], [1, 1]]))</span>
<span class="sd">    &gt;&gt;&gt; w; v</span>
<span class="sd">    array([ 1. + 1.j,  1. - 1.j])</span>
<span class="sd">    array([[ 0.70710678+0.j        ,  0.70710678+0.j        ],</span>
<span class="sd">           [ 0.00000000-0.70710678j,  0.00000000+0.70710678j]])</span>

<span class="sd">    Complex-valued matrix with real e-values (but complex-valued e-vectors);</span>
<span class="sd">    note that a.conj().T = a, i.e., a is Hermitian.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1j], [-1j, 1]])</span>
<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(a)</span>
<span class="sd">    &gt;&gt;&gt; w; v</span>
<span class="sd">    array([  2.00000000e+00+0.j,   5.98651912e-36+0.j]) # i.e., {2, 0}</span>
<span class="sd">    array([[ 0.00000000+0.70710678j,  0.70710678+0.j        ],</span>
<span class="sd">           [ 0.70710678+0.j        ,  0.00000000+0.70710678j]])</span>

<span class="sd">    Be careful about round-off error!</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])</span>
<span class="sd">    &gt;&gt;&gt; # Theor. e-values are 1 +/- 1e-9</span>
<span class="sd">    &gt;&gt;&gt; w, v = LA.eig(a)</span>
<span class="sd">    &gt;&gt;&gt; w; v</span>
<span class="sd">    array([ 1.,  1.])</span>
<span class="sd">    array([[ 1.,  0.],</span>
<span class="sd">           [ 0.,  1.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertFinite</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span>
        <span class="n">_raise_linalgerror_eigenvalues_nonconvergence</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;DD&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;DD&#39;</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">imag</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">real</span>
        <span class="n">vt</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">real</span>
        <span class="n">result_t</span> <span class="o">=</span> <span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result_t</span> <span class="o">=</span> <span class="n">_complexType</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>

    <span class="n">vt</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">),</span> <span class="n">wrap</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span></div>


<div class="viewcode-block" id="eigh"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.eigh.html#numpy.linalg.eigh">[docs]</a><span class="k">def</span> <span class="nf">eigh</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">UPLO</span><span class="o">=</span><span class="s1">&#39;L&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the eigenvalues and eigenvectors of a Hermitian or symmetric matrix.</span>

<span class="sd">    Returns two objects, a 1-D array containing the eigenvalues of `a`, and</span>
<span class="sd">    a 2-D square array or matrix (depending on the input type) of the</span>
<span class="sd">    corresponding eigenvectors (in columns).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array</span>
<span class="sd">        Hermitian/Symmetric matrices whose eigenvalues and</span>
<span class="sd">        eigenvectors are to be computed.</span>
<span class="sd">    UPLO : {&#39;L&#39;, &#39;U&#39;}, optional</span>
<span class="sd">        Specifies whether the calculation is done with the lower triangular</span>
<span class="sd">        part of `a` (&#39;L&#39;, default) or the upper triangular part (&#39;U&#39;).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    w : (..., M) ndarray</span>
<span class="sd">        The eigenvalues in ascending order, each repeated according to</span>
<span class="sd">        its multiplicity.</span>
<span class="sd">    v : {(..., M, M) ndarray, (..., M, M) matrix}</span>
<span class="sd">        The column ``v[:, i]`` is the normalized eigenvector corresponding</span>
<span class="sd">        to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is</span>
<span class="sd">        a matrix object.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If the eigenvalue computation does not converge.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    eigvalsh : eigenvalues of symmetric or Hermitian arrays.</span>
<span class="sd">    eig : eigenvalues and right eigenvectors for non-symmetric arrays.</span>
<span class="sd">    eigvals : eigenvalues of non-symmetric arrays.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    The eigenvalues/eigenvectors are computed using LAPACK routines _syevd,</span>
<span class="sd">    _heevd</span>

<span class="sd">    The eigenvalues of real symmetric or complex Hermitian matrices are</span>
<span class="sd">    always real. [1]_ The array `v` of (column) eigenvectors is unitary</span>
<span class="sd">    and `a`, `w`, and `v` satisfy the equations</span>
<span class="sd">    ``dot(a, v[:, i]) = w[i] * v[:, i]``.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,</span>
<span class="sd">           FL, Academic Press, Inc., 1980, pg. 222.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, -2j], [2j, 5]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 1.+0.j,  0.-2.j],</span>
<span class="sd">           [ 0.+2.j,  5.+0.j]])</span>
<span class="sd">    &gt;&gt;&gt; w, v = LA.eigh(a)</span>
<span class="sd">    &gt;&gt;&gt; w; v</span>
<span class="sd">    array([ 0.17157288,  5.82842712])</span>
<span class="sd">    array([[-0.92387953+0.j        , -0.38268343+0.j        ],</span>
<span class="sd">           [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])</span>

<span class="sd">    &gt;&gt;&gt; np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair</span>
<span class="sd">    array([2.77555756e-17 + 0.j, 0. + 1.38777878e-16j])</span>
<span class="sd">    &gt;&gt;&gt; np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair</span>
<span class="sd">    array([ 0.+0.j,  0.+0.j])</span>

<span class="sd">    &gt;&gt;&gt; A = np.matrix(a) # what happens if input is a matrix object</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    matrix([[ 1.+0.j,  0.-2.j],</span>
<span class="sd">            [ 0.+2.j,  5.+0.j]])</span>
<span class="sd">    &gt;&gt;&gt; w, v = LA.eigh(A)</span>
<span class="sd">    &gt;&gt;&gt; w; v</span>
<span class="sd">    array([ 0.17157288,  5.82842712])</span>
<span class="sd">    matrix([[-0.92387953+0.j        , -0.38268343+0.j        ],</span>
<span class="sd">            [ 0.00000000+0.38268343j,  0.00000000-0.92387953j]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">UPLO</span> <span class="o">=</span> <span class="n">UPLO</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">UPLO</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;L&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;UPLO argument must be &#39;L&#39; or &#39;U&#39;&quot;</span><span class="p">)</span>

    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span>
        <span class="n">_raise_linalgerror_eigenvalues_nonconvergence</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">UPLO</span> <span class="o">==</span> <span class="s1">&#39;L&#39;</span><span class="p">:</span>
        <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">eigh_lo</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">eigh_up</span>

    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;dD&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;dd&#39;</span>
    <span class="n">w</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">gufunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">vt</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">,</span> <span class="n">wrap</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span></div>


<span class="c1"># Singular value decomposition</span>

<div class="viewcode-block" id="svd"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.svd.html#numpy.linalg.svd">[docs]</a><span class="k">def</span> <span class="nf">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Singular Value Decomposition.</span>

<span class="sd">    Factors the matrix `a` as ``u * np.diag(s) * v``, where `u` and `v`</span>
<span class="sd">    are unitary and `s` is a 1-d array of `a`&#39;s singular values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, N) array_like</span>
<span class="sd">        A real or complex matrix of shape (`M`, `N`) .</span>
<span class="sd">    full_matrices : bool, optional</span>
<span class="sd">        If True (default), `u` and `v` have the shapes (`M`, `M`) and</span>
<span class="sd">        (`N`, `N`), respectively.  Otherwise, the shapes are (`M`, `K`)</span>
<span class="sd">        and (`K`, `N`), respectively, where `K` = min(`M`, `N`).</span>
<span class="sd">    compute_uv : bool, optional</span>
<span class="sd">        Whether or not to compute `u` and `v` in addition to `s`.  True</span>
<span class="sd">        by default.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    u : { (..., M, M), (..., M, K) } array</span>
<span class="sd">        Unitary matrices. The actual shape depends on the value of</span>
<span class="sd">        ``full_matrices``. Only returned when ``compute_uv`` is True.</span>
<span class="sd">    s : (..., K) array</span>
<span class="sd">        The singular values for every matrix, sorted in descending order.</span>
<span class="sd">    v : { (..., N, N), (..., K, N) } array</span>
<span class="sd">        Unitary matrices. The actual shape depends on the value of</span>
<span class="sd">        ``full_matrices``. Only returned when ``compute_uv`` is True.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If SVD computation does not converge.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    The decomposition is performed using LAPACK routine _gesdd</span>

<span class="sd">    The SVD is commonly written as ``a = U S V.H``.  The `v` returned</span>
<span class="sd">    by this function is ``V.H`` and ``u = U``.</span>

<span class="sd">    If ``U`` is a unitary matrix, it means that it</span>
<span class="sd">    satisfies ``U.H = inv(U)``.</span>

<span class="sd">    The rows of `v` are the eigenvectors of ``a.H a``. The columns</span>
<span class="sd">    of `u` are the eigenvectors of ``a a.H``.  For row ``i`` in</span>
<span class="sd">    `v` and column ``i`` in `u`, the corresponding eigenvalue is</span>
<span class="sd">    ``s[i]**2``.</span>

<span class="sd">    If `a` is a `matrix` object (as opposed to an `ndarray`), then so</span>
<span class="sd">    are all the return values.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)</span>

<span class="sd">    Reconstruction based on full SVD:</span>

<span class="sd">    &gt;&gt;&gt; U, s, V = np.linalg.svd(a, full_matrices=True)</span>
<span class="sd">    &gt;&gt;&gt; U.shape, V.shape, s.shape</span>
<span class="sd">    ((9, 9), (6, 6), (6,))</span>
<span class="sd">    &gt;&gt;&gt; S = np.zeros((9, 6), dtype=complex)</span>
<span class="sd">    &gt;&gt;&gt; S[:6, :6] = np.diag(s)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(U, np.dot(S, V)))</span>
<span class="sd">    True</span>

<span class="sd">    Reconstruction based on reduced SVD:</span>

<span class="sd">    &gt;&gt;&gt; U, s, V = np.linalg.svd(a, full_matrices=False)</span>
<span class="sd">    &gt;&gt;&gt; U.shape, V.shape, s.shape</span>
<span class="sd">    ((9, 6), (6, 6), (6,))</span>
<span class="sd">    &gt;&gt;&gt; S = np.diag(s)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(U, np.dot(S, V)))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNoEmpty2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

    <span class="n">extobj</span> <span class="o">=</span> <span class="n">get_linalg_error_extobj</span><span class="p">(</span><span class="n">_raise_linalgerror_svd_nonconvergence</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">compute_uv</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">full_matrices</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">svd_m_f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">svd_n_f</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">svd_m_s</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">svd_n_s</span>

        <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;DdD&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;ddd&#39;</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">gufunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">vt</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">u</span><span class="p">),</span> <span class="n">s</span><span class="p">,</span> <span class="n">wrap</span><span class="p">(</span><span class="n">vt</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">svd_m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gufunc</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">svd_n</span>

        <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;d&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;d&#39;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">gufunc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">,</span> <span class="n">extobj</span><span class="o">=</span><span class="n">extobj</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="cond"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.cond.html#numpy.linalg.cond">[docs]</a><span class="k">def</span> <span class="nf">cond</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the condition number of a matrix.</span>

<span class="sd">    This function is capable of returning the condition number using</span>
<span class="sd">    one of seven different norms, depending on the value of `p` (see</span>
<span class="sd">    Parameters below).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : (..., M, N) array_like</span>
<span class="sd">        The matrix whose condition number is sought.</span>
<span class="sd">    p : {None, 1, -1, 2, -2, inf, -inf, &#39;fro&#39;}, optional</span>
<span class="sd">        Order of the norm:</span>

<span class="sd">        =====  ============================</span>
<span class="sd">        p      norm for matrices</span>
<span class="sd">        =====  ============================</span>
<span class="sd">        None   2-norm, computed directly using the ``SVD``</span>
<span class="sd">        &#39;fro&#39;  Frobenius norm</span>
<span class="sd">        inf    max(sum(abs(x), axis=1))</span>
<span class="sd">        -inf   min(sum(abs(x), axis=1))</span>
<span class="sd">        1      max(sum(abs(x), axis=0))</span>
<span class="sd">        -1     min(sum(abs(x), axis=0))</span>
<span class="sd">        2      2-norm (largest sing. value)</span>
<span class="sd">        -2     smallest singular value</span>
<span class="sd">        =====  ============================</span>

<span class="sd">        inf means the numpy.inf object, and the Frobenius norm is</span>
<span class="sd">        the root-of-sum-of-squares norm.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : {float, inf}</span>
<span class="sd">        The condition number of the matrix. May be infinite.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.linalg.norm</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The condition number of `x` is defined as the norm of `x` times the</span>
<span class="sd">    norm of the inverse of `x` [1]_; the norm can be the usual L2-norm</span>
<span class="sd">    (root-of-sum-of-squares) or one of a number of other matrix norms.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,</span>
<span class="sd">           Academic Press, Inc., 1980, pg. 285.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 1,  0, -1],</span>
<span class="sd">           [ 0,  1,  0],</span>
<span class="sd">           [ 1,  0,  1]])</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a)</span>
<span class="sd">    1.4142135623730951</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a, &#39;fro&#39;)</span>
<span class="sd">    3.1622776601683795</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a, np.inf)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a, -np.inf)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a, 1)</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a, -1)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a, 2)</span>
<span class="sd">    1.4142135623730951</span>
<span class="sd">    &gt;&gt;&gt; LA.cond(a, -2)</span>
<span class="sd">    0.70710678118654746</span>
<span class="sd">    &gt;&gt;&gt; min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))</span>
<span class="sd">    0.70710678118654746</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># in case we have a matrix</span>
    <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">*</span> <span class="n">norm</span><span class="p">(</span><span class="n">inv</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">p</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span></div>


<div class="viewcode-block" id="matrix_rank"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.matrix_rank.html#numpy.linalg.matrix_rank">[docs]</a><span class="k">def</span> <span class="nf">matrix_rank</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return matrix rank of array using SVD method</span>

<span class="sd">    Rank of the array is the number of SVD singular values of the array that are</span>
<span class="sd">    greater than `tol`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    M : {(M,), (M, N)} array_like</span>
<span class="sd">        array of &lt;=2 dimensions</span>
<span class="sd">    tol : {None, float}, optional</span>
<span class="sd">       threshold below which SVD values are considered zero. If `tol` is</span>
<span class="sd">       None, and ``S`` is an array with singular values for `M`, and</span>
<span class="sd">       ``eps`` is the epsilon value for datatype of ``S``, then `tol` is</span>
<span class="sd">       set to ``S.max() * max(M.shape) * eps``.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The default threshold to detect rank deficiency is a test on the magnitude</span>
<span class="sd">    of the singular values of `M`.  By default, we identify singular values less</span>
<span class="sd">    than ``S.max() * max(M.shape) * eps`` as indicating rank deficiency (with</span>
<span class="sd">    the symbols defined above). This is the algorithm MATLAB uses [1].  It also</span>
<span class="sd">    appears in *Numerical recipes* in the discussion of SVD solutions for linear</span>
<span class="sd">    least squares [2].</span>

<span class="sd">    This default threshold is designed to detect rank deficiency accounting for</span>
<span class="sd">    the numerical errors of the SVD computation.  Imagine that there is a column</span>
<span class="sd">    in `M` that is an exact (in floating point) linear combination of other</span>
<span class="sd">    columns in `M`. Computing the SVD on `M` will not produce a singular value</span>
<span class="sd">    exactly equal to 0 in general: any difference of the smallest SVD value from</span>
<span class="sd">    0 will be caused by numerical imprecision in the calculation of the SVD.</span>
<span class="sd">    Our threshold for small SVD values takes this numerical imprecision into</span>
<span class="sd">    account, and the default threshold will detect such numerical rank</span>
<span class="sd">    deficiency.  The threshold may declare a matrix `M` rank deficient even if</span>
<span class="sd">    the linear combination of some columns of `M` is not exactly equal to</span>
<span class="sd">    another column of `M` but only numerically very close to another column of</span>
<span class="sd">    `M`.</span>

<span class="sd">    We chose our default threshold because it is in wide use.  Other thresholds</span>
<span class="sd">    are possible.  For example, elsewhere in the 2007 edition of *Numerical</span>
<span class="sd">    recipes* there is an alternative threshold of ``S.max() *</span>
<span class="sd">    np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe</span>
<span class="sd">    this threshold as being based on &quot;expected roundoff error&quot; (p 71).</span>

<span class="sd">    The thresholds above deal with floating point roundoff error in the</span>
<span class="sd">    calculation of the SVD.  However, you may have more information about the</span>
<span class="sd">    sources of error in `M` that would make you consider other tolerance values</span>
<span class="sd">    to detect *effective* rank deficiency.  The most useful measure of the</span>
<span class="sd">    tolerance depends on the operations you intend to use on your matrix.  For</span>
<span class="sd">    example, if your data come from uncertain measurements with uncertainties</span>
<span class="sd">    greater than floating point epsilon, choosing a tolerance near that</span>
<span class="sd">    uncertainty may be preferable.  The tolerance may be absolute if the</span>
<span class="sd">    uncertainties are absolute rather than relative.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] MATLAB reference documention, &quot;Rank&quot;</span>
<span class="sd">           http://www.mathworks.com/help/techdoc/ref/rank.html</span>
<span class="sd">    .. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,</span>
<span class="sd">           &quot;Numerical Recipes (3rd edition)&quot;, Cambridge University Press, 2007,</span>
<span class="sd">           page 795.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.linalg import matrix_rank</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(np.eye(4)) # Full rank matrix</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(I)</span>
<span class="sd">    3</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; matrix_rank(np.zeros((4,)))</span>
<span class="sd">    0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">M</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;array should have 2 or fewer dimensions&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">M</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">M</span><span class="o">==</span><span class="mi">0</span><span class="p">))</span>
    <span class="n">S</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">tol</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">*</span> <span class="n">finfo</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">eps</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">S</span> <span class="o">&gt;</span> <span class="n">tol</span><span class="p">)</span></div>


<span class="c1"># Generalized inverse</span>

<div class="viewcode-block" id="pinv"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.pinv.html#numpy.linalg.pinv">[docs]</a><span class="k">def</span> <span class="nf">pinv</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="mf">1e-15</span> <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the (Moore-Penrose) pseudo-inverse of a matrix.</span>

<span class="sd">    Calculate the generalized inverse of a matrix using its</span>
<span class="sd">    singular-value decomposition (SVD) and including all</span>
<span class="sd">    *large* singular values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M, N) array_like</span>
<span class="sd">      Matrix to be pseudo-inverted.</span>
<span class="sd">    rcond : float</span>
<span class="sd">      Cutoff for small singular values.</span>
<span class="sd">      Singular values smaller (in modulus) than</span>
<span class="sd">      `rcond` * largest_singular_value (again, in modulus)</span>
<span class="sd">      are set to zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    B : (N, M) ndarray</span>
<span class="sd">      The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so</span>
<span class="sd">      is `B`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">      If the SVD computation does not converge.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The pseudo-inverse of a matrix A, denoted :math:`A^+`, is</span>
<span class="sd">    defined as: &quot;the matrix that &#39;solves&#39; [the least-squares problem]</span>
<span class="sd">    :math:`Ax = b`,&quot; i.e., if :math:`\\bar{x}` is said solution, then</span>
<span class="sd">    :math:`A^+` is that matrix such that :math:`\\bar{x} = A^+b`.</span>

<span class="sd">    It can be shown that if :math:`Q_1 \\Sigma Q_2^T = A` is the singular</span>
<span class="sd">    value decomposition of A, then</span>
<span class="sd">    :math:`A^+ = Q_2 \\Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are</span>
<span class="sd">    orthogonal matrices, :math:`\\Sigma` is a diagonal matrix consisting</span>
<span class="sd">    of A&#39;s so-called singular values, (followed, typically, by</span>
<span class="sd">    zeros), and then :math:`\\Sigma^+` is simply the diagonal matrix</span>
<span class="sd">    consisting of the reciprocals of A&#39;s singular values</span>
<span class="sd">    (again, followed by zeros). [1]_</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,</span>
<span class="sd">           FL, Academic Press, Inc., 1980, pp. 139-142.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The following example checks that ``a * a+ * a == a`` and</span>
<span class="sd">    ``a+ * a * a+ == a+``:</span>

<span class="sd">    &gt;&gt;&gt; a = np.random.randn(9, 6)</span>
<span class="sd">    &gt;&gt;&gt; B = np.linalg.pinv(a)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(a, np.dot(a, np.dot(B, a)))</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(B, np.dot(B, np.dot(a, B)))</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNoEmpty2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span>
    <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vt</span> <span class="o">=</span> <span class="n">svd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">vt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cutoff</span> <span class="o">=</span> <span class="n">rcond</span><span class="o">*</span><span class="n">maximum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">cutoff</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span><span class="p">;</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">vt</span><span class="p">),</span> <span class="n">multiply</span><span class="p">(</span><span class="n">s</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">],</span> <span class="n">transpose</span><span class="p">(</span><span class="n">u</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

<span class="c1"># Determinant</span>

<div class="viewcode-block" id="slogdet"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.slogdet.html#numpy.linalg.slogdet">[docs]</a><span class="k">def</span> <span class="nf">slogdet</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the sign and (natural) logarithm of the determinant of an array.</span>

<span class="sd">    If an array has a very small or very large determinant, then a call to</span>
<span class="sd">    `det` may overflow or underflow. This routine is more robust against such</span>
<span class="sd">    issues, because it computes the logarithm of the determinant rather than</span>
<span class="sd">    the determinant itself.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        Input array, has to be a square 2-D array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    sign : (...) array_like</span>
<span class="sd">        A number representing the sign of the determinant. For a real matrix,</span>
<span class="sd">        this is 1, 0, or -1. For a complex matrix, this is a complex number</span>
<span class="sd">        with absolute value 1 (i.e., it is on the unit circle), or else 0.</span>
<span class="sd">    logdet : (...) array_like</span>
<span class="sd">        The natural log of the absolute value of the determinant.</span>

<span class="sd">    If the determinant is zero, then `sign` will be 0 and `logdet` will be</span>
<span class="sd">    -Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    det</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    .. versionadded:: 1.6.0.</span>

<span class="sd">    The determinant is computed via LU factorization using the LAPACK</span>
<span class="sd">    routine z/dgetrf.</span>


<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; (sign, logdet) = np.linalg.slogdet(a)</span>
<span class="sd">    &gt;&gt;&gt; (sign, logdet)</span>
<span class="sd">    (-1, 0.69314718055994529)</span>
<span class="sd">    &gt;&gt;&gt; sign * np.exp(logdet)</span>
<span class="sd">    -2.0</span>

<span class="sd">    Computing log-determinants for a stack of matrices:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])</span>
<span class="sd">    &gt;&gt;&gt; a.shape</span>
<span class="sd">    (3, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; sign, logdet = np.linalg.slogdet(a)</span>
<span class="sd">    &gt;&gt;&gt; (sign, logdet)</span>
<span class="sd">    (array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))</span>
<span class="sd">    &gt;&gt;&gt; sign * np.exp(logdet)</span>
<span class="sd">    array([-2., -3., -8.])</span>

<span class="sd">    This routine succeeds where ordinary `det` does not:</span>

<span class="sd">    &gt;&gt;&gt; np.linalg.det(np.eye(500) * 0.1)</span>
<span class="sd">    0.0</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.slogdet(np.eye(500) * 0.1)</span>
<span class="sd">    (1, -1151.2925464970228)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNoEmpty2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">real_t</span> <span class="o">=</span> <span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;Dd&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;dd&#39;</span>
    <span class="n">sign</span><span class="p">,</span> <span class="n">logdet</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">slogdet</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">sign</span><span class="p">):</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sign</span> <span class="o">=</span> <span class="n">sign</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">logdet</span><span class="p">):</span>
        <span class="n">logdet</span> <span class="o">=</span> <span class="n">logdet</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">real_t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logdet</span> <span class="o">=</span> <span class="n">logdet</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">real_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sign</span><span class="p">,</span> <span class="n">logdet</span></div>

<div class="viewcode-block" id="det"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.det.html#numpy.linalg.det">[docs]</a><span class="k">def</span> <span class="nf">det</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the determinant of an array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (..., M, M) array_like</span>
<span class="sd">        Input array to compute determinants for.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    det : (...) array_like</span>
<span class="sd">        Determinant of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    slogdet : Another way to representing the determinant, more suitable</span>
<span class="sd">      for large matrices where underflow/overflow may occur.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Broadcasting rules apply, see the `numpy.linalg` documentation for</span>
<span class="sd">    details.</span>

<span class="sd">    The determinant is computed via LU factorization using the LAPACK</span>
<span class="sd">    routine z/dgetrf.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.det(a)</span>
<span class="sd">    -2.0</span>

<span class="sd">    Computing determinants for a stack of matrices:</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])</span>
<span class="sd">    &gt;&gt;&gt; a.shape</span>
<span class="sd">    (3, 2, 2)</span>
<span class="sd">    &gt;&gt;&gt; np.linalg.det(a)</span>
<span class="sd">    array([-2., -3., -8.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNoEmpty2d</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertRankAtLeast2</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">_assertNdSquareness</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">signature</span> <span class="o">=</span> <span class="s1">&#39;D-&gt;D&#39;</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;d-&gt;d&#39;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">_umath_linalg</span><span class="o">.</span><span class="n">det</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">signature</span><span class="o">=</span><span class="n">signature</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isscalar</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">r</span></div>

<span class="c1"># Linear Least Squares</span>

<div class="viewcode-block" id="lstsq"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.lstsq.html#numpy.linalg.lstsq">[docs]</a><span class="k">def</span> <span class="nf">lstsq</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=-</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the least-squares solution to a linear matrix equation.</span>

<span class="sd">    Solves the equation `a x = b` by computing a vector `x` that</span>
<span class="sd">    minimizes the Euclidean 2-norm `|| b - a x ||^2`.  The equation may</span>
<span class="sd">    be under-, well-, or over- determined (i.e., the number of</span>
<span class="sd">    linearly independent rows of `a` can be less than, equal to, or</span>
<span class="sd">    greater than its number of linearly independent columns).  If `a`</span>
<span class="sd">    is square and of full rank, then `x` (but for round-off error) is</span>
<span class="sd">    the &quot;exact&quot; solution of the equation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : (M, N) array_like</span>
<span class="sd">        &quot;Coefficient&quot; matrix.</span>
<span class="sd">    b : {(M,), (M, K)} array_like</span>
<span class="sd">        Ordinate or &quot;dependent variable&quot; values. If `b` is two-dimensional,</span>
<span class="sd">        the least-squares solution is calculated for each of the `K` columns</span>
<span class="sd">        of `b`.</span>
<span class="sd">    rcond : float, optional</span>
<span class="sd">        Cut-off ratio for small singular values of `a`.</span>
<span class="sd">        Singular values are set to zero if they are smaller than `rcond`</span>
<span class="sd">        times the largest singular value of `a`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    x : {(N,), (N, K)} ndarray</span>
<span class="sd">        Least-squares solution. If `b` is two-dimensional,</span>
<span class="sd">        the solutions are in the `K` columns of `x`.</span>
<span class="sd">    residuals : {(), (1,), (K,)} ndarray</span>
<span class="sd">        Sums of residuals; squared Euclidean 2-norm for each column in</span>
<span class="sd">        ``b - a*x``.</span>
<span class="sd">        If the rank of `a` is &lt; N or M &lt;= N, this is an empty array.</span>
<span class="sd">        If `b` is 1-dimensional, this is a (1,) shape array.</span>
<span class="sd">        Otherwise the shape is (K,).</span>
<span class="sd">    rank : int</span>
<span class="sd">        Rank of matrix `a`.</span>
<span class="sd">    s : (min(M, N),) ndarray</span>
<span class="sd">        Singular values of `a`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    LinAlgError</span>
<span class="sd">        If computation does not converge.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If `b` is a matrix, then all array results are returned as matrices.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Fit a line, ``y = mx + c``, through some noisy data-points:</span>

<span class="sd">    &gt;&gt;&gt; x = np.array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; y = np.array([-1, 0.2, 0.9, 2.1])</span>

<span class="sd">    By examining the coefficients, we see that the line should have a</span>
<span class="sd">    gradient of roughly 1 and cut the y-axis at, more or less, -1.</span>

<span class="sd">    We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``</span>
<span class="sd">    and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:</span>

<span class="sd">    &gt;&gt;&gt; A = np.vstack([x, np.ones(len(x))]).T</span>
<span class="sd">    &gt;&gt;&gt; A</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 1.,  1.],</span>
<span class="sd">           [ 2.,  1.],</span>
<span class="sd">           [ 3.,  1.]])</span>

<span class="sd">    &gt;&gt;&gt; m, c = np.linalg.lstsq(A, y)[0]</span>
<span class="sd">    &gt;&gt;&gt; print m, c</span>
<span class="sd">    1.0 -0.95</span>

<span class="sd">    Plot the data along with the fitted line:</span>

<span class="sd">    &gt;&gt;&gt; import matplotlib.pyplot as plt</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, y, &#39;o&#39;, label=&#39;Original data&#39;, markersize=10)</span>
<span class="sd">    &gt;&gt;&gt; plt.plot(x, m*x + c, &#39;r&#39;, label=&#39;Fitted line&#39;)</span>
<span class="sd">    &gt;&gt;&gt; plt.legend()</span>
<span class="sd">    &gt;&gt;&gt; plt.show()</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">math</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">b</span><span class="p">,</span> <span class="n">wrap</span> <span class="o">=</span> <span class="n">_makearray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">is_1d</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">is_1d</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">[:,</span> <span class="n">newaxis</span><span class="p">]</span>
    <span class="n">_assertRank2</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">m</span>  <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">n</span>  <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">n_rhs</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">ldb</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;Incompatible dimensions&#39;</span><span class="p">)</span>
    <span class="n">t</span><span class="p">,</span> <span class="n">result_t</span> <span class="o">=</span> <span class="n">_commonType</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">result_real_t</span> <span class="o">=</span> <span class="n">_realType</span><span class="p">(</span><span class="n">result_t</span><span class="p">)</span>
    <span class="n">real_t</span> <span class="o">=</span> <span class="n">_linalgRealType</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">bstar</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">ldb</span><span class="p">,</span> <span class="n">n_rhs</span><span class="p">),</span> <span class="n">t</span><span class="p">)</span>
    <span class="n">bstar</span><span class="p">[:</span><span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:</span><span class="n">n_rhs</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">bstar</span> <span class="o">=</span> <span class="n">_fastCopyAndTranspose</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">bstar</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">bstar</span> <span class="o">=</span> <span class="n">_to_native_byte_order</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">bstar</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),),</span> <span class="n">real_t</span><span class="p">)</span>
    <span class="n">nlvl</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span> <span class="n">math</span><span class="o">.</span><span class="n">log</span><span class="p">(</span> <span class="nb">float</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span> <span class="p">)</span> <span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">)</span>
    <span class="n">iwork</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span><span class="o">*</span><span class="n">nlvl</span><span class="o">+</span><span class="mi">11</span><span class="o">*</span><span class="nb">min</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),),</span> <span class="n">fortran_int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
        <span class="n">lapack_routine</span> <span class="o">=</span> <span class="n">lapack_lite</span><span class="o">.</span><span class="n">zgelsd</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">rwork</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">real_t</span><span class="p">)</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_rhs</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bstar</span><span class="p">,</span> <span class="n">ldb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span>
                                 <span class="mi">0</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">rwork</span><span class="p">,</span> <span class="n">iwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">work</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">rwork</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">real_t</span><span class="p">)</span>
        <span class="n">a_real</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">real_t</span><span class="p">)</span>
        <span class="n">bstar_real</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">ldb</span><span class="p">,</span> <span class="n">n_rhs</span><span class="p">,),</span> <span class="n">real_t</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_lite</span><span class="o">.</span><span class="n">dgelsd</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_rhs</span><span class="p">,</span> <span class="n">a_real</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span>
                                     <span class="n">bstar_real</span><span class="p">,</span> <span class="n">ldb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span>
                                     <span class="mi">0</span><span class="p">,</span> <span class="n">rwork</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">iwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">lrwork</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rwork</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">rwork</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lrwork</span><span class="p">,),</span> <span class="n">real_t</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_rhs</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bstar</span><span class="p">,</span> <span class="n">ldb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span>
                                 <span class="mi">0</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">lwork</span><span class="p">,</span> <span class="n">rwork</span><span class="p">,</span> <span class="n">iwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">lapack_routine</span> <span class="o">=</span> <span class="n">lapack_lite</span><span class="o">.</span><span class="n">dgelsd</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_rhs</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bstar</span><span class="p">,</span> <span class="n">ldb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span>
                                 <span class="mi">0</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">iwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">lwork</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">work</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">work</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">lwork</span><span class="p">,),</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">lapack_routine</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">n_rhs</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">bstar</span><span class="p">,</span> <span class="n">ldb</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span>
                                 <span class="mi">0</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">lwork</span><span class="p">,</span> <span class="n">iwork</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;info&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LinAlgError</span><span class="p">(</span><span class="s1">&#39;SVD did not converge in Linear Least Squares&#39;</span><span class="p">)</span>
    <span class="n">resids</span> <span class="o">=</span> <span class="n">array</span><span class="p">([],</span> <span class="n">result_real_t</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_1d</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">bstar</span><span class="p">)[:</span><span class="n">n</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ravel</span><span class="p">(</span><span class="n">bstar</span><span class="p">)[</span><span class="n">n</span><span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)],</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">result_real_t</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="n">array</span><span class="p">([</span><span class="nb">sum</span><span class="p">((</span><span class="n">ravel</span><span class="p">(</span><span class="n">bstar</span><span class="p">)[</span><span class="n">n</span><span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)],</span>
                               <span class="n">dtype</span><span class="o">=</span><span class="n">result_real_t</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">bstar</span><span class="p">)[:</span><span class="n">n</span><span class="p">,:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">result_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;rank&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">transpose</span><span class="p">(</span><span class="n">bstar</span><span class="p">)[</span><span class="n">n</span><span class="p">:,:])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="n">result_real_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">resids</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">((</span><span class="n">transpose</span><span class="p">(</span><span class="n">bstar</span><span class="p">)[</span><span class="n">n</span><span class="p">:,:])</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="n">result_real_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">st</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="nb">min</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">result_real_t</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrap</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">wrap</span><span class="p">(</span><span class="n">resids</span><span class="p">),</span> <span class="n">results</span><span class="p">[</span><span class="s1">&#39;rank&#39;</span><span class="p">],</span> <span class="n">st</span></div>


<span class="k">def</span> <span class="nf">_multi_svd_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">row_axis</span><span class="p">,</span> <span class="n">col_axis</span><span class="p">,</span> <span class="n">op</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Compute a function of the singular values of the 2-D matrices in `x`.</span>

<span class="sd">    This is a private utility function used by numpy.linalg.norm().</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">    row_axis, col_axis : int</span>
<span class="sd">        The axes of `x` that hold the 2-D matrices.</span>
<span class="sd">    op : callable</span>
<span class="sd">        This should be either numpy.amin or numpy.amax or numpy.sum.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : float or ndarray</span>
<span class="sd">        If `x` is 2-D, the return values is a float.</span>
<span class="sd">        Otherwise, it is an array with ``x.ndim - 2`` dimensions.</span>
<span class="sd">        The return values are either the minimum or maximum or sum of the</span>
<span class="sd">        singular values of the matrices, depending on whether `op`</span>
<span class="sd">        is `numpy.amin` or `numpy.amax` or `numpy.sum`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">row_axis</span> <span class="o">&gt;</span> <span class="n">col_axis</span><span class="p">:</span>
        <span class="n">row_axis</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">rollaxis</span><span class="p">(</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">col_axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">),</span> <span class="n">row_axis</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">svd</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="norm"><a class="viewcode-back" href="../../../reference/generated/numpy.linalg.norm.html#numpy.linalg.norm">[docs]</a><span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">ord</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Matrix or vector norm.</span>

<span class="sd">    This function is able to return one of eight different matrix norms,</span>
<span class="sd">    or one of an infinite number of vector norms (described below), depending</span>
<span class="sd">    on the value of the ``ord`` parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Input array.  If `axis` is None, `x` must be 1-D or 2-D.</span>
<span class="sd">    ord : {non-zero int, inf, -inf, &#39;fro&#39;, &#39;nuc&#39;}, optional</span>
<span class="sd">        Order of the norm (see table under ``Notes``). inf means numpy&#39;s</span>
<span class="sd">        `inf` object.</span>
<span class="sd">    axis : {int, 2-tuple of ints, None}, optional</span>
<span class="sd">        If `axis` is an integer, it specifies the axis of `x` along which to</span>
<span class="sd">        compute the vector norms.  If `axis` is a 2-tuple, it specifies the</span>
<span class="sd">        axes that hold 2-D matrices, and the matrix norms of these matrices</span>
<span class="sd">        are computed.  If `axis` is None then either a vector norm (when `x`</span>
<span class="sd">        is 1-D) or a matrix norm (when `x` is 2-D) is returned.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are normed over are left in the</span>
<span class="sd">        result as dimensions with size one.  With this option the result will</span>
<span class="sd">        broadcast correctly against the original `x`.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    n : float or ndarray</span>
<span class="sd">        Norm of the matrix or vector(s).</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For values of ``ord &lt;= 0``, the result is, strictly speaking, not a</span>
<span class="sd">    mathematical &#39;norm&#39;, but it may still be useful for various numerical</span>
<span class="sd">    purposes.</span>

<span class="sd">    The following norms can be calculated:</span>

<span class="sd">    =====  ============================  ==========================</span>
<span class="sd">    ord    norm for matrices             norm for vectors</span>
<span class="sd">    =====  ============================  ==========================</span>
<span class="sd">    None   Frobenius norm                2-norm</span>
<span class="sd">    &#39;fro&#39;  Frobenius norm                --</span>
<span class="sd">    &#39;nuc&#39;  nuclear norm                  --</span>
<span class="sd">    inf    max(sum(abs(x), axis=1))      max(abs(x))</span>
<span class="sd">    -inf   min(sum(abs(x), axis=1))      min(abs(x))</span>
<span class="sd">    0      --                            sum(x != 0)</span>
<span class="sd">    1      max(sum(abs(x), axis=0))      as below</span>
<span class="sd">    -1     min(sum(abs(x), axis=0))      as below</span>
<span class="sd">    2      2-norm (largest sing. value)  as below</span>
<span class="sd">    -2     smallest singular value       as below</span>
<span class="sd">    other  --                            sum(abs(x)**ord)**(1./ord)</span>
<span class="sd">    =====  ============================  ==========================</span>

<span class="sd">    The Frobenius norm is given by [1]_:</span>

<span class="sd">        :math:`||A||_F = [\\sum_{i,j} abs(a_{i,j})^2]^{1/2}`</span>

<span class="sd">    The nuclear norm is the sum of the singular values.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,</span>
<span class="sd">           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy import linalg as LA</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9) - 4</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([-4, -3, -2, -1,  0,  1,  2,  3,  4])</span>
<span class="sd">    &gt;&gt;&gt; b = a.reshape((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([[-4, -3, -2],</span>
<span class="sd">           [-1,  0,  1],</span>
<span class="sd">           [ 2,  3,  4]])</span>

<span class="sd">    &gt;&gt;&gt; LA.norm(a)</span>
<span class="sd">    7.745966692414834</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b)</span>
<span class="sd">    7.745966692414834</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b, &#39;fro&#39;)</span>
<span class="sd">    7.745966692414834</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(a, np.inf)</span>
<span class="sd">    4</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b, np.inf)</span>
<span class="sd">    9</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(a, -np.inf)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b, -np.inf)</span>
<span class="sd">    2</span>

<span class="sd">    &gt;&gt;&gt; LA.norm(a, 1)</span>
<span class="sd">    20</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b, 1)</span>
<span class="sd">    7</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(a, -1)</span>
<span class="sd">    -4.6566128774142013e-010</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b, -1)</span>
<span class="sd">    6</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(a, 2)</span>
<span class="sd">    7.745966692414834</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b, 2)</span>
<span class="sd">    7.3484692283495345</span>

<span class="sd">    &gt;&gt;&gt; LA.norm(a, -2)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(b, -2)</span>
<span class="sd">    1.8570331885190563e-016</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(a, 3)</span>
<span class="sd">    5.8480354764257312</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(a, -3)</span>
<span class="sd">    nan</span>

<span class="sd">    Using the `axis` argument to compute vector norms:</span>

<span class="sd">    &gt;&gt;&gt; c = np.array([[ 1, 2, 3],</span>
<span class="sd">    ...               [-1, 1, 4]])</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(c, axis=0)</span>
<span class="sd">    array([ 1.41421356,  2.23606798,  5.        ])</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(c, axis=1)</span>
<span class="sd">    array([ 3.74165739,  4.24264069])</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(c, ord=1, axis=1)</span>
<span class="sd">    array([6, 6])</span>

<span class="sd">    Using the `axis` argument to compute matrix norms:</span>

<span class="sd">    &gt;&gt;&gt; m = np.arange(8).reshape(2,2,2)</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(m, axis=(1,2))</span>
<span class="sd">    array([  3.74165739,  11.22497216])</span>
<span class="sd">    &gt;&gt;&gt; LA.norm(m[0, :, :]), LA.norm(m[1, :, :])</span>
<span class="sd">    (3.7416573867739413, 11.224972160321824)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># Immediately handle some default, simple, fast, and common cases.</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="p">((</span><span class="nb">ord</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">ord</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">or</span>
            <span class="p">(</span><span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)):</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">):</span>
                <span class="n">sqnorm</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">real</span><span class="p">)</span> <span class="o">+</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sqnorm</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">sqnorm</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ndim</span><span class="o">*</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="c1"># Normalize the `axis` argument to a tuple.</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;&#39;axis&#39; must be None, an integer or a tuple of integers&quot;</span><span class="p">)</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">Inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="o">-</span><span class="n">Inf</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Zero norm</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># special case for speedup</span>
            <span class="k">return</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># special case for speedup</span>
            <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
            <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="nb">ord</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid norm order for vectors.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">longdouble</span><span class="p">:</span>
                <span class="c1"># Convert to a float type, so integer arrays give</span>
                <span class="c1"># float results.  Don&#39;t apply asfarray to longdouble arrays,</span>
                <span class="c1"># because it will downcast to float64.</span>
                <span class="n">absx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">absx</span> <span class="o">=</span> <span class="n">x</span> <span class="k">if</span> <span class="n">isComplexType</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span> <span class="k">else</span> <span class="n">asfarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">absx</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="n">x</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
                    <span class="n">absx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">absx</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># if the type changed, we can safely overwrite absx</span>
                    <span class="nb">abs</span><span class="p">(</span><span class="n">absx</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">absx</span><span class="p">)</span>
            <span class="n">absx</span> <span class="o">**=</span> <span class="nb">ord</span>
            <span class="k">return</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">absx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">ord</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">row_axis</span><span class="p">,</span> <span class="n">col_axis</span> <span class="o">=</span> <span class="n">axis</span>
        <span class="k">if</span> <span class="n">row_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">row_axis</span> <span class="o">+=</span> <span class="n">nd</span>
        <span class="k">if</span> <span class="n">col_axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">col_axis</span> <span class="o">+=</span> <span class="n">nd</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row_axis</span> <span class="o">&lt;</span> <span class="n">nd</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">col_axis</span> <span class="o">&lt;</span> <span class="n">nd</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid axis </span><span class="si">%r</span><span class="s1"> for an array with shape </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span>
                             <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">row_axis</span> <span class="o">==</span> <span class="n">col_axis</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Duplicate axes given.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span>  <span class="n">_multi_svd_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">row_axis</span><span class="p">,</span> <span class="n">col_axis</span><span class="p">,</span> <span class="n">amax</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">_multi_svd_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">row_axis</span><span class="p">,</span> <span class="n">col_axis</span><span class="p">,</span> <span class="n">amin</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col_axis</span> <span class="o">&gt;</span> <span class="n">row_axis</span><span class="p">:</span>
                <span class="n">col_axis</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">row_axis</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">col_axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="n">Inf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row_axis</span> <span class="o">&gt;</span> <span class="n">col_axis</span><span class="p">:</span>
                <span class="n">row_axis</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">col_axis</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">row_axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">col_axis</span> <span class="o">&gt;</span> <span class="n">row_axis</span><span class="p">:</span>
                <span class="n">col_axis</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">row_axis</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">col_axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="o">-</span><span class="n">Inf</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">row_axis</span> <span class="o">&gt;</span> <span class="n">col_axis</span><span class="p">:</span>
                <span class="n">row_axis</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">col_axis</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">row_axis</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;fro&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">]:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="n">x</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">ord</span> <span class="o">==</span> <span class="s1">&#39;nuc&#39;</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">_multi_svd_norm</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">row_axis</span><span class="p">,</span> <span class="n">col_axis</span><span class="p">,</span> <span class="nb">sum</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid norm order for matrices.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
            <span class="n">ret_shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">ret_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ret_shape</span><span class="p">[</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ret_shape</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Improper number of dimensions to norm.&quot;</span><span class="p">)</span></div>


<span class="c1"># multi_dot</span>

<div class="viewcode-block" id="multi_dot"><a class="viewcode-back" href="../../../generated/numpy.linalg.multi_dot.html#numpy.linalg.multi_dot">[docs]</a><span class="k">def</span> <span class="nf">multi_dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the dot product of two or more arrays in a single function call,</span>
<span class="sd">    while automatically selecting the fastest evaluation order.</span>

<span class="sd">    `multi_dot` chains `numpy.dot` and uses optimal parenthesization</span>
<span class="sd">    of the matrices [1]_ [2]_. Depending on the shapes of the matrices,</span>
<span class="sd">    this can speed up the multiplication a lot.</span>

<span class="sd">    If the first argument is 1-D it is treated as a row vector.</span>
<span class="sd">    If the last argument is 1-D it is treated as a column vector.</span>
<span class="sd">    The other arguments must be 2-D.</span>

<span class="sd">    Think of `multi_dot` as::</span>

<span class="sd">        def multi_dot(arrays): return functools.reduce(np.dot, arrays)</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : sequence of array_like</span>
<span class="sd">        If the first argument is 1-D it is treated as row vector.</span>
<span class="sd">        If the last argument is 1-D it is treated as column vector.</span>
<span class="sd">        The other arguments must be 2-D.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        Returns the dot product of the supplied arrays.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dot : dot multiplication with two arguments.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>

<span class="sd">    .. [1] Cormen, &quot;Introduction to Algorithms&quot;, Chapter 15.2, p. 370-378</span>
<span class="sd">    .. [2] http://en.wikipedia.org/wiki/Matrix_chain_multiplication</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    `multi_dot` allows you to write::</span>

<span class="sd">    &gt;&gt;&gt; from numpy.linalg import multi_dot</span>
<span class="sd">    &gt;&gt;&gt; # Prepare some data</span>
<span class="sd">    &gt;&gt;&gt; A = np.random.random(10000, 100)</span>
<span class="sd">    &gt;&gt;&gt; B = np.random.random(100, 1000)</span>
<span class="sd">    &gt;&gt;&gt; C = np.random.random(1000, 5)</span>
<span class="sd">    &gt;&gt;&gt; D = np.random.random(5, 333)</span>
<span class="sd">    &gt;&gt;&gt; # the actual dot multiplication</span>
<span class="sd">    &gt;&gt;&gt; multi_dot([A, B, C, D])</span>

<span class="sd">    instead of::</span>

<span class="sd">    &gt;&gt;&gt; np.dot(np.dot(np.dot(A, B), C), D)</span>
<span class="sd">    &gt;&gt;&gt; # or</span>
<span class="sd">    &gt;&gt;&gt; A.dot(B).dot(C).dot(D)</span>


<span class="sd">    Example: multiplication costs of different parenthesizations</span>
<span class="sd">    ------------------------------------------------------------</span>

<span class="sd">    The cost for a matrix multiplication can be calculated with the</span>
<span class="sd">    following function::</span>

<span class="sd">        def cost(A, B): return A.shape[0] * A.shape[1] * B.shape[1]</span>

<span class="sd">    Let&#39;s assume we have three matrices</span>
<span class="sd">    :math:`A_{10x100}, B_{100x5}, C_{5x50}$`.</span>

<span class="sd">    The costs for the two different parenthesizations are as follows::</span>

<span class="sd">        cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500</span>
<span class="sd">        cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="c1"># optimization only makes sense for len(arrays) &gt; 2</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expecting at least two arrays.&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>

    <span class="c1"># save original ndim to reshape the result array into the proper form later</span>
    <span class="n">ndim_first</span><span class="p">,</span> <span class="n">ndim_last</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span>
    <span class="c1"># Explicitly convert vectors to 2D arrays to keep the logic of the internal</span>
    <span class="c1"># _multi_dot_* functions as simple as possible.</span>
    <span class="k">if</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>
    <span class="n">_assertRank2</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>

    <span class="c1"># _multi_dot_three is much faster than _multi_dot_matrix_chain_order</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_multi_dot_three</span><span class="p">(</span><span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">order</span> <span class="o">=</span> <span class="n">_multi_dot_matrix_chain_order</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_multi_dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># return proper shape</span>
    <span class="k">if</span> <span class="n">ndim_first</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ndim_last</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># scalar</span>
    <span class="k">elif</span> <span class="n">ndim_first</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">ndim_last</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>  <span class="c1"># 1-D</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">_multi_dot_three</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the best order for three arrays and do the multiplication.</span>

<span class="sd">    For three arguments `_multi_dot_three` is approximately 15 times faster</span>
<span class="sd">    than `_multi_dot_matrix_chain_order`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># cost1 = cost((AB)C)</span>
    <span class="n">cost1</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>  <span class="c1"># (AB)</span>
             <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># (--)C</span>
    <span class="c1"># cost2 = cost((AB)C)</span>
    <span class="n">cost2</span> <span class="o">=</span> <span class="p">(</span><span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>  <span class="c1">#  (BC)</span>
             <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>   <span class="c1"># A(--)</span>

    <span class="k">if</span> <span class="n">cost1</span> <span class="o">&lt;</span> <span class="n">cost2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">),</span> <span class="n">C</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">dot</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">_multi_dot_matrix_chain_order</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">return_costs</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a np.array that encodes the optimal order of mutiplications.</span>

<span class="sd">    The optimal order array is then used by `_multi_dot()` to do the</span>
<span class="sd">    multiplication.</span>

<span class="sd">    Also return the cost matrix if `return_costs` is `True`</span>

<span class="sd">    The implementation CLOSELY follows Cormen, &quot;Introduction to Algorithms&quot;,</span>
<span class="sd">    Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.</span>

<span class="sd">        cost[i, j] = min([</span>
<span class="sd">            cost[prefix] + cost[suffix] + cost_mult(prefix, suffix)</span>
<span class="sd">            for k in range(i, j)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="c1"># p stores the dimensions of the matrices</span>
    <span class="c1"># Example for p: A_{10x100}, B_{100x5}, C_{5x50} --&gt; p = [10, 100, 5, 50]</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">arrays</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="c1"># m is a matrix of costs of the subproblems</span>
    <span class="c1"># m[i,j]: min number of scalar multiplications needed to compute A_{i..j}</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">double</span><span class="p">)</span>
    <span class="c1"># s is the actual ordering</span>
    <span class="c1"># s[i, j] is the value of k at which we split the product A_i..A_j</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">empty</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">intp</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">l</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">l</span>
            <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Inf</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                <span class="n">q</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span> <span class="o">+</span> <span class="n">m</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">p</span><span class="p">[</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">q</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                    <span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">q</span>
                    <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>  <span class="c1"># Note that Cormen uses 1-based index</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">if</span> <span class="n">return_costs</span> <span class="k">else</span> <span class="n">s</span>


<span class="k">def</span> <span class="nf">_multi_dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Actually do the multiplication with the given order.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">_multi_dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]),</span>
                   <span class="n">_multi_dot</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">order</span><span class="p">,</span> <span class="n">order</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>