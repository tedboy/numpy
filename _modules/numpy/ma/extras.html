

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>numpy.ma.extras &mdash; Numpy API</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Numpy API" href="../../../index.html"/>
        <link rel="up" title="numpy" href="../../numpy.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Numpy API
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.html">1. NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.doc.html">2. <code class="docutils literal"><span class="pre">numpy.doc</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.lib.html">3. <code class="docutils literal"><span class="pre">numpy.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.random.html">4. <code class="docutils literal"><span class="pre">numpy.random</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.linalg.html">5. <code class="docutils literal"><span class="pre">numpy.linalg</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.fft.html">6. Discrete Fourier Transform (<code class="docutils literal"><span class="pre">numpy.fft</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.polynomial.html">7. <code class="docutils literal"><span class="pre">numpy.polynomial</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.testing.html">8. <code class="docutils literal"><span class="pre">numpy.testing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.f2py.html">9. <code class="docutils literal"><span class="pre">numpy.f2py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.distutils.html">10. <code class="docutils literal"><span class="pre">numpy.distutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">11. NumPy Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">12. Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Numpy API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../numpy.html">numpy</a> &raquo;</li>
        
      <li>numpy.ma.extras</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for numpy.ma.extras</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Masked arrays add-ons.</span>

<span class="sd">A collection of utilities for `numpy.ma`.</span>

<span class="sd">:author: Pierre Gerard-Marchant</span>
<span class="sd">:contact: pierregm_at_uga_dot_edu</span>
<span class="sd">:version: $Id: extras.py 3473 2007-10-29 15:18:13Z jarrod.millman $</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;apply_along_axis&#39;</span><span class="p">,</span> <span class="s1">&#39;apply_over_axes&#39;</span><span class="p">,</span> <span class="s1">&#39;atleast_1d&#39;</span><span class="p">,</span> <span class="s1">&#39;atleast_2d&#39;</span><span class="p">,</span>
    <span class="s1">&#39;atleast_3d&#39;</span><span class="p">,</span> <span class="s1">&#39;average&#39;</span><span class="p">,</span> <span class="s1">&#39;clump_masked&#39;</span><span class="p">,</span> <span class="s1">&#39;clump_unmasked&#39;</span><span class="p">,</span>
    <span class="s1">&#39;column_stack&#39;</span><span class="p">,</span> <span class="s1">&#39;compress_cols&#39;</span><span class="p">,</span> <span class="s1">&#39;compress_nd&#39;</span><span class="p">,</span> <span class="s1">&#39;compress_rowcols&#39;</span><span class="p">,</span>
    <span class="s1">&#39;compress_rows&#39;</span><span class="p">,</span> <span class="s1">&#39;count_masked&#39;</span><span class="p">,</span> <span class="s1">&#39;corrcoef&#39;</span><span class="p">,</span> <span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="s1">&#39;diagflat&#39;</span><span class="p">,</span> <span class="s1">&#39;dot&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dstack&#39;</span><span class="p">,</span> <span class="s1">&#39;ediff1d&#39;</span><span class="p">,</span> <span class="s1">&#39;flatnotmasked_contiguous&#39;</span><span class="p">,</span> <span class="s1">&#39;flatnotmasked_edges&#39;</span><span class="p">,</span>
    <span class="s1">&#39;hsplit&#39;</span><span class="p">,</span> <span class="s1">&#39;hstack&#39;</span><span class="p">,</span> <span class="s1">&#39;in1d&#39;</span><span class="p">,</span> <span class="s1">&#39;intersect1d&#39;</span><span class="p">,</span> <span class="s1">&#39;mask_cols&#39;</span><span class="p">,</span> <span class="s1">&#39;mask_rowcols&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mask_rows&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_all&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_all_like&#39;</span><span class="p">,</span> <span class="s1">&#39;median&#39;</span><span class="p">,</span> <span class="s1">&#39;mr_&#39;</span><span class="p">,</span>
    <span class="s1">&#39;notmasked_contiguous&#39;</span><span class="p">,</span> <span class="s1">&#39;notmasked_edges&#39;</span><span class="p">,</span> <span class="s1">&#39;polyfit&#39;</span><span class="p">,</span> <span class="s1">&#39;row_stack&#39;</span><span class="p">,</span>
    <span class="s1">&#39;setdiff1d&#39;</span><span class="p">,</span> <span class="s1">&#39;setxor1d&#39;</span><span class="p">,</span> <span class="s1">&#39;unique&#39;</span><span class="p">,</span> <span class="s1">&#39;union1d&#39;</span><span class="p">,</span> <span class="s1">&#39;vander&#39;</span><span class="p">,</span> <span class="s1">&#39;vstack&#39;</span><span class="p">,</span>
    <span class="p">]</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">core</span> <span class="k">as</span> <span class="n">ma</span>
<span class="kn">from</span> <span class="nn">.core</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">MaskedArray</span><span class="p">,</span> <span class="n">MAError</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">concatenate</span><span class="p">,</span> <span class="n">filled</span><span class="p">,</span>
    <span class="n">getmask</span><span class="p">,</span> <span class="n">getmaskarray</span><span class="p">,</span> <span class="n">make_mask_descr</span><span class="p">,</span> <span class="n">masked</span><span class="p">,</span> <span class="n">masked_array</span><span class="p">,</span> <span class="n">mask_or</span><span class="p">,</span>
    <span class="n">nomask</span><span class="p">,</span> <span class="n">ones</span><span class="p">,</span> <span class="n">sort</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">getdata</span><span class="p">,</span> <span class="n">get_masked_subclass</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span>
    <span class="n">mask_rowcols</span>
    <span class="p">)</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">array</span> <span class="k">as</span> <span class="n">nxarray</span>
<span class="kn">import</span> <span class="nn">numpy.core.umath</span> <span class="kn">as</span> <span class="nn">umath</span>
<span class="kn">from</span> <span class="nn">numpy.lib.index_tricks</span> <span class="kn">import</span> <span class="n">AxisConcatenator</span>


<span class="k">def</span> <span class="nf">issequence</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is seq a sequence (ndarray, list or tuple)?</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="count_masked"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.count_masked.html#numpy.ma.count_masked">[docs]</a><span class="k">def</span> <span class="nf">count_masked</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count the number of masked elements along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        An array with (possibly) masked elements.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to count. If None (default), a flattened</span>
<span class="sd">        version of the array is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    count : int, ndarray</span>
<span class="sd">        The total number of masked elements (axis=None) or the number</span>
<span class="sd">        of masked elements along each slice of the given axis.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.count : Count non-masked elements.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape((3,3))</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array(a)</span>
<span class="sd">    &gt;&gt;&gt; a[1, 0] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; a[1, 2] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; a[2, 1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 1 2]</span>
<span class="sd">     [-- 4 --]</span>
<span class="sd">     [6 -- 8]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False False False]</span>
<span class="sd">     [ True False  True]</span>
<span class="sd">     [False  True False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.count_masked(a)</span>
<span class="sd">    3</span>

<span class="sd">    When the `axis` keyword is used an array is returned.</span>

<span class="sd">    &gt;&gt;&gt; ma.count_masked(a, axis=0)</span>
<span class="sd">    array([1, 1, 1])</span>
<span class="sd">    &gt;&gt;&gt; ma.count_masked(a, axis=1)</span>
<span class="sd">    array([0, 2, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span></div>

<div class="viewcode-block" id="masked_all"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_all.html#numpy.ma.masked_all">[docs]</a><span class="k">def</span> <span class="nf">masked_all</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Empty masked array with all elements masked.</span>

<span class="sd">    Return an empty masked array of the given shape and dtype, where all the</span>
<span class="sd">    data are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : tuple</span>
<span class="sd">        Shape of the required MaskedArray.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type of the output.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        A masked array with all data masked.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_all_like : Empty masked array modelled on an existing array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_all((3, 3))</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[-- -- --]</span>
<span class="sd">     [-- -- --]</span>
<span class="sd">     [-- -- --]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[ True  True  True]</span>
<span class="sd">     [ True  True  True]</span>
<span class="sd">     [ True  True  True]],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    The `dtype` parameter defines the underlying data type.</span>

<span class="sd">    &gt;&gt;&gt; a = ma.masked_all((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; a.dtype</span>
<span class="sd">    dtype(&#39;float64&#39;)</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_all((3, 3), dtype=np.int32)</span>
<span class="sd">    &gt;&gt;&gt; a.dtype</span>
<span class="sd">    dtype(&#39;int32&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="p">),</span>
                     <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">a</span></div>

<div class="viewcode-block" id="masked_all_like"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_all_like.html#numpy.ma.masked_all_like">[docs]</a><span class="k">def</span> <span class="nf">masked_all_like</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Empty masked array with the properties of an existing array.</span>

<span class="sd">    Return an empty masked array of the same shape and dtype as</span>
<span class="sd">    the array `arr`, where all the data are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : ndarray</span>
<span class="sd">        An array describing the shape and dtype of the required MaskedArray.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        A masked array with all data masked.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    AttributeError</span>
<span class="sd">        If `arr` doesn&#39;t have a shape attribute (i.e. not an ndarray)</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_all : Empty masked array with all elements masked.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; arr = np.zeros((2, 3), dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([[ 0.,  0.,  0.],</span>
<span class="sd">           [ 0.,  0.,  0.]], dtype=float32)</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_all_like(arr)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[-- -- --]</span>
<span class="sd">     [-- -- --]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[ True  True  True]</span>
<span class="sd">     [ True  True  True]],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    The dtype of the masked array matches the dtype of `arr`.</span>

<span class="sd">    &gt;&gt;&gt; arr.dtype</span>
<span class="sd">    dtype(&#39;float32&#39;)</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_all_like(arr).dtype</span>
<span class="sd">    dtype(&#39;float32&#39;)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">make_mask_descr</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">a</span></div>


<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="c1">#---- --- Standard functions ---</span>
<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="k">class</span> <span class="nc">_fromnxfunction</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a wrapper to adapt NumPy functions to masked arrays.</span>


<span class="sd">    An instance of `_fromnxfunction` can be called with the same parameters</span>
<span class="sd">    as the wrapped NumPy function. The docstring of `newfunc` is adapted from</span>
<span class="sd">    the wrapped function as well, see `getdoc`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    funcname : str</span>
<span class="sd">        The name of the function to be adapted. The function should be</span>
<span class="sd">        in the NumPy namespace (i.e. ``np.funcname``).</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcname</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">funcname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getdoc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getdoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieve the docstring and signature from the function.</span>

<span class="sd">        The ``__doc__`` attribute of the function is used as the docstring for</span>
<span class="sd">        the new masked array version of the function. A note on application</span>
<span class="sd">        of the function to the mask is appended.</span>

<span class="sd">        .. warning::</span>
<span class="sd">          If the function docstring already contained a Notes section, the</span>
<span class="sd">          new docstring will have two Notes sections instead of appending a note</span>
<span class="sd">          to the existing section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">npfunc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">npfunc</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span><span class="p">:</span>
            <span class="n">sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="n">ma</span><span class="o">.</span><span class="n">get_object_signature</span><span class="p">(</span><span class="n">npfunc</span><span class="p">)</span>
            <span class="n">locdoc</span> <span class="o">=</span> <span class="s2">&quot;Notes</span><span class="se">\n</span><span class="s2">-----</span><span class="se">\n</span><span class="s2">The function is applied to both the _data&quot;</span>\
                     <span class="s2">&quot; and the _mask, if any.&quot;</span>
            <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">((</span><span class="n">sig</span><span class="p">,</span> <span class="n">doc</span><span class="p">,</span> <span class="n">locdoc</span><span class="p">))</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="n">_d</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">__array__</span><span class="p">(),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_m</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">_d</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">x</span><span class="p">]),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_m</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_d</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">issequence</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
                <span class="n">_d</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
                <span class="n">res</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">masked_array</span><span class="p">(</span><span class="n">_d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_m</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">res</span>

<span class="n">atleast_1d</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;atleast_1d&#39;</span><span class="p">)</span>
<span class="n">atleast_2d</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;atleast_2d&#39;</span><span class="p">)</span>
<span class="n">atleast_3d</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;atleast_3d&#39;</span><span class="p">)</span>
<span class="c1">#atleast_1d = np.atleast_1d</span>
<span class="c1">#atleast_2d = np.atleast_2d</span>
<span class="c1">#atleast_3d = np.atleast_3d</span>

<span class="n">vstack</span> <span class="o">=</span> <span class="n">row_stack</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;vstack&#39;</span><span class="p">)</span>
<span class="n">hstack</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;hstack&#39;</span><span class="p">)</span>
<span class="n">column_stack</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;column_stack&#39;</span><span class="p">)</span>
<span class="n">dstack</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;dstack&#39;</span><span class="p">)</span>

<span class="n">hsplit</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;hsplit&#39;</span><span class="p">)</span>

<span class="n">diagflat</span> <span class="o">=</span> <span class="n">_fromnxfunction</span><span class="p">(</span><span class="s1">&#39;diagflat&#39;</span><span class="p">)</span>


<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="c1">#----</span>
<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="k">def</span> <span class="nf">flatten_inplace</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Flatten a sequence in place.&quot;&quot;&quot;</span>
    <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)):</span>
        <span class="k">while</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
            <span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">:(</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
        <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">seq</span>


<div class="viewcode-block" id="apply_along_axis"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.apply_along_axis.html#numpy.ma.apply_along_axis">[docs]</a><span class="k">def</span> <span class="nf">apply_along_axis</span><span class="p">(</span><span class="n">func1d</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (This docstring should be overwritten)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">+=</span> <span class="n">nd</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">axis</span> <span class="o">&gt;=</span> <span class="n">nd</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;axis must be less than arr.ndim; axis=</span><span class="si">%d</span><span class="s2">, rank=</span><span class="si">%d</span><span class="s2">.&quot;</span>
            <span class="o">%</span> <span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">nd</span><span class="p">))</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">nd</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)</span>
    <span class="n">indlist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">nd</span><span class="p">))</span>
    <span class="n">indlist</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">i</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">outshape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indlist</span><span class="p">)</span>
    <span class="n">i</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indlist</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tolist</span><span class="p">())],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="c1">#  if res is a number, then we have a smaller output array</span>
    <span class="n">asscalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">asscalar</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="n">asscalar</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c1"># Note: we shouldn&#39;t set the dtype of the output from the first result</span>
    <span class="c1"># so we force the type to object, and build a list of dtypes.  We&#39;ll</span>
    <span class="c1"># just take the largest, to avoid some downcasting</span>
    <span class="n">dtypes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">asscalar</span><span class="p">:</span>
        <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">outarr</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">outshape</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">outarr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="n">Ntot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">outshape</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Ntot</span><span class="p">:</span>
            <span class="c1"># increment the index</span>
            <span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">outshape</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nd</span><span class="p">)):</span>
                <span class="n">ind</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ind</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indlist</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tolist</span><span class="p">())],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">outarr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">ind</span><span class="p">)]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">j</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">([</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)]</span> <span class="o">*</span> <span class="n">res</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
        <span class="n">j</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indlist</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
        <span class="n">Ntot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">outshape</span><span class="p">)</span>
        <span class="n">holdshape</span> <span class="o">=</span> <span class="n">outshape</span>
        <span class="n">outshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">outshape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">outshape</span> <span class="o">=</span> <span class="n">flatten_inplace</span><span class="p">(</span><span class="n">outshape</span><span class="p">)</span>
        <span class="n">outarr</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">outshape</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
        <span class="n">outarr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_inplace</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))]</span> <span class="o">=</span> <span class="n">res</span>
        <span class="n">k</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">Ntot</span><span class="p">:</span>
            <span class="c1"># increment the index</span>
            <span class="n">ind</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">while</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">holdshape</span><span class="p">[</span><span class="n">n</span><span class="p">])</span> <span class="ow">and</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">nd</span><span class="p">)):</span>
                <span class="n">ind</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">ind</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">n</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">i</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indlist</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
            <span class="n">j</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indlist</span><span class="p">,</span> <span class="n">ind</span><span class="p">)</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func1d</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">tolist</span><span class="p">())],</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">outarr</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_inplace</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">tolist</span><span class="p">()))]</span> <span class="o">=</span> <span class="n">res</span>
            <span class="n">dtypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">asarray</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">max_dtypes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dtypes</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">outarr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">max_dtypes</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">outarr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">max_dtypes</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">default_fill_value</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>
<span class="n">apply_along_axis</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="o">.</span><span class="n">__doc__</span>


<span class="k">def</span> <span class="nf">apply_over_axes</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    (This docstring will be overwritten)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">array</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="n">axes</span><span class="p">,)</span>
    <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">N</span> <span class="o">+</span> <span class="n">axis</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">res</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">res</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;function is not returning &quot;</span>
                        <span class="s2">&quot;an array of the correct shape&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">val</span>

<span class="k">if</span> <span class="n">apply_over_axes</span><span class="o">.</span><span class="n">__doc__</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">apply_over_axes</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="o">.</span><span class="n">__doc__</span><span class="p">[</span>
        <span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">apply_over_axes</span><span class="o">.</span><span class="n">__doc__</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;Notes&#39;</span><span class="p">)]</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="o">+</span> \
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ma.arange(24).reshape(2,3,4)</span>
<span class="sd">    &gt;&gt;&gt; a[:,0,1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; a[:,1,:] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; print a</span>
<span class="sd">    [[[0 -- 2 3]</span>
<span class="sd">      [-- -- -- --]</span>
<span class="sd">      [8 9 10 11]]</span>

<span class="sd">     [[12 -- 14 15]</span>
<span class="sd">      [-- -- -- --]</span>
<span class="sd">      [20 21 22 23]]]</span>
<span class="sd">    &gt;&gt;&gt; print ma.apply_over_axes(ma.sum, a, [0,2])</span>
<span class="sd">    [[[46]</span>
<span class="sd">      [--]</span>
<span class="sd">      [124]]]</span>

<span class="sd">    Tuple axis arguments to ufuncs are equivalent:</span>

<span class="sd">    &gt;&gt;&gt; print ma.sum(a, axis=(0,2)).reshape((1,-1,1))</span>
<span class="sd">    [[[46]</span>
<span class="sd">      [--]</span>
<span class="sd">      [124]]]</span>
<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="average"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.average.html#numpy.ma.average">[docs]</a><span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">returned</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the weighted average of array over the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Data to be averaged.</span>
<span class="sd">        Masked entries are not taken into account in the computation.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the average is computed. The default is to compute</span>
<span class="sd">        the average of the flattened array.</span>
<span class="sd">    weights : array_like, optional</span>
<span class="sd">        The importance that each element has in the computation of the average.</span>
<span class="sd">        The weights array can either be 1-D (in which case its length must be</span>
<span class="sd">        the size of `a` along the given axis) or of the same shape as `a`.</span>
<span class="sd">        If ``weights=None``, then all data in `a` are assumed to have a</span>
<span class="sd">        weight equal to one.   If `weights` is complex, the imaginary parts</span>
<span class="sd">        are ignored.</span>
<span class="sd">    returned : bool, optional</span>
<span class="sd">        Flag indicating whether a tuple ``(result, sum of weights)``</span>
<span class="sd">        should be returned as output (True), or just the result (False).</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    average, [sum_of_weights] : (tuple of) scalar or MaskedArray</span>
<span class="sd">        The average along the specified axis. When returned is `True`,</span>
<span class="sd">        return a tuple with the average as the first element and the sum</span>
<span class="sd">        of the weights as the second element. The return type is `np.float64`</span>
<span class="sd">        if `a` is of integer type and floats smaller than `float64`, or the</span>
<span class="sd">        input data-type, otherwise. If returned, `sum_of_weights` is always</span>
<span class="sd">        `float64`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.ma.array([1., 2., 3., 4.], mask=[False, False, True, True])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.average(a, weights=[3, 1, 0, 0])</span>
<span class="sd">    1.25</span>

<span class="sd">    &gt;&gt;&gt; x = np.ma.arange(6.).reshape(3, 2)</span>
<span class="sd">    &gt;&gt;&gt; print x</span>
<span class="sd">    [[ 0.  1.]</span>
<span class="sd">     [ 2.  3.]</span>
<span class="sd">     [ 4.  5.]]</span>
<span class="sd">    &gt;&gt;&gt; avg, sumweights = np.ma.average(x, axis=0, weights=[1, 2, 3],</span>
<span class="sd">    ...                                 returned=True)</span>
<span class="sd">    &gt;&gt;&gt; print avg</span>
<span class="sd">    [2.66666666667 3.66666666667]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">mask</span>
    <span class="n">ash</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">if</span> <span class="n">ash</span> <span class="o">==</span> <span class="p">():</span>
        <span class="n">ash</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="o">~</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="nb">float</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">*</span> <span class="n">w</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">w</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">ash</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="mf">1.0</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">wsh</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">wsh</span> <span class="o">==</span> <span class="p">():</span>
                    <span class="n">wsh</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">wsh</span> <span class="o">==</span> <span class="n">ash</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">w</span>
                <span class="k">elif</span> <span class="n">wsh</span> <span class="o">==</span> <span class="p">(</span><span class="n">ash</span><span class="p">[</span><span class="n">axis</span><span class="p">],):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ash</span><span class="p">)</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;w[&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">+</span> <span class="s2">&quot;] * ones(ash, float)&quot;</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                    <span class="k">del</span> <span class="n">w</span><span class="p">,</span> <span class="n">r</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;average: weights wrong shape.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">((</span><span class="o">~</span><span class="n">mask</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="n">wsh</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">if</span> <span class="n">wsh</span> <span class="o">==</span> <span class="p">():</span>
                    <span class="n">wsh</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
                <span class="k">if</span> <span class="n">wsh</span> <span class="o">==</span> <span class="n">ash</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">wsh</span> <span class="o">==</span> <span class="p">(</span><span class="n">ash</span><span class="p">[</span><span class="n">axis</span><span class="p">],):</span>
                    <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ash</span><span class="p">)</span>
                    <span class="n">r</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="nb">eval</span><span class="p">(</span><span class="s2">&quot;w[&quot;</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">+</span>
                             <span class="s2">&quot;] * masked_array(ones(ash, float), mask)&quot;</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;average: weights wrong shape.&#39;</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">w</span>
    <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="n">masked</span> <span class="ow">or</span> <span class="n">d</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">/</span> <span class="n">d</span>
    <span class="k">del</span> <span class="n">n</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="ow">and</span> \
           <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">if</span> <span class="n">returned</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span> <span class="o">*</span> <span class="n">d</span>
    <span class="k">if</span> <span class="n">returned</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span><span class="p">,</span> <span class="n">d</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="median"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.median.html#numpy.ma.median">[docs]</a><span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the median along the specified axis.</span>

<span class="sd">    Returns the median of the array elements.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the medians are computed. The default (None) is</span>
<span class="sd">        to compute the median along a flattened version of the array.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output</span>
<span class="sd">        but the type will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow use of memory of input array (a) for</span>
<span class="sd">        calculations. The input array will be modified by the call to</span>
<span class="sd">        median. This will save memory when you do not need to preserve</span>
<span class="sd">        the contents of the input array. Treat the input as undefined,</span>
<span class="sd">        but it will probably be fully or partially sorted. Default is</span>
<span class="sd">        False. Note that, if `overwrite_input` is True, and the input</span>
<span class="sd">        is not already an `ndarray`, an error will be raised.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    median : ndarray</span>
<span class="sd">        A new array holding the result is returned unless out is</span>
<span class="sd">        specified, in which case a reference to out is returned.</span>
<span class="sd">        Return data-type is `float64` for integers and floats smaller than</span>
<span class="sd">        `float64`, or the input data-type, otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector ``V`` with ``N`` non masked values, the median of ``V``</span>
<span class="sd">    is the middle value of a sorted copy of ``V`` (``Vs``) - i.e.</span>
<span class="sd">    ``Vs[(N-1)/2]``, when ``N`` is odd, or ``{Vs[N/2 - 1] + Vs[N/2]}/2``</span>
<span class="sd">    when ``N`` is even.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(8), mask=[0]*4 + [1]*4)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.median(x)</span>
<span class="sd">    1.5</span>

<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(10).reshape(2, 5), mask=[0]*6 + [1]*4)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.median(x)</span>
<span class="sd">    2.5</span>
<span class="sd">    &gt;&gt;&gt; np.ma.median(x, axis=-1, overwrite_input=True)</span>
<span class="sd">    masked_array(data = [ 2.  5.],</span>
<span class="sd">                 mask = False,</span>
<span class="sd">           fill_value = 1e+20)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;mask&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span>
                      <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">asorted</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">asorted</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="n">asorted</span> <span class="o">=</span> <span class="n">a</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">asorted</span> <span class="o">=</span> <span class="n">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">+=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>

    <span class="n">counts</span> <span class="o">=</span> <span class="n">asorted</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">asorted</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="n">h</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="c1"># create indexing mesh grid for all but reduced axis</span>
    <span class="n">axes_grid</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">asorted</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                 <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">axis</span><span class="p">]</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">axes_grid</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="c1"># insert indices of low and high median</span>
    <span class="n">ind</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">h</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">low</span> <span class="o">=</span> <span class="n">asorted</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="n">ind</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">h</span>
    <span class="n">high</span> <span class="o">=</span> <span class="n">asorted</span><span class="p">[</span><span class="n">ind</span><span class="p">]</span>
    <span class="c1"># duplicate high if odd number of elements so mean does nothing</span>
    <span class="n">odd</span> <span class="o">=</span> <span class="n">counts</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">asorted</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">odd</span><span class="p">:</span>
            <span class="n">low</span> <span class="o">=</span> <span class="n">high</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">low</span><span class="p">[</span><span class="n">odd</span><span class="p">]</span> <span class="o">=</span> <span class="n">high</span><span class="p">[</span><span class="n">odd</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">asorted</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="c1"># avoid inf / x = masked</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">mean</span><span class="p">([</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">s</span></div>


<span class="k">def</span> <span class="nf">compress_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Supress slices from multiple dimensions which contain masked values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, MaskedArray</span>
<span class="sd">        The array to operate on. If not a MaskedArray instance (or if no array</span>
<span class="sd">        elements are masked, `x` is interpreted as a MaskedArray with `mask`</span>
<span class="sd">        set to `nomask`.</span>
<span class="sd">    axis : tuple of ints or int, optional</span>
<span class="sd">        Which dimensions to supress slices from can be configured with this</span>
<span class="sd">        parameter.</span>
<span class="sd">        - If axis is a tuple of ints, those are the axes to supress slices from.</span>
<span class="sd">        - If axis is an int, then that is the only axis to supress slices from.</span>
<span class="sd">        - If axis is None, all axis are selected.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    compress_array : ndarray</span>
<span class="sd">        The compressed array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Set axis to tuple of ints</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
    <span class="k">elif</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid type for axis argument&#39;</span><span class="p">)</span>
    <span class="c1"># Check axis input</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="n">ax</span> <span class="o">+</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="k">if</span> <span class="n">ax</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">ax</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ax</span> <span class="o">&lt;</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span> <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;axis&#39; entry is out of bounds&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">axis</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;duplicate value in &#39;axis&#39;&quot;</span><span class="p">)</span>
    <span class="c1"># Nothing is masked: return x</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">_data</span>
    <span class="c1"># All is masked: return empty</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">nxarray</span><span class="p">([])</span>
    <span class="c1"># Filter elements through boolean indexing</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ax</span><span class="p">))</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ax</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">ndim</span><span class="p">)))</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),)</span><span class="o">*</span><span class="n">ax</span> <span class="o">+</span> <span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axes</span><span class="p">),)]</span>
    <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="compress_rowcols"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.compress_rowcols.html#numpy.ma.compress_rowcols">[docs]</a><span class="k">def</span> <span class="nf">compress_rowcols</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Suppress the rows and/or columns of a 2-D array that contain</span>
<span class="sd">    masked values.</span>

<span class="sd">    The suppression behavior is selected with the `axis` parameter.</span>

<span class="sd">    - If axis is None, both rows and columns are suppressed.</span>
<span class="sd">    - If axis is 0, only rows are suppressed.</span>
<span class="sd">    - If axis is 1 or -1, only columns are suppressed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like, MaskedArray</span>
<span class="sd">        The array to operate on.  If not a MaskedArray instance (or if no array</span>
<span class="sd">        elements are masked), `x` is interpreted as a MaskedArray with</span>
<span class="sd">        `mask` set to `nomask`. Must be a 2D array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to perform the operation. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    compressed_array : ndarray</span>
<span class="sd">        The compressed array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],</span>
<span class="sd">    ...                                                   [1, 0, 0],</span>
<span class="sd">    ...                                                   [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[-- 1 2]</span>
<span class="sd">     [-- 4 5]</span>
<span class="sd">     [6 7 8]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[ True False False]</span>
<span class="sd">     [ True False False]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &gt;&gt;&gt; np.ma.compress_rowcols(x)</span>
<span class="sd">    array([[7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.compress_rowcols(x, 0)</span>
<span class="sd">    array([[6, 7, 8]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.compress_rowcols(x, 1)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [4, 5],</span>
<span class="sd">           [7, 8]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;compress_rowcols works for 2D arrays only.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compress_nd</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="compress_rows"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.compress_rows.html#numpy.ma.compress_rows">[docs]</a><span class="k">def</span> <span class="nf">compress_rows</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Suppress whole rows of a 2-D array that contain masked values.</span>

<span class="sd">    This is equivalent to ``np.ma.compress_rowcols(a, 0)``, see</span>
<span class="sd">    `extras.compress_rowcols` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    extras.compress_rowcols</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;compress_rows works for 2D arrays only.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compress_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="compress_cols"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.compress_cols.html#numpy.ma.compress_cols">[docs]</a><span class="k">def</span> <span class="nf">compress_cols</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Suppress whole columns of a 2-D array that contain masked values.</span>

<span class="sd">    This is equivalent to ``np.ma.compress_rowcols(a, 1)``, see</span>
<span class="sd">    `extras.compress_rowcols` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    extras.compress_rowcols</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;compress_cols works for 2D arrays only.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">compress_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>

<div class="viewcode-block" id="mask_rows"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.mask_rows.html#numpy.ma.mask_rows">[docs]</a><span class="k">def</span> <span class="nf">mask_rows</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask rows of a 2D array that contain masked values.</span>

<span class="sd">    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 0.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mask_rowcols : Mask rows and/or columns of a 2D array.</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=np.int)</span>
<span class="sd">    &gt;&gt;&gt; a[1, 1] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 1, 0],</span>
<span class="sd">           [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal(a, 1)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 0 0]</span>
<span class="sd">     [0 -- 0]</span>
<span class="sd">     [0 0 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False False False]</span>
<span class="sd">     [False  True False]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.mask_rows(a)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 0 0]</span>
<span class="sd">     [-- -- --]</span>
<span class="sd">     [0 0 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False False False]</span>
<span class="sd">     [ True  True  True]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mask_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="mask_cols"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.mask_cols.html#numpy.ma.mask_cols">[docs]</a><span class="k">def</span> <span class="nf">mask_cols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask columns of a 2D array that contain masked values.</span>

<span class="sd">    This function is a shortcut to ``mask_rowcols`` with `axis` equal to 1.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mask_rowcols : Mask rows and/or columns of a 2D array.</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=np.int)</span>
<span class="sd">    &gt;&gt;&gt; a[1, 1] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 1, 0],</span>
<span class="sd">           [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal(a, 1)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 0 0]</span>
<span class="sd">     [0 -- 0]</span>
<span class="sd">     [0 0 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False False False]</span>
<span class="sd">     [False  True False]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.mask_cols(a)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 -- 0]</span>
<span class="sd">     [0 -- 0]</span>
<span class="sd">     [0 -- 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True False]</span>
<span class="sd">     [False  True False]</span>
<span class="sd">     [False  True False]],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">mask_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="c1">#---- --- arraysetops ---</span>
<span class="c1">#####--------------------------------------------------------------------------</span>

<div class="viewcode-block" id="ediff1d"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.ediff1d.html#numpy.ma.ediff1d">[docs]</a><span class="k">def</span> <span class="nf">ediff1d</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">to_end</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">to_begin</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the differences between consecutive elements of an array.</span>

<span class="sd">    This function is the equivalent of `numpy.ediff1d` that takes masked</span>
<span class="sd">    values into account, see `numpy.ediff1d` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.ediff1d : Equivalent function for ndarrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">flat</span>
    <span class="n">ed</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="n">arr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">ed</span><span class="p">]</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">to_begin</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">arrays</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">to_begin</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">to_end</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">arrays</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_end</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># We&#39;ll save ourselves a copy of a potentially large array in the common</span>
        <span class="c1"># case where neither to_begin or to_end was given.</span>
        <span class="n">ed</span> <span class="o">=</span> <span class="n">hstack</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">return</span> <span class="n">ed</span></div>


<span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the unique elements of an array.</span>

<span class="sd">    Masked values are considered the same element (masked). The output array</span>
<span class="sd">    is always a masked array. See `numpy.unique` for more details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.unique : Equivalent function for ndarrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span>
                       <span class="n">return_index</span><span class="o">=</span><span class="n">return_index</span><span class="p">,</span>
                       <span class="n">return_inverse</span><span class="o">=</span><span class="n">return_inverse</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
        <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="k">def</span> <span class="nf">intersect1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the unique elements common to both arrays.</span>

<span class="sd">    Masked values are considered equal one to the other.</span>
<span class="sd">    The output is always a masked array.</span>

<span class="sd">    See `numpy.intersect1d` for more details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.intersect1d : Equivalent function for ndarrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = array([1, 3, 3, 3], mask=[0, 0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; y = array([3, 1, 1, 1], mask=[0, 0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; intersect1d(x, y)</span>
<span class="sd">    masked_array(data = [1 3 --],</span>
<span class="sd">                 mask = [False False  True],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">assume_unique</span><span class="p">:</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Might be faster than unique( intersect1d( ar1, ar2 ) )?</span>
        <span class="n">aux</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">),</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar2</span><span class="p">)))</span>
    <span class="n">aux</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">aux</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">aux</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">aux</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>


<span class="k">def</span> <span class="nf">setxor1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set exclusive-or of 1-D arrays with unique elements.</span>

<span class="sd">    The output is always a masked array. See `numpy.setxor1d` for more details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.setxor1d : Equivalent function for ndarrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_unique</span><span class="p">:</span>
        <span class="n">ar1</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span>
        <span class="n">ar2</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar2</span><span class="p">)</span>

    <span class="n">aux</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">aux</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">aux</span>
    <span class="n">aux</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">auxf</span> <span class="o">=</span> <span class="n">aux</span><span class="o">.</span><span class="n">filled</span><span class="p">()</span>
<span class="c1">#    flag = ediff1d( aux, to_end = 1, to_begin = 1 ) == 0</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="bp">True</span><span class="p">],</span> <span class="p">(</span><span class="n">auxf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">auxf</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="p">[</span><span class="bp">True</span><span class="p">]))</span>
<span class="c1">#    flag2 = ediff1d( flag ) == 0</span>
    <span class="n">flag2</span> <span class="o">=</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">flag</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">aux</span><span class="p">[</span><span class="n">flag2</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">in1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether each element of an array is also present in a second</span>
<span class="sd">    array.</span>

<span class="sd">    The output is always a masked array. See `numpy.in1d` for more details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.in1d : Equivalent function for ndarrays.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.4.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">assume_unique</span><span class="p">:</span>
        <span class="n">ar1</span><span class="p">,</span> <span class="n">rev_idx</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">ar2</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar2</span><span class="p">)</span>

    <span class="n">ar</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">))</span>
    <span class="c1"># We need this to be a stable sort, so always use &#39;mergesort&#39;</span>
    <span class="c1"># here. The values from the first array should always come before</span>
    <span class="c1"># the values from the second array.</span>
    <span class="n">order</span> <span class="o">=</span> <span class="n">ar</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)</span>
    <span class="n">sar</span> <span class="o">=</span> <span class="n">ar</span><span class="p">[</span><span class="n">order</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
        <span class="n">bool_ar</span> <span class="o">=</span> <span class="p">(</span><span class="n">sar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">sar</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bool_ar</span> <span class="o">=</span> <span class="p">(</span><span class="n">sar</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">sar</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">bool_ar</span><span class="p">,</span> <span class="p">[</span><span class="n">invert</span><span class="p">]))</span>
    <span class="n">indx</span> <span class="o">=</span> <span class="n">order</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">&#39;mergesort&#39;</span><span class="p">)[:</span><span class="nb">len</span><span class="p">(</span><span class="n">ar1</span><span class="p">)]</span>

    <span class="k">if</span> <span class="n">assume_unique</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flag</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flag</span><span class="p">[</span><span class="n">indx</span><span class="p">][</span><span class="n">rev_idx</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">union1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Union of two arrays.</span>

<span class="sd">    The output is always a masked array. See `numpy.union1d` for more details.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.union1d : Equivalent function for ndarrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">unique</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">)))</span>


<span class="k">def</span> <span class="nf">setdiff1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set difference of 1D arrays with unique elements.</span>

<span class="sd">    The output is always a masked array. See `numpy.setdiff1d` for more</span>
<span class="sd">    details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.setdiff1d : Equivalent function for ndarrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array([1, 2, 3, 4], mask=[0, 1, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.setdiff1d(x, [1, 2])</span>
<span class="sd">    masked_array(data = [3 --],</span>
<span class="sd">                 mask = [False  True],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">assume_unique</span><span class="p">:</span>
        <span class="n">ar1</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ar1</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar1</span><span class="p">)</span>
        <span class="n">ar2</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">ar2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ar1</span><span class="p">[</span><span class="n">in1d</span><span class="p">(</span><span class="n">ar1</span><span class="p">,</span> <span class="n">ar2</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">True</span><span class="p">)]</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                                Covariance                                   #</span>
<span class="c1">###############################################################################</span>


<span class="k">def</span> <span class="nf">_covhelper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">allow_masked</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function for the computation of covariance and correlation</span>
<span class="sd">    coefficients.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
    <span class="n">xmask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Quick exit if we can&#39;t process masked data</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_masked</span> <span class="ow">and</span> <span class="n">xmask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot process masked data.&quot;</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">rowvar</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="c1"># Make sure that rowvar is either 0 or 1</span>
    <span class="n">rowvar</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">rowvar</span><span class="p">))</span>
    <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">rowvar</span>
    <span class="k">if</span> <span class="n">rowvar</span><span class="p">:</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">tup</span> <span class="o">=</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">))</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">xnotmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">xmask</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="n">ymask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_masked</span> <span class="ow">and</span> <span class="n">ymask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot process masked data.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">xmask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">or</span> <span class="n">ymask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="c1"># Define some common mask</span>
                <span class="n">common_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">xmask</span><span class="p">,</span> <span class="n">ymask</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">common_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">unshare_mask</span><span class="p">()</span>
                    <span class="n">y</span><span class="o">.</span><span class="n">unshare_mask</span><span class="p">()</span>
                    <span class="n">xmask</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">y</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">ymask</span> <span class="o">=</span> <span class="n">common_mask</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">xnotmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xmask</span><span class="p">,</span> <span class="n">ymask</span><span class="p">),</span> <span class="n">axis</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">-=</span> <span class="n">x</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">rowvar</span><span class="p">)[</span><span class="n">tup</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xnotmask</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">)</span>


<div class="viewcode-block" id="cov"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.cov.html#numpy.ma.cov">[docs]</a><span class="k">def</span> <span class="nf">cov</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">allow_masked</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Estimate the covariance matrix.</span>

<span class="sd">    Except for the handling of missing data this function does the same as</span>
<span class="sd">    `numpy.cov`. For more details and examples, see `numpy.cov`.</span>

<span class="sd">    By default, masked values are recognized as such. If `x` and `y` have the</span>
<span class="sd">    same shape, a common mask is allocated: if ``x[i,j]`` is masked, then</span>
<span class="sd">    ``y[i,j]`` will also be masked.</span>
<span class="sd">    Setting `allow_masked` to False will raise an exception if values are</span>
<span class="sd">    missing in either of the input arrays.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `x` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same</span>
<span class="sd">        form as `x`.</span>
<span class="sd">    rowvar : bool, optional</span>
<span class="sd">        If `rowvar` is True (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : bool, optional</span>
<span class="sd">        Default normalization (False) is by ``(N-1)``, where ``N`` is the</span>
<span class="sd">        number of observations given (unbiased estimate). If `bias` is True,</span>
<span class="sd">        then normalization is by ``N``. This keyword can be overridden by</span>
<span class="sd">        the keyword ``ddof`` in numpy versions &gt;= 1.5.</span>
<span class="sd">    allow_masked : bool, optional</span>
<span class="sd">        If True, masked values are propagated pair-wise: if a value is masked</span>
<span class="sd">        in `x`, the corresponding value is masked in `y`.</span>
<span class="sd">        If False, raises a `ValueError` exception when some values are missing.</span>
<span class="sd">    ddof : {None, int}, optional</span>
<span class="sd">        If not ``None`` normalization is by ``(N - ddof)``, where ``N`` is</span>
<span class="sd">        the number of observations; this overrides the value implied by</span>
<span class="sd">        ``bias``. The default value is ``None``.</span>

<span class="sd">        .. versionadded:: 1.5</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        Raised if some values are missing and `allow_masked` is False.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.cov</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check inputs</span>
    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">ddof</span> <span class="o">!=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ddof</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ddof must be an integer&quot;</span><span class="p">)</span>
    <span class="c1"># Set up ddof</span>
    <span class="k">if</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">bias</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ddof</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xnotmask</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">)</span> <span class="o">=</span> <span class="n">_covhelper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">,</span> <span class="n">allow_masked</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xnotmask</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">xnotmask</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">ddof</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">/</span> <span class="n">fact</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xnotmask</span><span class="p">,</span> <span class="n">xnotmask</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">-</span> <span class="n">ddof</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">/</span> <span class="n">fact</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="corrcoef"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.corrcoef.html#numpy.ma.corrcoef">[docs]</a><span class="k">def</span> <span class="nf">corrcoef</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">rowvar</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">allow_masked</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
             <span class="n">ddof</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return Pearson product-moment correlation coefficients.</span>

<span class="sd">    Except for the handling of missing data this function does the same as</span>
<span class="sd">    `numpy.corrcoef`. For more details and examples, see `numpy.corrcoef`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        A 1-D or 2-D array containing multiple variables and observations.</span>
<span class="sd">        Each row of `x` represents a variable, and each column a single</span>
<span class="sd">        observation of all those variables. Also see `rowvar` below.</span>
<span class="sd">    y : array_like, optional</span>
<span class="sd">        An additional set of variables and observations. `y` has the same</span>
<span class="sd">        shape as `x`.</span>
<span class="sd">    rowvar : bool, optional</span>
<span class="sd">        If `rowvar` is True (default), then each row represents a</span>
<span class="sd">        variable, with observations in the columns. Otherwise, the relationship</span>
<span class="sd">        is transposed: each column represents a variable, while the rows</span>
<span class="sd">        contain observations.</span>
<span class="sd">    bias : _NoValue, optional</span>
<span class="sd">        Has no affect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>
<span class="sd">    allow_masked : bool, optional</span>
<span class="sd">        If True, masked values are propagated pair-wise: if a value is masked</span>
<span class="sd">        in `x`, the corresponding value is masked in `y`.</span>
<span class="sd">        If False, raises an exception.  Because `bias` is deprecated, this</span>
<span class="sd">        argument needs to be treated as keyword only to avoid a warning.</span>
<span class="sd">    ddof : _NoValue, optional</span>
<span class="sd">        Has no affect, do not use.</span>

<span class="sd">        .. deprecated:: 1.10.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.corrcoef : Equivalent function in top-level NumPy module.</span>
<span class="sd">    cov : Estimate the covariance matrix.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function accepts but discards arguments `bias` and `ddof`.  This is</span>
<span class="sd">    for backwards compatibility with previous versions of this function.  These</span>
<span class="sd">    arguments had no effect on the return values of the function and can be</span>
<span class="sd">    safely ignored in this and previous versions of numpy.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">msg</span> <span class="o">=</span> <span class="s1">&#39;bias and ddof have no affect and are deprecated&#39;</span>
    <span class="k">if</span> <span class="n">bias</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span> <span class="ow">or</span> <span class="n">ddof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">_NoValue</span><span class="p">:</span>
        <span class="c1"># 2015-03-15, 1.10</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
    <span class="c1"># Get the data</span>
    <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">xnotmask</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">)</span> <span class="o">=</span> <span class="n">_covhelper</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">rowvar</span><span class="p">,</span> <span class="n">allow_masked</span><span class="p">)</span>
    <span class="c1"># Compute the covariance matrix</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">rowvar</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xnotmask</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">xnotmask</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">/</span> <span class="n">fact</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">xnotmask</span><span class="p">,</span> <span class="n">xnotmask</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1.</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="o">/</span> <span class="n">fact</span><span class="p">)</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="c1"># Check whether we have a scalar</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">diag</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">xnotmask</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
        <span class="n">_denom</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">diag</span><span class="p">,</span> <span class="n">diag</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">_denom</span> <span class="o">=</span> <span class="n">diagflat</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">rowvar</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">rowvar</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">_x</span> <span class="o">=</span> <span class="n">mask_cols</span><span class="p">(</span><span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="n">j</span><span class="p">])))</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">_denom</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_denom</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
                    <span class="n">_x</span> <span class="o">=</span> <span class="n">mask_cols</span><span class="p">(</span>
                            <span class="n">vstack</span><span class="p">((</span><span class="n">x</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">x</span><span class="p">[:,</span> <span class="n">j</span><span class="p">])))</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">_denom</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">_denom</span><span class="p">[</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ma</span><span class="o">.</span><span class="n">multiply</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">_x</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">c</span> <span class="o">/</span> <span class="n">_denom</span></div>

<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="c1">#---- --- Concatenation helpers ---</span>
<span class="c1">#####--------------------------------------------------------------------------</span>

<span class="k">class</span> <span class="nc">MAxisConcatenator</span><span class="p">(</span><span class="n">AxisConcatenator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate slice objects to concatenation along an axis.</span>

<span class="sd">    For documentation on usage, see `mr_class`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mr_class</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">AxisConcatenator</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">matrix</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">MAError</span><span class="p">(</span><span class="s2">&quot;Unavailable for masked array.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">,)</span>
        <span class="n">objs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">scalars</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">final_dtypedescr</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)):</span>
            <span class="n">scalar</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="nb">slice</span><span class="p">):</span>
                <span class="n">step</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">step</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">start</span>
                <span class="n">stop</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">stop</span>
                <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="n">step</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">step</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
                    <span class="n">size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">step</span><span class="p">))</span>
                    <span class="n">newobj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="n">size</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">newobj</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39;rc&#39;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                    <span class="k">continue</span>
                <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unknown special directive&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ScalarType</span><span class="p">:</span>
                <span class="n">newobj</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">([</span><span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">]])</span>
                <span class="n">scalars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="n">scalar</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">newobj</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="n">objs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newobj</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">newobj</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">scalar</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">final_dtypedescr</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">final_dtypedescr</span> <span class="o">=</span> <span class="n">newobj</span><span class="o">.</span><span class="n">dtype</span>
                <span class="k">elif</span> <span class="n">newobj</span><span class="o">.</span><span class="n">dtype</span> <span class="o">&gt;</span> <span class="n">final_dtypedescr</span><span class="p">:</span>
                    <span class="n">final_dtypedescr</span> <span class="o">=</span> <span class="n">newobj</span><span class="o">.</span><span class="n">dtype</span>
        <span class="k">if</span> <span class="n">final_dtypedescr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">scalars</span><span class="p">:</span>
                <span class="n">objs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">objs</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">final_dtypedescr</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">objs</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_retval</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">mr_class</span><span class="p">(</span><span class="n">MAxisConcatenator</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Translate slice objects to concatenation along the first axis.</span>

<span class="sd">    This is the masked array version of `lib.index_tricks.RClass`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    lib.index_tricks.RClass</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.ma.mr_[np.ma.array([1,2,3]), 0, 0, np.ma.array([4,5,6])]</span>
<span class="sd">    array([1, 2, 3, 0, 0, 4, 5, 6])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">MAxisConcatenator</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">mr_</span> <span class="o">=</span> <span class="n">mr_class</span><span class="p">()</span>

<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="c1">#---- Find unmasked data ---</span>
<span class="c1">#####--------------------------------------------------------------------------</span>

<div class="viewcode-block" id="flatnotmasked_edges"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.flatnotmasked_edges.html#numpy.ma.flatnotmasked_edges">[docs]</a><span class="k">def</span> <span class="nf">flatnotmasked_edges</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the indices of the first and last unmasked values.</span>

<span class="sd">    Expects a 1-D `MaskedArray`, returns None if all values are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input 1-D `MaskedArray`</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    edges : ndarray or None</span>
<span class="sd">        The indices of first and last non-masked value in the array.</span>
<span class="sd">        Returns None if all values are masked.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnotmasked_contiguous, notmasked_contiguous, notmasked_edges,</span>
<span class="sd">    clump_masked, clump_unmasked</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Only accepts 1-D arrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.ma.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; flatnotmasked_edges(a)</span>
<span class="sd">    [0,-1]</span>

<span class="sd">    &gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)</span>
<span class="sd">    &gt;&gt;&gt; a[mask] = np.ma.masked</span>
<span class="sd">    &gt;&gt;&gt; np.array(a[~a.mask])</span>
<span class="sd">    array([3, 4, 6, 7, 8])</span>

<span class="sd">    &gt;&gt;&gt; flatnotmasked_edges(a)</span>
<span class="sd">    array([3, 8])</span>

<span class="sd">    &gt;&gt;&gt; a[:] = np.ma.masked</span>
<span class="sd">    &gt;&gt;&gt; print flatnotmasked_edges(ma)</span>
<span class="sd">    None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">unmasked</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="o">~</span><span class="n">m</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unmasked</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unmasked</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span></div>


<div class="viewcode-block" id="notmasked_edges"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.notmasked_edges.html#numpy.ma.notmasked_edges">[docs]</a><span class="k">def</span> <span class="nf">notmasked_edges</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the indices of the first and last unmasked values along an axis.</span>

<span class="sd">    If all values are masked, return None.  Otherwise, return a list</span>
<span class="sd">    of two tuples, corresponding to the indices of the first and last</span>
<span class="sd">    unmasked values respectively.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to perform the operation.</span>
<span class="sd">        If None (default), applies to a flattened version of the array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    edges : ndarray or list</span>
<span class="sd">        An array of start and end indexes if there are any masked data in</span>
<span class="sd">        the array. If there are no masked data in the array, `edges` is a</span>
<span class="sd">        list of the first and last index.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnotmasked_contiguous, flatnotmasked_edges, notmasked_contiguous,</span>
<span class="sd">    clump_masked, clump_unmasked</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; m = np.zeros_like(a)</span>
<span class="sd">    &gt;&gt;&gt; m[1:, 1:] = 1</span>

<span class="sd">    &gt;&gt;&gt; am = np.ma.array(a, mask=m)</span>
<span class="sd">    &gt;&gt;&gt; np.array(am[~am.mask])</span>
<span class="sd">    array([0, 1, 2, 3, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.ma.notmasked_edges(ma)</span>
<span class="sd">    array([0, 6])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flatnotmasked_edges</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">return</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">([</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]),</span>
            <span class="nb">tuple</span><span class="p">([</span><span class="n">idx</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span><span class="p">)]),</span> <span class="p">]</span></div>


<div class="viewcode-block" id="flatnotmasked_contiguous"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.flatnotmasked_contiguous.html#numpy.ma.flatnotmasked_contiguous">[docs]</a><span class="k">def</span> <span class="nf">flatnotmasked_contiguous</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find contiguous unmasked data in a masked array along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : narray</span>
<span class="sd">        The input array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slice_list : list</span>
<span class="sd">        A sorted sequence of slices (start index, end index).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnotmasked_edges, notmasked_contiguous, notmasked_edges,</span>
<span class="sd">    clump_masked, clump_unmasked</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Only accepts 2-D arrays at most.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.ma.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a)</span>
<span class="sd">    slice(0, 10, None)</span>

<span class="sd">    &gt;&gt;&gt; mask = (a &lt; 3) | (a &gt; 8) | (a == 5)</span>
<span class="sd">    &gt;&gt;&gt; a[mask] = np.ma.masked</span>
<span class="sd">    &gt;&gt;&gt; np.array(a[~a.mask])</span>
<span class="sd">    array([3, 4, 6, 7, 8])</span>

<span class="sd">    &gt;&gt;&gt; np.ma.flatnotmasked_contiguous(a)</span>
<span class="sd">    [slice(3, 5, None), slice(6, 9, None)]</span>
<span class="sd">    &gt;&gt;&gt; a[:] = np.ma.masked</span>
<span class="sd">    &gt;&gt;&gt; print np.ma.flatnotmasked_edges(a)</span>
<span class="sd">    None</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">ravel</span><span class="p">()):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">k</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">result</span> <span class="ow">or</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="notmasked_contiguous"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.notmasked_contiguous.html#numpy.ma.notmasked_contiguous">[docs]</a><span class="k">def</span> <span class="nf">notmasked_contiguous</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find contiguous unmasked data in a masked array along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        The input array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to perform the operation.</span>
<span class="sd">        If None (default), applies to a flattened version of the array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    endpoints : list</span>
<span class="sd">        A list of slices (start and end indexes) of unmasked indexes</span>
<span class="sd">        in the array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,</span>
<span class="sd">    clump_masked, clump_unmasked</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Only accepts 2-D arrays at most.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(9).reshape((3, 3))</span>
<span class="sd">    &gt;&gt;&gt; mask = np.zeros_like(a)</span>
<span class="sd">    &gt;&gt;&gt; mask[1:, 1:] = 1</span>

<span class="sd">    &gt;&gt;&gt; ma = np.ma.array(a, mask=mask)</span>
<span class="sd">    &gt;&gt;&gt; np.array(ma[~ma.mask])</span>
<span class="sd">    array([0, 1, 2, 3, 6])</span>

<span class="sd">    &gt;&gt;&gt; np.ma.notmasked_contiguous(ma)</span>
<span class="sd">    [slice(0, 4, None), slice(6, 7, None)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">nd</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">nd</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Currently limited to atmost 2D array.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">nd</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">flatnotmasked_contiguous</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1">#</span>
    <span class="n">other</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="c1">#</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">other</span><span class="p">]):</span>
        <span class="n">idx</span><span class="p">[</span><span class="n">other</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">flatnotmasked_contiguous</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span> <span class="ow">or</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">_ezclump</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Finds the clumps (groups of data with the same values) for a 1D bool array.</span>

<span class="sd">    Returns a series of slices.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#def clump_masked(a):</span>
    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">^</span> <span class="n">mask</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
              <span class="k">for</span> <span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">idx</span><span class="p">),</span>
                                       <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">mask</span><span class="p">)]),)]</span>
    <span class="k">return</span> <span class="n">slices</span>


<div class="viewcode-block" id="clump_unmasked"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.clump_unmasked.html#numpy.ma.clump_unmasked">[docs]</a><span class="k">def</span> <span class="nf">clump_unmasked</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return list of slices corresponding to the unmasked clumps of a 1-D array.</span>
<span class="sd">    (A &quot;clump&quot; is defined as a contiguous region of the array).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        A one-dimensional masked array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slices : list of slice</span>
<span class="sd">        The list of slices, one for each continuous region of unmasked</span>
<span class="sd">        elements in `a`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.4.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,</span>
<span class="sd">    notmasked_contiguous, clump_masked</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.ma.masked_array(np.arange(10))</span>
<span class="sd">    &gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked</span>
<span class="sd">    &gt;&gt;&gt; np.ma.clump_unmasked(a)</span>
<span class="sd">    [slice(3, 6, None), slice(7, 8, None)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span><span class="p">)]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">_ezclump</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="clump_masked"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.clump_masked.html#numpy.ma.clump_masked">[docs]</a><span class="k">def</span> <span class="nf">clump_masked</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a list of slices corresponding to the masked clumps of a 1-D array.</span>
<span class="sd">    (A &quot;clump&quot; is defined as a contiguous region of the array).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        A one-dimensional masked array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    slices : list of slice</span>
<span class="sd">        The list of slices, one for each continuous region of masked elements</span>
<span class="sd">        in `a`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    .. versionadded:: 1.4.0</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    flatnotmasked_edges, flatnotmasked_contiguous, notmasked_edges,</span>
<span class="sd">    notmasked_contiguous, clump_unmasked</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.ma.masked_array(np.arange(10))</span>
<span class="sd">    &gt;&gt;&gt; a[[0, 1, 2, 6, 8, 9]] = np.ma.masked</span>
<span class="sd">    &gt;&gt;&gt; np.ma.clump_masked(a)</span>
<span class="sd">    [slice(0, 3, None), slice(6, 7, None), slice(8, 10, None)]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">slices</span> <span class="o">=</span> <span class="n">_ezclump</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[::</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">slices</span> <span class="o">=</span> <span class="n">slices</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">slices</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#                              Polynomial fit                                 #</span>
<span class="c1">###############################################################################</span>


<div class="viewcode-block" id="vander"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.vander.html#numpy.ma.vander">[docs]</a><span class="k">def</span> <span class="nf">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Masked values in the input array result in rows of zeros.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_vander</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">_vander</span><span class="p">[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">return</span> <span class="n">_vander</span></div>

<span class="n">vander</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">doc_note</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">vander</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>


<div class="viewcode-block" id="polyfit"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.polyfit.html#numpy.ma.polyfit">[docs]</a><span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">full</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Any masked values in x is propagated in y, and vice-versa.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">getmask</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="k">elif</span> <span class="n">y</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">my</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">mask_rows</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">my</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">my</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Expected a 1D or 2D array for y!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">asarray</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected a 1-d array for weights&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">w</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;expected w and y to have the same length&quot;</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">getmask</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">not_m</span> <span class="o">=</span> <span class="o">~</span><span class="n">m</span>
        <span class="k">if</span> <span class="n">w</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">not_m</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">not_m</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="n">not_m</span><span class="p">],</span> <span class="n">deg</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span> <span class="n">full</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">deg</span><span class="p">,</span> <span class="n">rcond</span><span class="p">,</span> <span class="n">full</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">cov</span><span class="p">)</span></div>

<span class="n">polyfit</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">doc_note</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span> <span class="n">polyfit</span><span class="o">.</span><span class="n">__doc__</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>