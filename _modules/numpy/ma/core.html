

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>numpy.ma.core &mdash; Numpy API</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Numpy API" href="../../../index.html"/>
        <link rel="up" title="numpy" href="../../numpy.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Numpy API
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.html">1. NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.doc.html">2. <code class="docutils literal"><span class="pre">numpy.doc</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.lib.html">3. <code class="docutils literal"><span class="pre">numpy.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.random.html">4. <code class="docutils literal"><span class="pre">numpy.random</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.linalg.html">5. <code class="docutils literal"><span class="pre">numpy.linalg</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.fft.html">6. Discrete Fourier Transform (<code class="docutils literal"><span class="pre">numpy.fft</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.polynomial.html">7. <code class="docutils literal"><span class="pre">numpy.polynomial</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.testing.html">8. <code class="docutils literal"><span class="pre">numpy.testing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.f2py.html">9. <code class="docutils literal"><span class="pre">numpy.f2py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.distutils.html">10. <code class="docutils literal"><span class="pre">numpy.distutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">11. NumPy Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">12. Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Numpy API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../numpy.html">numpy</a> &raquo;</li>
        
      <li>numpy.ma.core</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for numpy.ma.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">numpy.ma : a package to handle missing or invalid values.</span>

<span class="sd">This package was initially written for numarray by Paul F. Dubois</span>
<span class="sd">at Lawrence Livermore National Laboratory.</span>
<span class="sd">In 2006, the package was completely rewritten by Pierre Gerard-Marchant</span>
<span class="sd">(University of Georgia) to make the MaskedArray class a subclass of ndarray,</span>
<span class="sd">and to improve support of structured arrays.</span>


<span class="sd">Copyright 1999, 2000, 2001 Regents of the University of California.</span>
<span class="sd">Released for unlimited redistribution.</span>

<span class="sd">* Adapted for numpy_core 2005 by Travis Oliphant and (mainly) Paul Dubois.</span>
<span class="sd">* Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant</span>
<span class="sd">  (pgmdevlist_AT_gmail_DOT_com)</span>
<span class="sd">* Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com)</span>

<span class="sd">.. moduleauthor:: Pierre Gerard-Marchant</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c1"># pylint: disable-msg=E1002</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="nb">reduce</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">numpy.core.umath</span> <span class="kn">as</span> <span class="nn">umath</span>
<span class="kn">import</span> <span class="nn">numpy.core.numerictypes</span> <span class="kn">as</span> <span class="nn">ntypes</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">amax</span><span class="p">,</span> <span class="n">amin</span><span class="p">,</span> <span class="n">iscomplexobj</span><span class="p">,</span> <span class="n">bool_</span><span class="p">,</span> <span class="n">_NoValue</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">array</span> <span class="k">as</span> <span class="n">narray</span>
<span class="kn">from</span> <span class="nn">numpy.lib.function_base</span> <span class="kn">import</span> <span class="n">angle</span>
<span class="kn">from</span> <span class="nn">numpy.compat</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">getargspec</span><span class="p">,</span> <span class="n">formatargspec</span><span class="p">,</span> <span class="nb">long</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">unicode</span>
    <span class="p">)</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">expand_dims</span> <span class="k">as</span> <span class="n">n_expand_dims</span>


<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;MAError&#39;</span><span class="p">,</span> <span class="s1">&#39;MaskError&#39;</span><span class="p">,</span> <span class="s1">&#39;MaskType&#39;</span><span class="p">,</span> <span class="s1">&#39;MaskedArray&#39;</span><span class="p">,</span> <span class="s1">&#39;abs&#39;</span><span class="p">,</span> <span class="s1">&#39;absolute&#39;</span><span class="p">,</span>
    <span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;allclose&#39;</span><span class="p">,</span> <span class="s1">&#39;allequal&#39;</span><span class="p">,</span> <span class="s1">&#39;alltrue&#39;</span><span class="p">,</span> <span class="s1">&#39;amax&#39;</span><span class="p">,</span> <span class="s1">&#39;amin&#39;</span><span class="p">,</span>
    <span class="s1">&#39;angle&#39;</span><span class="p">,</span> <span class="s1">&#39;anom&#39;</span><span class="p">,</span> <span class="s1">&#39;anomalies&#39;</span><span class="p">,</span> <span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="s1">&#39;append&#39;</span><span class="p">,</span> <span class="s1">&#39;arange&#39;</span><span class="p">,</span> <span class="s1">&#39;arccos&#39;</span><span class="p">,</span>
    <span class="s1">&#39;arccosh&#39;</span><span class="p">,</span> <span class="s1">&#39;arcsin&#39;</span><span class="p">,</span> <span class="s1">&#39;arcsinh&#39;</span><span class="p">,</span> <span class="s1">&#39;arctan&#39;</span><span class="p">,</span> <span class="s1">&#39;arctan2&#39;</span><span class="p">,</span> <span class="s1">&#39;arctanh&#39;</span><span class="p">,</span>
    <span class="s1">&#39;argmax&#39;</span><span class="p">,</span> <span class="s1">&#39;argmin&#39;</span><span class="p">,</span> <span class="s1">&#39;argsort&#39;</span><span class="p">,</span> <span class="s1">&#39;around&#39;</span><span class="p">,</span> <span class="s1">&#39;array&#39;</span><span class="p">,</span> <span class="s1">&#39;asanyarray&#39;</span><span class="p">,</span>
    <span class="s1">&#39;asarray&#39;</span><span class="p">,</span> <span class="s1">&#39;bitwise_and&#39;</span><span class="p">,</span> <span class="s1">&#39;bitwise_or&#39;</span><span class="p">,</span> <span class="s1">&#39;bitwise_xor&#39;</span><span class="p">,</span> <span class="s1">&#39;bool_&#39;</span><span class="p">,</span> <span class="s1">&#39;ceil&#39;</span><span class="p">,</span>
    <span class="s1">&#39;choose&#39;</span><span class="p">,</span> <span class="s1">&#39;clip&#39;</span><span class="p">,</span> <span class="s1">&#39;common_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;compress&#39;</span><span class="p">,</span> <span class="s1">&#39;compressed&#39;</span><span class="p">,</span>
    <span class="s1">&#39;concatenate&#39;</span><span class="p">,</span> <span class="s1">&#39;conjugate&#39;</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="s1">&#39;cos&#39;</span><span class="p">,</span> <span class="s1">&#39;cosh&#39;</span><span class="p">,</span> <span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="s1">&#39;cumprod&#39;</span><span class="p">,</span>
    <span class="s1">&#39;cumsum&#39;</span><span class="p">,</span> <span class="s1">&#39;default_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;diag&#39;</span><span class="p">,</span> <span class="s1">&#39;diagonal&#39;</span><span class="p">,</span> <span class="s1">&#39;diff&#39;</span><span class="p">,</span> <span class="s1">&#39;divide&#39;</span><span class="p">,</span>
    <span class="s1">&#39;dump&#39;</span><span class="p">,</span> <span class="s1">&#39;dumps&#39;</span><span class="p">,</span> <span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="s1">&#39;empty_like&#39;</span><span class="p">,</span> <span class="s1">&#39;equal&#39;</span><span class="p">,</span> <span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="s1">&#39;expand_dims&#39;</span><span class="p">,</span>
    <span class="s1">&#39;fabs&#39;</span><span class="p">,</span> <span class="s1">&#39;filled&#39;</span><span class="p">,</span> <span class="s1">&#39;fix_invalid&#39;</span><span class="p">,</span> <span class="s1">&#39;flatten_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;flatten_structured_array&#39;</span><span class="p">,</span> <span class="s1">&#39;floor&#39;</span><span class="p">,</span> <span class="s1">&#39;floor_divide&#39;</span><span class="p">,</span> <span class="s1">&#39;fmod&#39;</span><span class="p">,</span>
    <span class="s1">&#39;frombuffer&#39;</span><span class="p">,</span> <span class="s1">&#39;fromflex&#39;</span><span class="p">,</span> <span class="s1">&#39;fromfunction&#39;</span><span class="p">,</span> <span class="s1">&#39;getdata&#39;</span><span class="p">,</span> <span class="s1">&#39;getmask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;getmaskarray&#39;</span><span class="p">,</span> <span class="s1">&#39;greater&#39;</span><span class="p">,</span> <span class="s1">&#39;greater_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;harden_mask&#39;</span><span class="p">,</span> <span class="s1">&#39;hypot&#39;</span><span class="p">,</span>
    <span class="s1">&#39;identity&#39;</span><span class="p">,</span> <span class="s1">&#39;ids&#39;</span><span class="p">,</span> <span class="s1">&#39;indices&#39;</span><span class="p">,</span> <span class="s1">&#39;inner&#39;</span><span class="p">,</span> <span class="s1">&#39;innerproduct&#39;</span><span class="p">,</span> <span class="s1">&#39;isMA&#39;</span><span class="p">,</span>
    <span class="s1">&#39;isMaskedArray&#39;</span><span class="p">,</span> <span class="s1">&#39;is_mask&#39;</span><span class="p">,</span> <span class="s1">&#39;is_masked&#39;</span><span class="p">,</span> <span class="s1">&#39;isarray&#39;</span><span class="p">,</span> <span class="s1">&#39;left_shift&#39;</span><span class="p">,</span>
    <span class="s1">&#39;less&#39;</span><span class="p">,</span> <span class="s1">&#39;less_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="s1">&#39;loads&#39;</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;log10&#39;</span><span class="p">,</span> <span class="s1">&#39;log2&#39;</span><span class="p">,</span>
    <span class="s1">&#39;logical_and&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_not&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_or&#39;</span><span class="p">,</span> <span class="s1">&#39;logical_xor&#39;</span><span class="p">,</span> <span class="s1">&#39;make_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;make_mask_descr&#39;</span><span class="p">,</span> <span class="s1">&#39;make_mask_none&#39;</span><span class="p">,</span> <span class="s1">&#39;mask_or&#39;</span><span class="p">,</span> <span class="s1">&#39;masked&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_array&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_greater&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_greater_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_inside&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_invalid&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_less&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_less_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_not_equal&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_object&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_outside&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_print_option&#39;</span><span class="p">,</span>
    <span class="s1">&#39;masked_singleton&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_values&#39;</span><span class="p">,</span> <span class="s1">&#39;masked_where&#39;</span><span class="p">,</span> <span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;maximum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;maximum_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;mean&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum&#39;</span><span class="p">,</span> <span class="s1">&#39;minimum_fill_value&#39;</span><span class="p">,</span>
    <span class="s1">&#39;mod&#39;</span><span class="p">,</span> <span class="s1">&#39;multiply&#39;</span><span class="p">,</span> <span class="s1">&#39;mvoid&#39;</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="s1">&#39;negative&#39;</span><span class="p">,</span> <span class="s1">&#39;nomask&#39;</span><span class="p">,</span> <span class="s1">&#39;nonzero&#39;</span><span class="p">,</span>
    <span class="s1">&#39;not_equal&#39;</span><span class="p">,</span> <span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="s1">&#39;outerproduct&#39;</span><span class="p">,</span> <span class="s1">&#39;power&#39;</span><span class="p">,</span> <span class="s1">&#39;prod&#39;</span><span class="p">,</span>
    <span class="s1">&#39;product&#39;</span><span class="p">,</span> <span class="s1">&#39;ptp&#39;</span><span class="p">,</span> <span class="s1">&#39;put&#39;</span><span class="p">,</span> <span class="s1">&#39;putmask&#39;</span><span class="p">,</span> <span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="s1">&#39;ravel&#39;</span><span class="p">,</span> <span class="s1">&#39;remainder&#39;</span><span class="p">,</span>
    <span class="s1">&#39;repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;reshape&#39;</span><span class="p">,</span> <span class="s1">&#39;resize&#39;</span><span class="p">,</span> <span class="s1">&#39;right_shift&#39;</span><span class="p">,</span> <span class="s1">&#39;round&#39;</span><span class="p">,</span> <span class="s1">&#39;round_&#39;</span><span class="p">,</span>
    <span class="s1">&#39;set_fill_value&#39;</span><span class="p">,</span> <span class="s1">&#39;shape&#39;</span><span class="p">,</span> <span class="s1">&#39;sin&#39;</span><span class="p">,</span> <span class="s1">&#39;sinh&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">,</span> <span class="s1">&#39;soften_mask&#39;</span><span class="p">,</span>
    <span class="s1">&#39;sometrue&#39;</span><span class="p">,</span> <span class="s1">&#39;sort&#39;</span><span class="p">,</span> <span class="s1">&#39;sqrt&#39;</span><span class="p">,</span> <span class="s1">&#39;squeeze&#39;</span><span class="p">,</span> <span class="s1">&#39;std&#39;</span><span class="p">,</span> <span class="s1">&#39;subtract&#39;</span><span class="p">,</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span>
    <span class="s1">&#39;swapaxes&#39;</span><span class="p">,</span> <span class="s1">&#39;take&#39;</span><span class="p">,</span> <span class="s1">&#39;tan&#39;</span><span class="p">,</span> <span class="s1">&#39;tanh&#39;</span><span class="p">,</span> <span class="s1">&#39;trace&#39;</span><span class="p">,</span> <span class="s1">&#39;transpose&#39;</span><span class="p">,</span> <span class="s1">&#39;true_divide&#39;</span><span class="p">,</span>
    <span class="s1">&#39;var&#39;</span><span class="p">,</span> <span class="s1">&#39;where&#39;</span><span class="p">,</span> <span class="s1">&#39;zeros&#39;</span><span class="p">,</span>
    <span class="p">]</span>

<span class="n">MaskType</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span>
<span class="n">nomask</span> <span class="o">=</span> <span class="n">MaskType</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">doc_note</span><span class="p">(</span><span class="n">initialdoc</span><span class="p">,</span> <span class="n">note</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds a Notes section to an existing docstring.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">initialdoc</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span>
    <span class="k">if</span> <span class="n">note</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">initialdoc</span>
    <span class="n">newdoc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2"></span>

<span class="s2">    Notes</span>
<span class="s2">    -----</span>
<span class="s2">    </span><span class="si">%s</span><span class="s2"></span>
<span class="s2">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">newdoc</span> <span class="o">%</span> <span class="p">(</span><span class="n">initialdoc</span><span class="p">,</span> <span class="n">note</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">get_object_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the signature from obj</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">formatargspec</span><span class="p">(</span><span class="o">*</span><span class="n">getargspec</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="k">return</span> <span class="n">sig</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                              Exceptions                                     #</span>
<span class="c1">###############################################################################</span>


<span class="k">class</span> <span class="nc">MAError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for masked array related errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">MaskError</span><span class="p">(</span><span class="n">MAError</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for mask related errors.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                           Filling options                                   #</span>
<span class="c1">###############################################################################</span>


<span class="c1"># b: boolean - c: complex - f: floats - i: integer - O: object - S: string</span>
<span class="n">default_filler</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="bp">True</span><span class="p">,</span>
                  <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="mf">1.e20</span> <span class="o">+</span> <span class="mf">0.0j</span><span class="p">,</span>
                  <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">1.e20</span><span class="p">,</span>
                  <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mi">999999</span><span class="p">,</span>
                  <span class="s1">&#39;O&#39;</span><span class="p">:</span> <span class="s1">&#39;?&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;S&#39;</span><span class="p">:</span> <span class="s1">&#39;N/A&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;u&#39;</span><span class="p">:</span> <span class="mi">999999</span><span class="p">,</span>
                  <span class="s1">&#39;V&#39;</span><span class="p">:</span> <span class="s1">&#39;???&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;U&#39;</span><span class="p">:</span> <span class="s1">&#39;N/A&#39;</span>
                  <span class="p">}</span>

<span class="c1"># Add datetime64 and timedelta64 types</span>
<span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Y&quot;</span><span class="p">,</span> <span class="s2">&quot;M&quot;</span><span class="p">,</span> <span class="s2">&quot;W&quot;</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="s2">&quot;h&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;ms&quot;</span><span class="p">,</span> <span class="s2">&quot;us&quot;</span><span class="p">,</span> <span class="s2">&quot;ns&quot;</span><span class="p">,</span> <span class="s2">&quot;ps&quot;</span><span class="p">,</span>
          <span class="s2">&quot;fs&quot;</span><span class="p">,</span> <span class="s2">&quot;as&quot;</span><span class="p">]:</span>
    <span class="n">default_filler</span><span class="p">[</span><span class="s2">&quot;M8[&quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">datetime64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">default_filler</span><span class="p">[</span><span class="s2">&quot;m8[&quot;</span> <span class="o">+</span> <span class="n">v</span> <span class="o">+</span> <span class="s2">&quot;]&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">timedelta64</span><span class="p">(</span><span class="s2">&quot;NaT&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">max_filler</span> <span class="o">=</span> <span class="n">ntypes</span><span class="o">.</span><span class="n">_minvals</span>
<span class="n">max_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]])</span>
<span class="n">min_filler</span> <span class="o">=</span> <span class="n">ntypes</span><span class="o">.</span><span class="n">_maxvals</span>
<span class="n">min_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">k</span><span class="p">,</span> <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]])</span>
<span class="k">if</span> <span class="s1">&#39;float128&#39;</span> <span class="ow">in</span> <span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">:</span>
    <span class="n">max_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>
    <span class="n">min_filler</span><span class="o">.</span><span class="n">update</span><span class="p">([(</span><span class="n">np</span><span class="o">.</span><span class="n">float128</span><span class="p">,</span> <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)])</span>


<div class="viewcode-block" id="default_fill_value"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.default_fill_value.html#numpy.ma.default_fill_value">[docs]</a><span class="k">def</span> <span class="nf">default_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the default fill value for the argument object.</span>

<span class="sd">    The default filling value depends on the datatype of the input</span>
<span class="sd">    array or the type of the input scalar:</span>

<span class="sd">       ========  ========</span>
<span class="sd">       datatype  default</span>
<span class="sd">       ========  ========</span>
<span class="sd">       bool      True</span>
<span class="sd">       int       999999</span>
<span class="sd">       float     1.e20</span>
<span class="sd">       complex   1.e20+0j</span>
<span class="sd">       object    &#39;?&#39;</span>
<span class="sd">       string    &#39;N/A&#39;</span>
<span class="sd">       ========  ========</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : ndarray, dtype or scalar</span>
<span class="sd">        The array data-type or scalar for which the default fill value</span>
<span class="sd">        is returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fill_value : scalar</span>
<span class="sd">        The default fill value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.ma.default_fill_value(1)</span>
<span class="sd">    999999</span>
<span class="sd">    &gt;&gt;&gt; np.ma.default_fill_value(np.array([1.1, 2., np.pi]))</span>
<span class="sd">    1e+20</span>
<span class="sd">    &gt;&gt;&gt; np.ma.default_fill_value(np.dtype(complex))</span>
<span class="sd">    (1e+20+0j)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
        <span class="n">defval</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">subdtype</span><span class="p">:</span>
            <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">subdtype</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;Mm&#39;</span><span class="p">:</span>
            <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">str</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="s1">&#39;?&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">long</span><span class="p">):</span>
        <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
        <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="p">[</span><span class="s1">&#39;U&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
        <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="p">[</span><span class="s1">&#39;c&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">defval</span> <span class="o">=</span> <span class="n">default_filler</span><span class="p">[</span><span class="s1">&#39;O&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">defval</span></div>


<span class="k">def</span> <span class="nf">_recursive_extremum_fill_value</span><span class="p">(</span><span class="n">ndtype</span><span class="p">,</span> <span class="n">extremum</span><span class="p">):</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">ndtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">deflist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">fval</span> <span class="o">=</span> <span class="n">_recursive_extremum_fill_value</span><span class="p">(</span><span class="n">ndtype</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">extremum</span><span class="p">)</span>
            <span class="n">deflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fval</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">deflist</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">extremum</span><span class="p">[</span><span class="n">ndtype</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">minimum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the maximum value that can be represented by the dtype of an object.</span>

<span class="sd">    This function is useful for calculating a fill value suitable for</span>
<span class="sd">    taking the minimum of an array with a given dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : ndarray or dtype</span>
<span class="sd">        An object that can be queried for it&#39;s numeric type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : scalar</span>
<span class="sd">        The maximum representable value.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If `obj` isn&#39;t a suitable numeric type.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    maximum_fill_value : The inverse function.</span>
<span class="sd">    set_fill_value : Set the filling value of a masked array.</span>
<span class="sd">    MaskedArray.fill_value : Return current fill value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.int8()</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    127</span>
<span class="sd">    &gt;&gt;&gt; a = np.int32()</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    2147483647</span>

<span class="sd">    An array of numeric data can also be passed.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    127</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; ma.minimum_fill_value(a)</span>
<span class="sd">    inf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Unsuitable type for calculating minimum.&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_recursive_extremum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">min_filler</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">min_filler</span><span class="p">[</span><span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="s1">&#39;float_&#39;</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">min_filler</span><span class="p">[</span><span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="s1">&#39;int_&#39;</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">long</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">min_filler</span><span class="p">[</span><span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="s1">&#39;uint&#39;</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">min_filler</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>


<div class="viewcode-block" id="maximum_fill_value"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.maximum_fill_value.html#numpy.ma.maximum_fill_value">[docs]</a><span class="k">def</span> <span class="nf">maximum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the minimum value that can be represented by the dtype of an object.</span>

<span class="sd">    This function is useful for calculating a fill value suitable for</span>
<span class="sd">    taking the maximum of an array with a given dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : {ndarray, dtype}</span>
<span class="sd">        An object that can be queried for it&#39;s numeric type.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    val : scalar</span>
<span class="sd">        The minimum representable value.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        If `obj` isn&#39;t a suitable numeric type.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    minimum_fill_value : The inverse function.</span>
<span class="sd">    set_fill_value : Set the filling value of a masked array.</span>
<span class="sd">    MaskedArray.fill_value : Return current fill value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.int8()</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -128</span>
<span class="sd">    &gt;&gt;&gt; a = np.int32()</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -2147483648</span>

<span class="sd">    An array of numeric data can also be passed.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.int8)</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -128</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([1, 2, 3], dtype=np.float32)</span>
<span class="sd">    &gt;&gt;&gt; ma.maximum_fill_value(a)</span>
<span class="sd">    -inf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Unsuitable type for calculating maximum.&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">_recursive_extremum_fill_value</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">max_filler</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">max_filler</span><span class="p">[</span><span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="s1">&#39;float_&#39;</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">max_filler</span><span class="p">[</span><span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="s1">&#39;int_&#39;</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">long</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">max_filler</span><span class="p">[</span><span class="n">ntypes</span><span class="o">.</span><span class="n">typeDict</span><span class="p">[</span><span class="s1">&#39;uint&#39;</span><span class="p">]]</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">max_filler</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_recursive_set_default_fill_value</span><span class="p">(</span><span class="n">dtypedescr</span><span class="p">):</span>
    <span class="n">deflist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">currentdescr</span> <span class="ow">in</span> <span class="n">dtypedescr</span><span class="p">:</span>
        <span class="n">currenttype</span> <span class="o">=</span> <span class="n">currentdescr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">currenttype</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">deflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="nb">tuple</span><span class="p">(</span><span class="n">_recursive_set_default_fill_value</span><span class="p">(</span><span class="n">currenttype</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">deflist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">default_fill_value</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">currenttype</span><span class="p">)))</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">deflist</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_recursive_set_fill_value</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="n">dtypedescr</span><span class="p">):</span>
    <span class="n">fillvalue</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtypedescr</span><span class="p">))</span>
    <span class="n">output_value</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">descr</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fillvalue</span><span class="p">,</span> <span class="n">dtypedescr</span><span class="p">):</span>
        <span class="n">cdtype</span> <span class="o">=</span> <span class="n">descr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cdtype</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">output_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">_recursive_set_fill_value</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">cdtype</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output_value</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fval</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">cdtype</span><span class="p">)</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
    <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">output_value</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">ndtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function validating the given `fill_value` for the given dtype.</span>

<span class="sd">    If fill_value is None, it is set to the default corresponding to the dtype</span>
<span class="sd">    if this latter is standard (no fields). If the datatype is flexible (named</span>
<span class="sd">    fields), fill_value is set to a tuple whose elements are the default fill</span>
<span class="sd">    values corresponding to each field.</span>

<span class="sd">    If fill_value is not None, its value is forced to the given dtype.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">ndtype</span><span class="p">)</span>
    <span class="n">fields</span> <span class="o">=</span> <span class="n">ndtype</span><span class="o">.</span><span class="n">fields</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fields</span><span class="p">:</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="n">ndtype</span><span class="o">.</span><span class="n">descr</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_recursive_set_default_fill_value</span><span class="p">(</span><span class="n">descr</span><span class="p">),</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">ndtype</span><span class="p">,)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="n">ndtype</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">fields</span><span class="p">:</span>
        <span class="n">fdtype</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">_</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">ndtype</span><span class="o">.</span><span class="n">descr</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">)):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">fdtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Unable to transform </span><span class="si">%s</span><span class="s2"> to dtype </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">fdtype</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="n">ndtype</span><span class="o">.</span><span class="n">descr</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">_recursive_set_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">descr</span><span class="p">),</span>
                                  <span class="n">dtype</span><span class="o">=</span><span class="n">ndtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ndtype</span><span class="o">.</span><span class="n">char</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s1">&#39;OSVU&#39;</span><span class="p">):</span>
            <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Cannot set fill value of string with array of dtype </span><span class="si">%s</span><span class="s2">&quot;</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">%</span> <span class="n">ndtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># In case we want to convert 1e20 to int.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ndtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">OverflowError</span><span class="p">:</span>
                <span class="c1"># Raise TypeError instead of OverflowError. OverflowError</span>
                <span class="c1"># is seldom used, and the real problem here is that the</span>
                <span class="c1"># passed fill_value is not compatible with the ndtype.</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Fill value </span><span class="si">%s</span><span class="s2"> overflows dtype </span><span class="si">%s</span><span class="s2">&quot;</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">err_msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">ndtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>


<div class="viewcode-block" id="set_fill_value"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.set_fill_value.html#numpy.ma.set_fill_value">[docs]</a><span class="k">def</span> <span class="nf">set_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set the filling value of a, if a is a masked array.</span>

<span class="sd">    This function changes the fill value of the masked array `a` in place.</span>
<span class="sd">    If `a` is not a masked array, the function returns silently, without</span>
<span class="sd">    doing anything.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array.</span>
<span class="sd">    fill_value : dtype</span>
<span class="sd">        Filling value. A consistency test is performed to make sure</span>
<span class="sd">        the value is compatible with the dtype of `a`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>
<span class="sd">        Nothing returned by this function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    maximum_fill_value : Return the default fill value for a dtype.</span>
<span class="sd">    MaskedArray.fill_value : Return current fill value.</span>
<span class="sd">    MaskedArray.set_fill_value : Equivalent method.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_where(a &lt; 3, a)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [-- -- -- 3 4],</span>
<span class="sd">          mask = [ True  True  True False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.set_fill_value(a, -999)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [-- -- -- 3 4],</span>
<span class="sd">          mask = [ True  True  True False False],</span>
<span class="sd">          fill_value=-999)</span>

<span class="sd">    Nothing happens if `a` is not a masked array.</span>

<span class="sd">    &gt;&gt;&gt; a = range(5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    [0, 1, 2, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; ma.set_fill_value(a, 100)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    [0, 1, 2, 3, 4]</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; ma.set_fill_value(a, 100)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">a</span><span class="o">.</span><span class="n">set_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">return</span></div>


<span class="k">def</span> <span class="nf">get_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the filling value of a, if any.  Otherwise, returns the</span>
<span class="sd">    default filling value for that type.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fill_value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="common_fill_value"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.common_fill_value.html#numpy.ma.common_fill_value">[docs]</a><span class="k">def</span> <span class="nf">common_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the common filling value of two masked arrays, if any.</span>

<span class="sd">    If ``a.fill_value == b.fill_value``, return the fill value,</span>
<span class="sd">    otherwise return None.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : MaskedArray</span>
<span class="sd">        The masked arrays for which to compare fill values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    fill_value : scalar or None</span>
<span class="sd">        The common fill value, or None.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=3)</span>
<span class="sd">    &gt;&gt;&gt; y = np.ma.array([0, 1.], fill_value=3)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.common_fill_value(x, y)</span>
<span class="sd">    3.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">get_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">get_fill_value</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t1</span>
    <span class="k">return</span> <span class="bp">None</span></div>


<div class="viewcode-block" id="filled"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.filled.html#numpy.ma.filled">[docs]</a><span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return input as an array with masked data replaced by a fill value.</span>

<span class="sd">    If `a` is not a `MaskedArray`, `a` itself is returned.</span>
<span class="sd">    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to</span>
<span class="sd">    ``a.fill_value``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : MaskedArray or array_like</span>
<span class="sd">        An input object.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Filling value. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : ndarray</span>
<span class="sd">        The filled array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    compressed</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],</span>
<span class="sd">    ...                                                   [1, 0, 0],</span>
<span class="sd">    ...                                                   [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; x.filled()</span>
<span class="sd">    array([[999999,      1,      2],</span>
<span class="sd">           [999999,      4,      5],</span>
<span class="sd">           [     6,      7,      8]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;filled&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># Should we check for contiguity ? and a.flags[&#39;CONTIGUOUS&#39;]:</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;O&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">get_masked_subclass</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the youngest subclass of MaskedArray from a list of (masked) arrays.</span>

<span class="sd">    In case of siblings, the first listed takes over.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">rcls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rcls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">arrcls</span> <span class="o">=</span> <span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">]</span>
        <span class="n">rcls</span> <span class="o">=</span> <span class="n">arrcls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">rcls</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">rcls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
        <span class="k">for</span> <span class="n">cls</span> <span class="ow">in</span> <span class="n">arrcls</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">rcls</span><span class="p">):</span>
                <span class="n">rcls</span> <span class="o">=</span> <span class="n">cls</span>
    <span class="c1"># Don&#39;t return MaskedConstant as result: revert to MaskedArray</span>
    <span class="k">if</span> <span class="n">rcls</span><span class="o">.</span><span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;MaskedConstant&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">MaskedArray</span>
    <span class="k">return</span> <span class="n">rcls</span>


<div class="viewcode-block" id="getdata"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.getdata.html#numpy.ma.getdata">[docs]</a><span class="k">def</span> <span class="nf">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the data of a masked array as an ndarray.</span>

<span class="sd">    Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,</span>
<span class="sd">    else return `a` as a ndarray or subclass (depending on `subok`) if not.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.</span>
<span class="sd">    subok : bool</span>
<span class="sd">        Whether to force the output to be a `pure` ndarray (False) or to</span>
<span class="sd">        return a subclass of ndarray if appropriate (True, default).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    getmask : Return the mask of a masked array, or nomask.</span>
<span class="sd">    getmaskarray : Return the mask of a masked array, or full array of False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.getdata(a)</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    Equivalently use the ``MaskedArray`` `data` attribute.</span>

<span class="sd">    &gt;&gt;&gt; a.data</span>
<span class="sd">    array([[1, 2],</span>
<span class="sd">           [3, 4]])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">subok</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<span class="n">get_data</span> <span class="o">=</span> <span class="n">getdata</span>


<div class="viewcode-block" id="fix_invalid"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.fix_invalid.html#numpy.ma.fix_invalid">[docs]</a><span class="k">def</span> <span class="nf">fix_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return input with invalid data masked and replaced by a fill value.</span>

<span class="sd">    Invalid data means values of `nan`, `inf`, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array, a (subclass of) ndarray.</span>
<span class="sd">    mask : sequence, optional</span>
<span class="sd">        Mask. Must be convertible to an array of booleans with the same</span>
<span class="sd">        shape as `data`. True indicates a masked (i.e. invalid) data.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to use a copy of `a` (True) or to fix `a` in place (False).</span>
<span class="sd">        Default is True.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Value used for fixing invalid data. Default is None, in which case</span>
<span class="sd">        the ``a.fill_value`` is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    b : MaskedArray</span>
<span class="sd">        The input array with invalid entries fixed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    A copy is performed by default.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [-- -1.0 nan inf],</span>
<span class="sd">                 mask = [ True False False False],</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.fix_invalid(x)</span>
<span class="sd">    masked_array(data = [-- -1.0 -- --],</span>
<span class="sd">                 mask = [ True False  True  True],</span>
<span class="sd">           fill_value = 1e+20)</span>

<span class="sd">    &gt;&gt;&gt; fixed = np.ma.fix_invalid(x)</span>
<span class="sd">    &gt;&gt;&gt; fixed.data</span>
<span class="sd">    array([  1.00000000e+00,  -1.00000000e+00,   1.00000000e+20,</span>
<span class="sd">             1.00000000e+20])</span>
<span class="sd">    &gt;&gt;&gt; x.data</span>
<span class="sd">    array([  1.,  -1.,  NaN,  Inf])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">invalid</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">a</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">invalid</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">fill_value</span>
    <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_value</span>
    <span class="k">return</span> <span class="n">a</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#                                  Ufuncs                                     #</span>
<span class="c1">###############################################################################</span>


<span class="n">ufunc_domain</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">ufunc_fills</span> <span class="o">=</span> <span class="p">{}</span>


<span class="k">class</span> <span class="nc">_DomainCheckInterval</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a valid interval, so that :</span>

<span class="sd">    ``domain_check_interval(a,b)(x) == True`` where</span>
<span class="sd">    ``x &lt; a`` or ``x &gt; b``.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="s2">&quot;domain_check_interval(a,b)(x) = true where x &lt; a or y &gt; b&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">):</span>
            <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">b</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Execute the call behavior.&quot;</span>
        <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">b</span><span class="p">),</span>
                                <span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">a</span><span class="p">))</span>


<span class="k">class</span> <span class="nc">_DomainTan</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a valid interval for the `tan` function, so that:</span>

<span class="sd">    ``domain_tan(eps) = True`` where ``abs(cos(x)) &lt; eps``</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">eps</span><span class="p">):</span>
        <span class="s2">&quot;domain_tan(eps) = true where abs(cos(x)) &lt; eps)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eps</span> <span class="o">=</span> <span class="n">eps</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="bp">self</span><span class="o">.</span><span class="n">eps</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DomainSafeDivide</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a domain for safe division.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">tolerance</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="c1"># Delay the selection of the tolerance to here in order to reduce numpy</span>
        <span class="c1"># import times. The calculation of these parameters is a substantial</span>
        <span class="c1"># component of numpy&#39;s import time.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span><span class="o">.</span><span class="n">tiny</span>
        <span class="c1"># don&#39;t call ma ufuncs from __array_wrap__ which would fail for scalars</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">&gt;=</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DomainGreater</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DomainGreater(v)(x) is True where x &lt;= v.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">critical_value</span><span class="p">):</span>
        <span class="s2">&quot;DomainGreater(v)(x) = true where x &lt;= v&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span> <span class="o">=</span> <span class="n">critical_value</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DomainGreaterEqual</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DomainGreaterEqual(v)(x) is True where x &lt; v.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">critical_value</span><span class="p">):</span>
        <span class="s2">&quot;DomainGreaterEqual(v)(x) = true where x &lt; v&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span> <span class="o">=</span> <span class="n">critical_value</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">return</span> <span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">critical_value</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MaskedUnaryOperation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines masked version of unary operations, where invalid values are</span>
<span class="sd">    pre-masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mufunc : callable</span>
<span class="sd">        The function for which to define a masked version. Made available</span>
<span class="sd">        as ``_MaskedUnaryOperation.f``.</span>
<span class="sd">    fill : scalar, optional</span>
<span class="sd">        Filling value, default is 0.</span>
<span class="sd">    domain : class instance</span>
<span class="sd">        Domain for the function. Should be one of the ``_Domain*``</span>
<span class="sd">        classes. Default is None.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mufunc</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">domain</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">mufunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span> <span class="o">=</span> <span class="n">fill</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mufunc</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">mufunc</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mufunc</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">mufunc</span><span class="p">))</span>
        <span class="n">ufunc_domain</span><span class="p">[</span><span class="n">mufunc</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">mufunc</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the call behavior.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="c1"># Deal with domain</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Case 1.1. : Domained function</span>
            <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Make a mask</span>
            <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">umath</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">domain</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">|=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Case 1.2. : Function without a domain</span>
            <span class="c1"># Get the result and the mask</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="c1"># Case 2.1. : The result is scalarscalar</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Case 2.2. The result is an array</span>
            <span class="c1"># We need to fill the invalid data back w/ the input Now,</span>
            <span class="c1"># that&#39;s plain silly: in C, we would just skip the element and</span>
            <span class="c1"># keep the original, but we do have to do it that way in Python</span>

            <span class="c1"># In case result has a lower dtype than the inputs (as in</span>
            <span class="c1"># equal)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># Transform to</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Masked version of </span><span class="si">%s</span><span class="s2">. [Invalid values are masked]&quot;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_MaskedBinaryOperation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define masked version of binary operations, where invalid</span>
<span class="sd">    values are pre-masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mbfunc : function</span>
<span class="sd">        The function for which to define a masked version. Made available</span>
<span class="sd">        as ``_MaskedBinaryOperation.f``.</span>
<span class="sd">    domain : class instance</span>
<span class="sd">        Default domain for the function. Should be one of the ``_Domain*``</span>
<span class="sd">        classes. Default is None.</span>
<span class="sd">    fillx : scalar, optional</span>
<span class="sd">        Filling value for the first argument, default is 0.</span>
<span class="sd">    filly : scalar, optional</span>
<span class="sd">        Filling value for the second argument, default is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mbfunc</span><span class="p">,</span> <span class="n">fillx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">filly</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        abfunc(fillx, filly) must be defined.</span>

<span class="sd">        abfunc(x, filly) = x for all x to enable reduce.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">mbfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillx</span> <span class="o">=</span> <span class="n">fillx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filly</span> <span class="o">=</span> <span class="n">filly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mbfunc</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">mbfunc</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">mbfunc</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">mbfunc</span><span class="p">))</span>
        <span class="n">ufunc_domain</span><span class="p">[</span><span class="n">mbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">mbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fillx</span><span class="p">,</span> <span class="n">filly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Execute the call behavior.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the data, as ndarray</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="c1"># Get the result</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">():</span>
            <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Get the mask for the result</span>
        <span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">nomask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">mb</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>

        <span class="c1"># Case 1. : scalar</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="c1"># Case 2. : array</span>
        <span class="c1"># Revert result to da where masked</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="c1"># any errors, just abort; impossible to guarantee masked values</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
                <span class="c1"># avoid using &quot;*&quot; since this may be overlaid</span>
                <span class="n">masked_da</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">da</span><span class="p">)</span>
                <span class="c1"># only add back if it can be cast safely</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">masked_da</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">):</span>
                    <span class="n">result</span> <span class="o">+=</span> <span class="n">masked_da</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Transforms to a (subclass of) MaskedArray</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce `target` along the given `axis`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tclass</span> <span class="o">=</span> <span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filly</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">t</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">mr</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span> <span class="ow">or</span> <span class="n">t</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">mr</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tr</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mr</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tr</span>
        <span class="n">masked_tr</span> <span class="o">=</span> <span class="n">tr</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">tclass</span><span class="p">)</span>
        <span class="n">masked_tr</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mr</span>
        <span class="n">masked_tr</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_tr</span>

    <span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the function applied to the outer product of a and b.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">mb</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span> <span class="ow">and</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">da</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="n">masked_d</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">masked_d</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">masked_d</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_d</span>

    <span class="k">def</span> <span class="nf">accumulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accumulate `target` along `axis` after filling with y fill</span>
<span class="sd">        value.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tclass</span> <span class="o">=</span> <span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">filly</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="o">.</span><span class="n">accumulate</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">tclass</span><span class="p">)</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Masked version of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">_DomainedBinaryOperation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define binary operations that have a domain, like divide.</span>

<span class="sd">    They have no reduce, outer or accumulate.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mbfunc : function</span>
<span class="sd">        The function for which to define a masked version. Made available</span>
<span class="sd">        as ``_DomainedBinaryOperation.f``.</span>
<span class="sd">    domain : class instance</span>
<span class="sd">        Default domain for the function. Should be one of the ``_Domain*``</span>
<span class="sd">        classes.</span>
<span class="sd">    fillx : scalar, optional</span>
<span class="sd">        Filling value for the first argument, default is 0.</span>
<span class="sd">    filly : scalar, optional</span>
<span class="sd">        Filling value for the second argument, default is 0.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbfunc</span><span class="p">,</span> <span class="n">domain</span><span class="p">,</span> <span class="n">fillx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">filly</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;abfunc(fillx, filly) must be defined.</span>
<span class="sd">           abfunc(x, filly) = x for all x to enable reduce.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">dbfunc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">domain</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fillx</span> <span class="o">=</span> <span class="n">fillx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filly</span> <span class="o">=</span> <span class="n">filly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dbfunc</span><span class="p">,</span> <span class="s2">&quot;__doc__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dbfunc</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dbfunc</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">dbfunc</span><span class="p">))</span>
        <span class="n">ufunc_domain</span><span class="p">[</span><span class="n">dbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="n">domain</span>
        <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">dbfunc</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">fillx</span><span class="p">,</span> <span class="n">filly</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="s2">&quot;Execute the call behavior.&quot;</span>
        <span class="c1"># Get the data</span>
        <span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="c1"># Get the result</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Get the mask as a combination of the source masks and invalid</span>
        <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">umath</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">|=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">|=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="c1"># Apply the domain</span>
        <span class="n">domain</span> <span class="o">=</span> <span class="n">ufunc_domain</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">|=</span> <span class="n">filled</span><span class="p">(</span><span class="n">domain</span><span class="p">(</span><span class="n">da</span><span class="p">,</span> <span class="n">db</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
        <span class="c1"># Take care of the scalar case first</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># When the mask is True, put back da if possible</span>
        <span class="c1"># any errors, just abort; impossible to guarantee masked values</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="c1"># avoid using &quot;*&quot; since this may be overlaid</span>
            <span class="n">masked_da</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">da</span><span class="p">)</span>
            <span class="c1"># only add back if it can be cast safely</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">can_cast</span><span class="p">(</span><span class="n">masked_da</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;safe&#39;</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">+=</span> <span class="n">masked_da</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># Transforms to a (subclass of) MaskedArray</span>
        <span class="n">masked_result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="n">masked_result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_result</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;Masked version of &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f</span><span class="p">)</span>


<span class="c1"># Unary ufuncs</span>
<span class="n">exp</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">exp</span><span class="p">)</span>
<span class="n">conjugate</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">conjugate</span><span class="p">)</span>
<span class="n">sin</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">sin</span><span class="p">)</span>
<span class="n">cos</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">cos</span><span class="p">)</span>
<span class="n">tan</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">tan</span><span class="p">)</span>
<span class="n">arctan</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arctan</span><span class="p">)</span>
<span class="n">arcsinh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arcsinh</span><span class="p">)</span>
<span class="n">sinh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">sinh</span><span class="p">)</span>
<span class="n">cosh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">cosh</span><span class="p">)</span>
<span class="n">tanh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">tanh</span><span class="p">)</span>
<span class="nb">abs</span> <span class="o">=</span> <span class="n">absolute</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">)</span>
<span class="n">angle</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>  <span class="c1"># from numpy.lib.function_base</span>
<span class="n">fabs</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">fabs</span><span class="p">)</span>
<span class="n">negative</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">negative</span><span class="p">)</span>
<span class="n">floor</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">floor</span><span class="p">)</span>
<span class="n">ceil</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">ceil</span><span class="p">)</span>
<span class="n">around</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">)</span>
<span class="n">logical_not</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_not</span><span class="p">)</span>

<span class="c1"># Domained unary ufuncs</span>
<span class="n">sqrt</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                             <span class="n">_DomainGreaterEqual</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">log</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                            <span class="n">_DomainGreater</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">log2</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">log2</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="n">_DomainGreater</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">log10</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">log10</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                              <span class="n">_DomainGreater</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
<span class="n">tan</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">tan</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                            <span class="n">_DomainTan</span><span class="p">(</span><span class="mf">1e-35</span><span class="p">))</span>
<span class="n">arcsin</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arcsin</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="n">_DomainCheckInterval</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="n">arccos</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arccos</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                               <span class="n">_DomainCheckInterval</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
<span class="n">arccosh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arccosh</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span>
                                <span class="n">_DomainGreaterEqual</span><span class="p">(</span><span class="mf">1.0</span><span class="p">))</span>
<span class="n">arctanh</span> <span class="o">=</span> <span class="n">_MaskedUnaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arctanh</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span>
                                <span class="n">_DomainCheckInterval</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span> <span class="o">+</span> <span class="mf">1e-15</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="mf">1e-15</span><span class="p">))</span>

<span class="c1"># Binary ufuncs</span>
<span class="n">add</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">add</span><span class="p">)</span>
<span class="n">subtract</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">subtract</span><span class="p">)</span>
<span class="n">multiply</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">multiply</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">arctan2</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">arctan2</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
<span class="n">equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">)</span>
<span class="n">equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">not_equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">not_equal</span><span class="p">)</span>
<span class="n">not_equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">less_equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">less_equal</span><span class="p">)</span>
<span class="n">less_equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">greater_equal</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">greater_equal</span><span class="p">)</span>
<span class="n">greater_equal</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">less</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">less</span><span class="p">)</span>
<span class="n">less</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">greater</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">greater</span><span class="p">)</span>
<span class="n">greater</span><span class="o">.</span><span class="n">reduce</span> <span class="o">=</span> <span class="bp">None</span>
<span class="n">logical_and</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="p">)</span>
<span class="n">alltrue</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reduce</span>
<span class="n">logical_or</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">)</span>
<span class="n">sometrue</span> <span class="o">=</span> <span class="n">logical_or</span><span class="o">.</span><span class="n">reduce</span>
<span class="n">logical_xor</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_xor</span><span class="p">)</span>
<span class="n">bitwise_and</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">bitwise_and</span><span class="p">)</span>
<span class="n">bitwise_or</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">bitwise_or</span><span class="p">)</span>
<span class="n">bitwise_xor</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">bitwise_xor</span><span class="p">)</span>
<span class="n">hypot</span> <span class="o">=</span> <span class="n">_MaskedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">hypot</span><span class="p">)</span>

<span class="c1"># Domained binary ufuncs</span>
<span class="n">divide</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">divide</span><span class="p">,</span> <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">true_divide</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">true_divide</span><span class="p">,</span>
                                       <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">floor_divide</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">,</span>
                                        <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">remainder</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">remainder</span><span class="p">,</span>
                                     <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">fmod</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">fmod</span><span class="p">,</span> <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">mod</span> <span class="o">=</span> <span class="n">_DomainedBinaryOperation</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span> <span class="n">_DomainSafeDivide</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                        Mask creation functions                              #</span>
<span class="c1">###############################################################################</span>


<span class="k">def</span> <span class="nf">_recursive_make_descr</span><span class="p">(</span><span class="n">datatype</span><span class="p">,</span> <span class="n">newtype</span><span class="o">=</span><span class="n">bool_</span><span class="p">):</span>
    <span class="s2">&quot;Private function allowing recursion in make_descr.&quot;</span>
    <span class="c1"># Do we have some name fields ?</span>
    <span class="k">if</span> <span class="n">datatype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">descr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">datatype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">datatype</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">field</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="c1"># Prepend the title to the name</span>
                <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">descr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">name</span><span class="p">,</span> <span class="n">_recursive_make_descr</span><span class="p">(</span><span class="n">field</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newtype</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">descr</span>
    <span class="c1"># Is this some kind of composite a la (np.float,2)</span>
    <span class="k">elif</span> <span class="n">datatype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">:</span>
        <span class="n">mdescr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">datatype</span><span class="o">.</span><span class="n">subdtype</span><span class="p">)</span>
        <span class="n">mdescr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">newtype</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">mdescr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">newtype</span>


<div class="viewcode-block" id="make_mask_descr"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.make_mask_descr.html#numpy.ma.make_mask_descr">[docs]</a><span class="k">def</span> <span class="nf">make_mask_descr</span><span class="p">(</span><span class="n">ndtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct a dtype description list from a given dtype.</span>

<span class="sd">    Returns a new dtype object, with the type of all fields in `ndtype` to a</span>
<span class="sd">    boolean type. Field names are not altered.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ndtype : dtype</span>
<span class="sd">        The dtype to convert.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : dtype</span>
<span class="sd">        A dtype that looks like `ndtype`, the type of all fields is boolean.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;foo&#39;, &#39;bar&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[np.float32, np.int]})</span>
<span class="sd">    &gt;&gt;&gt; dtype</span>
<span class="sd">    dtype([(&#39;foo&#39;, &#39;&lt;f4&#39;), (&#39;bar&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_descr(dtype)</span>
<span class="sd">    dtype([(&#39;foo&#39;, &#39;|b1&#39;), (&#39;bar&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_descr(np.float32)</span>
<span class="sd">    &lt;type &#39;numpy.bool_&#39;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure we do have a dtype</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ndtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
        <span class="n">ndtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">ndtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">_recursive_make_descr</span><span class="p">(</span><span class="n">ndtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">))</span></div>


<div class="viewcode-block" id="getmask"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.getmask.html#numpy.ma.getmask">[docs]</a><span class="k">def</span> <span class="nf">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the mask of a masked array, or nomask.</span>

<span class="sd">    Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the</span>
<span class="sd">    mask is not `nomask`, else return `nomask`. To guarantee a full array</span>
<span class="sd">    of booleans of the same shape as a, use `getmaskarray`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input `MaskedArray` for which the mask is required.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    getdata : Return the data of a masked array as an ndarray.</span>
<span class="sd">    getmaskarray : Return the mask of a masked array, or full array of False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.getmask(a)</span>
<span class="sd">    array([[False,  True],</span>
<span class="sd">           [False, False]], dtype=bool)</span>

<span class="sd">    Equivalently use the `MaskedArray` `mask` attribute.</span>

<span class="sd">    &gt;&gt;&gt; a.mask</span>
<span class="sd">    array([[False,  True],</span>
<span class="sd">           [False, False]], dtype=bool)</span>

<span class="sd">    Result when mask == `nomask`</span>

<span class="sd">    &gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 2]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     False,</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.nomask</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.getmask(b) == ma.nomask</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; b.mask == ma.nomask</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span></div>


<span class="n">get_mask</span> <span class="o">=</span> <span class="n">getmask</span>


<div class="viewcode-block" id="getmaskarray"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.getmaskarray.html#numpy.ma.getmaskarray">[docs]</a><span class="k">def</span> <span class="nf">getmaskarray</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the mask of a masked array, or full boolean array of False.</span>

<span class="sd">    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and</span>
<span class="sd">    the mask is not `nomask`, else return a full boolean array of False of</span>
<span class="sd">    the same shape as `arr`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Input `MaskedArray` for which the mask is required.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    getmask : Return the mask of a masked array, or nomask.</span>
<span class="sd">    getdata : Return the data of a masked array as an ndarray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal([[1,2],[3,4]], 2)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.getmaskarray(a)</span>
<span class="sd">    array([[False,  True],</span>
<span class="sd">           [False, False]], dtype=bool)</span>

<span class="sd">    Result when mask == ``nomask``</span>

<span class="sd">    &gt;&gt;&gt; b = ma.masked_array([[1,2],[3,4]])</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 2]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">          mask =</span>
<span class="sd">     False,</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; &gt;ma.getmaskarray(b)</span>
<span class="sd">    array([[False, False],</span>
<span class="sd">           [False, False]], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">arr</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">mask</span></div>


<div class="viewcode-block" id="is_mask"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.is_mask.html#numpy.ma.is_mask">[docs]</a><span class="k">def</span> <span class="nf">is_mask</span><span class="p">(</span><span class="n">m</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if m is a valid, standard mask.</span>

<span class="sd">    This function does not check the contents of the input, only that the</span>
<span class="sd">    type is MaskType. In particular, this function returns False if the</span>
<span class="sd">    mask has a flexible dtype.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Array to test.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : bool</span>
<span class="sd">        True if `m.dtype.type` is MaskType, False otherwise.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isMaskedArray : Test whether input is an instance of MaskedArray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; m = ma.masked_equal([0, 1, 0, 2, 3], 0)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    masked_array(data = [-- 1 -- 2 3],</span>
<span class="sd">          mask = [ True False  True False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m.mask)</span>
<span class="sd">    True</span>

<span class="sd">    Input must be an ndarray (or have similar attributes)</span>
<span class="sd">    for it to be considered a valid mask.</span>

<span class="sd">    &gt;&gt;&gt; m = [False, True, False]</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([False, True, False])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([False,  True, False], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    True</span>

<span class="sd">    Arrays with complex dtypes don&#39;t return True.</span>

<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;monty&#39;, &#39;pithon&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[np.bool, np.bool]})</span>
<span class="sd">    &gt;&gt;&gt; dtype</span>
<span class="sd">    dtype([(&#39;monty&#39;, &#39;|b1&#39;), (&#39;pithon&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; m = np.array([(True, False), (False, True), (True, False)],</span>
<span class="sd">                     dtype=dtype)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([(True, False), (False, True), (True, False)],</span>
<span class="sd">          dtype=[(&#39;monty&#39;, &#39;|b1&#39;), (&#39;pithon&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.is_mask(m)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">MaskType</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="make_mask"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.make_mask.html#numpy.ma.make_mask">[docs]</a><span class="k">def</span> <span class="nf">make_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">MaskType</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a boolean mask from an array.</span>

<span class="sd">    Return `m` as a boolean mask, creating a copy if necessary or requested.</span>
<span class="sd">    The function can accept any sequence that is convertible to integers,</span>
<span class="sd">    or ``nomask``.  Does not require that contents must be 0s and 1s, values</span>
<span class="sd">    of 0 are interepreted as False, everything else as True.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : array_like</span>
<span class="sd">        Potential mask.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to return a copy of `m` (True) or `m` itself (False).</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to shrink `m` to ``nomask`` if all its values are False.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data-type of the output mask. By default, the output mask has a</span>
<span class="sd">        dtype of MaskType (bool). If the dtype is flexible, each field has</span>
<span class="sd">        a boolean dtype. This is ignored when `m` is ``nomask``, in which</span>
<span class="sd">        case ``nomask`` is always returned.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        A boolean mask derived from `m`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; m = [True, False, True, True]</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    array([ True, False,  True,  True], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; m = [1, 0, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    array([ True, False,  True,  True], dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; m = [1, 0, 2, -3]</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    array([ True, False,  True,  True], dtype=bool)</span>

<span class="sd">    Effect of the `shrink` parameter.</span>

<span class="sd">    &gt;&gt;&gt; m = np.zeros(4)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([ 0.,  0.,  0.,  0.])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(m, shrink=False)</span>
<span class="sd">    array([False, False, False, False], dtype=bool)</span>

<span class="sd">    Using a flexible `dtype`.</span>

<span class="sd">    &gt;&gt;&gt; m = [1, 0, 1, 1]</span>
<span class="sd">    &gt;&gt;&gt; n = [0, 1, 0, 0]</span>
<span class="sd">    &gt;&gt;&gt; arr = []</span>
<span class="sd">    &gt;&gt;&gt; for man, mouse in zip(m, n):</span>
<span class="sd">    ...     arr.append((man, mouse))</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    [(1, 0), (0, 1), (1, 0), (1, 0)]</span>
<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;man&#39;, &#39;mouse&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[np.int, np.int]})</span>
<span class="sd">    &gt;&gt;&gt; arr = np.array(arr, dtype=dtype)</span>
<span class="sd">    &gt;&gt;&gt; arr</span>
<span class="sd">    array([(1, 0), (0, 1), (1, 0), (1, 0)],</span>
<span class="sd">          dtype=[(&#39;man&#39;, &#39;&lt;i4&#39;), (&#39;mouse&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask(arr, dtype=dtype)</span>
<span class="sd">    array([(True, False), (False, True), (True, False), (True, False)],</span>
<span class="sd">          dtype=[(&#39;man&#39;, &#39;|b1&#39;), (&#39;mouse&#39;, &#39;|b1&#39;)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">nomask</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
        <span class="c1"># We won&#39;t return after this point to make sure we can shrink the mask</span>
        <span class="c1"># Fill the mask in case there are missing data</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
        <span class="c1"># Make sure the input dtype is valid</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">MaskType</span><span class="p">)</span>
    <span class="c1"># Bas les masques !</span>
    <span class="k">if</span> <span class="n">shrink</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
        <span class="k">return</span> <span class="n">nomask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="make_mask_none"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.make_mask_none.html#numpy.ma.make_mask_none">[docs]</a><span class="k">def</span> <span class="nf">make_mask_none</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a boolean mask of the given shape, filled with False.</span>

<span class="sd">    This function returns a boolean ndarray with all entries False, that can</span>
<span class="sd">    be used in common mask manipulations. If a complex dtype is specified, the</span>
<span class="sd">    type of each field is converted to a boolean type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    newshape : tuple</span>
<span class="sd">        A tuple indicating the shape of the mask.</span>
<span class="sd">    dtype : {None, dtype}, optional</span>
<span class="sd">        If None, use a MaskType instance. Otherwise, use a new datatype with</span>
<span class="sd">        the same fields as `dtype`, converted to boolean types.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : ndarray</span>
<span class="sd">        An ndarray of appropriate shape and dtype, filled with False.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    make_mask : Create a boolean mask from an array.</span>
<span class="sd">    make_mask_descr : Construct a dtype description list from a given dtype.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_none((3,))</span>
<span class="sd">    array([False, False, False], dtype=bool)</span>

<span class="sd">    Defining a more complex dtype.</span>

<span class="sd">    &gt;&gt;&gt; dtype = np.dtype({&#39;names&#39;:[&#39;foo&#39;, &#39;bar&#39;],</span>
<span class="sd">                          &#39;formats&#39;:[np.float32, np.int]})</span>
<span class="sd">    &gt;&gt;&gt; dtype</span>
<span class="sd">    dtype([(&#39;foo&#39;, &#39;&lt;f4&#39;), (&#39;bar&#39;, &#39;&lt;i4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; ma.make_mask_none((3,), dtype=dtype)</span>
<span class="sd">    array([(False, False), (False, False), (False, False)],</span>
<span class="sd">          dtype=[(&#39;foo&#39;, &#39;|b1&#39;), (&#39;bar&#39;, &#39;|b1&#39;)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">MaskType</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">newshape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="mask_or"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.mask_or.html#numpy.ma.mask_or">[docs]</a><span class="k">def</span> <span class="nf">mask_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Combine two masks with the ``logical_or`` operator.</span>

<span class="sd">    The result may be a view on `m1` or `m2` if the other is `nomask`</span>
<span class="sd">    (i.e. False).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m1, m2 : array_like</span>
<span class="sd">        Input masks.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        If copy is False and one of the inputs is `nomask`, return a view</span>
<span class="sd">        of the other input mask. Defaults to False.</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to shrink the output to `nomask` if all its values are</span>
<span class="sd">        False. Defaults to True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mask : output mask</span>
<span class="sd">        The result masks values that are masked in either `m1` or `m2`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `m1` and `m2` have different flexible dtypes.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; m1 = np.ma.make_mask([0, 1, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; m2 = np.ma.make_mask([1, 0, 0, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.mask_or(m1, m2)</span>
<span class="sd">    array([ True,  True,  True, False], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_recursive_mask_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">newmask</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">m1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">current1</span> <span class="o">=</span> <span class="n">m1</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">current1</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">_recursive_mask_or</span><span class="p">(</span><span class="n">current1</span><span class="p">,</span> <span class="n">m2</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">newmask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">current1</span><span class="p">,</span> <span class="n">m2</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">newmask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">m1</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m1</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">MaskType</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m2</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">m2</span> <span class="ow">is</span> <span class="bp">False</span><span class="p">):</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="n">MaskType</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m1</span> <span class="ow">is</span> <span class="n">m2</span> <span class="ow">and</span> <span class="n">is_mask</span><span class="p">(</span><span class="n">m1</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">m1</span>
    <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dtype1</span> <span class="o">!=</span> <span class="n">dtype2</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Incompatible dtypes &#39;</span><span class="si">%s</span><span class="s2">&#39;&lt;&gt;&#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">dtype1</span><span class="p">,</span> <span class="n">dtype2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">dtype1</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>
        <span class="n">_recursive_mask_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">,</span> <span class="n">newmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">newmask</span>
    <span class="k">return</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">flatten_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns a completely flattened version of the mask, where nested fields</span>
<span class="sd">    are collapsed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mask : array_like</span>
<span class="sd">        Input array, which will be interpreted as booleans.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    flattened_mask : ndarray of bools</span>
<span class="sd">        The flattened input.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mask = np.array([0, 0, 1], dtype=np.bool)</span>
<span class="sd">    &gt;&gt;&gt; flatten_mask(mask)</span>
<span class="sd">    array([False, False,  True], dtype=bool)</span>

<span class="sd">    &gt;&gt;&gt; mask = np.array([(0, 0), (0, 1)], dtype=[(&#39;a&#39;, bool), (&#39;b&#39;, bool)])</span>
<span class="sd">    &gt;&gt;&gt; flatten_mask(mask)</span>
<span class="sd">    array([False, False, False,  True], dtype=bool)</span>

<span class="sd">    &gt;&gt;&gt; mdtype = [(&#39;a&#39;, bool), (&#39;b&#39;, [(&#39;ba&#39;, bool), (&#39;bb&#39;, bool)])]</span>
<span class="sd">    &gt;&gt;&gt; mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)</span>
<span class="sd">    &gt;&gt;&gt; flatten_mask(mask)</span>
<span class="sd">    array([False, False, False, False, False,  True], dtype=bool)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_flatmask</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
        <span class="s2">&quot;Flatten the mask and returns a (maybe nested) sequence of booleans.&quot;</span>
        <span class="n">mnames</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="n">mnames</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">flatten_mask</span><span class="p">(</span><span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span> <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">mnames</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">mask</span>

    <span class="k">def</span> <span class="nf">_flatsequence</span><span class="p">(</span><span class="n">sequence</span><span class="p">):</span>
        <span class="s2">&quot;Generates a flattened version of the sequence.&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">sequence</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">_flatsequence</span><span class="p">(</span><span class="n">element</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">element</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">sequence</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">flattened</span> <span class="o">=</span> <span class="n">_flatsequence</span><span class="p">(</span><span class="n">_flatmask</span><span class="p">(</span><span class="n">mask</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">flattened</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_check_mask_axis</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="s2">&quot;Check whether there are masked values along the given axis&quot;</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nomask</span>


<span class="c1">###############################################################################</span>
<span class="c1">#                             Masking functions                               #</span>
<span class="c1">###############################################################################</span>

<div class="viewcode-block" id="masked_where"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_where.html#numpy.ma.masked_where">[docs]</a><span class="k">def</span> <span class="nf">masked_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where a condition is met.</span>

<span class="sd">    Return `a` as an array masked where `condition` is True.</span>
<span class="sd">    Any masked values of `a` or `condition` are also masked in the output.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : array_like</span>
<span class="sd">        Masking condition.  When `condition` tests floating point values for</span>
<span class="sd">        equality, consider using ``masked_values`` instead.</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array to mask.</span>
<span class="sd">    copy : bool</span>
<span class="sd">        If True (default) make a copy of `a` in the result.  If False modify</span>
<span class="sd">        `a` in place and return a view.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The result of masking `a` where `condition` is True.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_values : Mask using floating point equality.</span>
<span class="sd">    masked_equal : Mask where equal to a given value.</span>
<span class="sd">    masked_not_equal : Mask where `not` equal to a given value.</span>
<span class="sd">    masked_less_equal : Mask where less than or equal to a given value.</span>
<span class="sd">    masked_greater_equal : Mask where greater than or equal to a given value.</span>
<span class="sd">    masked_less : Mask where less than a given value.</span>
<span class="sd">    masked_greater : Mask where greater than a given value.</span>
<span class="sd">    masked_inside : Mask inside a given interval.</span>
<span class="sd">    masked_outside : Mask outside a given interval.</span>
<span class="sd">    masked_invalid : Mask invalid values (NaNs or infs).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_where(a &lt;= 2, a)</span>
<span class="sd">    masked_array(data = [-- -- -- 3],</span>
<span class="sd">          mask = [ True  True  True False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    Mask array `b` conditional on `a`.</span>

<span class="sd">    &gt;&gt;&gt; b = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_where(a == 2, b)</span>
<span class="sd">    masked_array(data = [a b -- d],</span>
<span class="sd">          mask = [False False  True False],</span>
<span class="sd">          fill_value=N/A)</span>

<span class="sd">    Effect of the `copy` argument.</span>

<span class="sd">    &gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a)</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    masked_array(data = [-- -- -- 3],</span>
<span class="sd">          mask = [ True  True  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; c[0] = 99</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    masked_array(data = [99 -- -- 3],</span>
<span class="sd">          mask = [False  True  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; c = ma.masked_where(a &lt;= 2, a, copy=False)</span>
<span class="sd">    &gt;&gt;&gt; c[0] = 99</span>
<span class="sd">    &gt;&gt;&gt; c</span>
<span class="sd">    masked_array(data = [99 -- -- 3],</span>
<span class="sd">          mask = [False  True  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([99,  1,  2,  3])</span>

<span class="sd">    When `condition` or `a` contain masked values.</span>

<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_where(a == 2, a)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [0 1 -- 3],</span>
<span class="sd">          mask = [False False  True False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; b = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; b = ma.masked_where(b == 0, b)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data = [-- 1 2 3],</span>
<span class="sd">          mask = [ True False False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_where(a == 3, b)</span>
<span class="sd">    masked_array(data = [-- 1 -- --],</span>
<span class="sd">          mask = [ True False  True  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Make sure that condition is a valid standard-type mask.</span>
    <span class="n">cond</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="p">(</span><span class="n">cshape</span><span class="p">,</span> <span class="n">ashape</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">cond</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">cshape</span> <span class="ow">and</span> <span class="n">cshape</span> <span class="o">!=</span> <span class="n">ashape</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">IndexError</span><span class="p">(</span><span class="s2">&quot;Inconsistant shape between the condition and the input&quot;</span>
                         <span class="s2">&quot; (got </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">cshape</span><span class="p">,</span> <span class="n">ashape</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">):</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="c1"># Assign to *.mask so that structured masks are handled correctly.</span>
    <span class="n">result</span><span class="o">.</span><span class="n">mask</span> <span class="o">=</span> <span class="n">cond</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="masked_greater"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_greater.html#numpy.ma.masked_greater">[docs]</a><span class="k">def</span> <span class="nf">masked_greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where greater than a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &gt; value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_greater(a, 2)</span>
<span class="sd">    masked_array(data = [0 1 2 --],</span>
<span class="sd">          mask = [False False False  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">greater</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_greater_equal"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_greater_equal.html#numpy.ma.masked_greater_equal">[docs]</a><span class="k">def</span> <span class="nf">masked_greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where greater than or equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &gt;= value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_greater_equal(a, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- --],</span>
<span class="sd">          mask = [False False  True  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">greater_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_less"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_less.html#numpy.ma.masked_less">[docs]</a><span class="k">def</span> <span class="nf">masked_less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where less than a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &lt; value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_less(a, 2)</span>
<span class="sd">    masked_array(data = [-- -- 2 3],</span>
<span class="sd">          mask = [ True  True False False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">less</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_less_equal"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_less_equal.html#numpy.ma.masked_less_equal">[docs]</a><span class="k">def</span> <span class="nf">masked_less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where less than or equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x &lt;= value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_less_equal(a, 2)</span>
<span class="sd">    masked_array(data = [-- -- -- 3],</span>
<span class="sd">          mask = [ True  True  True False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">less_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_not_equal"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_not_equal.html#numpy.ma.masked_not_equal">[docs]</a><span class="k">def</span> <span class="nf">masked_not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where `not` equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x != value).</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_not_equal(a, 2)</span>
<span class="sd">    masked_array(data = [-- -- 2 --],</span>
<span class="sd">          mask = [ True  True False  True],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">not_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_equal"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_equal.html#numpy.ma.masked_equal">[docs]</a><span class="k">def</span> <span class="nf">masked_equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where equal to a given value.</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = (x == value).  For floating point arrays,</span>
<span class="sd">    consider using ``masked_values(x, value)``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>
<span class="sd">    masked_values : Mask using floating point equality.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(4)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([0, 1, 2, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_equal(a, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- 3],</span>
<span class="sd">          mask = [False False  True False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span>
    <span class="n">output</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="masked_inside"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_inside.html#numpy.ma.masked_inside">[docs]</a><span class="k">def</span> <span class="nf">masked_inside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array inside a given interval.</span>

<span class="sd">    Shortcut to ``masked_where``, where `condition` is True for `x` inside</span>
<span class="sd">    the interval [v1,v2] (v1 &lt;= x &lt;= v2).  The boundaries `v1` and `v2`</span>
<span class="sd">    can be given in either order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The array `x` is prefilled with its filling value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_inside(x, -0.3, 0.3)</span>
<span class="sd">    masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],</span>
<span class="sd">          mask = [False False  True  True False False],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    The order of `v1` and `v2` doesn&#39;t matter.</span>

<span class="sd">    &gt;&gt;&gt; ma.masked_inside(x, 0.3, -0.3)</span>
<span class="sd">    masked_array(data = [0.31 1.2 -- -- -0.4 -1.1],</span>
<span class="sd">          mask = [False False  True  True False False],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">:</span>
        <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
    <span class="n">xf</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&gt;=</span> <span class="n">v1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&lt;=</span> <span class="n">v2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_outside"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_outside.html#numpy.ma.masked_outside">[docs]</a><span class="k">def</span> <span class="nf">masked_outside</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array outside a given interval.</span>

<span class="sd">    Shortcut to ``masked_where``, where `condition` is True for `x` outside</span>
<span class="sd">    the interval [v1,v2] (x &lt; v1)|(x &gt; v2).</span>
<span class="sd">    The boundaries `v1` and `v2` can be given in either order.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The array `x` is prefilled with its filling value.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_outside(x, -0.3, 0.3)</span>
<span class="sd">    masked_array(data = [-- -- 0.01 0.2 -- --],</span>
<span class="sd">          mask = [ True  True False False  True  True],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    The order of `v1` and `v2` doesn&#39;t matter.</span>

<span class="sd">    &gt;&gt;&gt; ma.masked_outside(x, 0.3, -0.3)</span>
<span class="sd">    masked_array(data = [-- -- 0.01 0.2 -- --],</span>
<span class="sd">          mask = [ True  True False False  True  True],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">v2</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">:</span>
        <span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">v2</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
    <span class="n">xf</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">condition</span> <span class="o">=</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&lt;</span> <span class="n">v1</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">xf</span> <span class="o">&gt;</span> <span class="n">v2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_object"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_object.html#numpy.ma.masked_object">[docs]</a><span class="k">def</span> <span class="nf">masked_object</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask the array `x` where the data are exactly equal to value.</span>

<span class="sd">    This function is similar to `masked_values`, but only suitable</span>
<span class="sd">    for object arrays: for floating point, use `masked_values` instead.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Array to mask</span>
<span class="sd">    value : object</span>
<span class="sd">        Comparison value</span>
<span class="sd">    copy : {True, False}, optional</span>
<span class="sd">        Whether to return a copy of `x`.</span>
<span class="sd">    shrink : {True, False}, optional</span>
<span class="sd">        Whether to collapse a mask full of False to nomask</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The result of masking `x` where equal to `value`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>
<span class="sd">    masked_equal : Mask where equal to a given value (integers).</span>
<span class="sd">    masked_values : Mask using floating point equality.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; food = np.array([&#39;green_eggs&#39;, &#39;ham&#39;], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; # don&#39;t eat spoiled food</span>
<span class="sd">    &gt;&gt;&gt; eat = ma.masked_object(food, &#39;green_eggs&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print eat</span>
<span class="sd">    [-- ham]</span>
<span class="sd">    &gt;&gt;&gt; # plain ol` ham is boring</span>
<span class="sd">    &gt;&gt;&gt; fresh_food = np.array([&#39;cheese&#39;, &#39;ham&#39;, &#39;pineapple&#39;], dtype=object)</span>
<span class="sd">    &gt;&gt;&gt; eat = ma.masked_object(fresh_food, &#39;green_eggs&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print eat</span>
<span class="sd">    [cheese ham pineapple]</span>

<span class="sd">    Note that `mask` is set to ``nomask`` if possible.</span>

<span class="sd">    &gt;&gt;&gt; eat</span>
<span class="sd">    masked_array(data = [cheese ham pineapple],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=?)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">isMaskedArray</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">_mask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">nomask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_values"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_values.html#numpy.ma.masked_values">[docs]</a><span class="k">def</span> <span class="nf">masked_values</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask using floating point equality.</span>

<span class="sd">    Return a MaskedArray, masked where the data in array `x` are approximately</span>
<span class="sd">    equal to `value`, i.e. where the following condition is True</span>

<span class="sd">    (abs(x - value) &lt;= atol+rtol*abs(value))</span>

<span class="sd">    The fill_value is set to `value` and the mask is set to ``nomask`` if</span>
<span class="sd">    possible.  For integers, consider using ``masked_equal``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Array to mask.</span>
<span class="sd">    value : float</span>
<span class="sd">        Masking value.</span>
<span class="sd">    rtol : float, optional</span>
<span class="sd">        Tolerance parameter.</span>
<span class="sd">    atol : float, optional</span>
<span class="sd">        Tolerance parameter (1e-8).</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to return a copy of `x`.</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to collapse a mask full of False to ``nomask``.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The result of masking `x` where approximately equal to `value`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>
<span class="sd">    masked_equal : Mask where equal to a given value (integers).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = np.array([1, 1.1, 2, 1.1, 3])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_values(x, 1.1)</span>
<span class="sd">    masked_array(data = [1.0 -- 2.0 -- 3.0],</span>
<span class="sd">          mask = [False  True False  True False],</span>
<span class="sd">          fill_value=1.1)</span>

<span class="sd">    Note that `mask` is set to ``nomask`` if possible.</span>

<span class="sd">    &gt;&gt;&gt; ma.masked_values(x, 1.5)</span>
<span class="sd">    masked_array(data = [ 1.   1.1  2.   1.1  3. ],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=1.5)</span>

<span class="sd">    For integers, the fill value will be different in general to the</span>
<span class="sd">    result of ``masked_equal``.</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(5)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([0, 1, 2, 3, 4])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_values(x, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- 3 4],</span>
<span class="sd">          mask = [False False  True False False],</span>
<span class="sd">          fill_value=2)</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_equal(x, 2)</span>
<span class="sd">    masked_array(data = [0 1 -- 3 4],</span>
<span class="sd">          mask = [False False  True False False],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mabs</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span>
    <span class="n">xnew</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">xnew</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span>
            <span class="n">mabs</span><span class="p">(</span><span class="n">xnew</span> <span class="o">-</span> <span class="n">value</span><span class="p">),</span> <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">mabs</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">nomask</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">),</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="masked_invalid"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.masked_invalid.html#numpy.ma.masked_invalid">[docs]</a><span class="k">def</span> <span class="nf">masked_invalid</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask an array where invalid values occur (NaNs or infs).</span>

<span class="sd">    This function is a shortcut to ``masked_where``, with</span>
<span class="sd">    `condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.</span>
<span class="sd">    Only applies to arrays with a dtype where NaNs or infs make sense</span>
<span class="sd">    (i.e. floating point types), but accepts any array_like object.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.arange(5, dtype=np.float)</span>
<span class="sd">    &gt;&gt;&gt; a[2] = np.NaN</span>
<span class="sd">    &gt;&gt;&gt; a[3] = np.PINF</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([  0.,   1.,  NaN,  Inf,   4.])</span>
<span class="sd">    &gt;&gt;&gt; ma.masked_invalid(a)</span>
<span class="sd">    masked_array(data = [0.0 1.0 -- -- 4.0],</span>
<span class="sd">          mask = [False False  True  True False],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">condition</span> <span class="o">|=</span> <span class="n">mask</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">condition</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="c1">###############################################################################</span>
<span class="c1">#                            Printing options                                 #</span>
<span class="c1">###############################################################################</span>


<span class="k">class</span> <span class="nc">_MaskedPrintOption</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handle the string used to represent missing data in a masked array.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the masked_print_option object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">=</span> <span class="n">display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enabled</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">def</span> <span class="nf">display</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display the string to print for masked values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_display</span>

    <span class="k">def</span> <span class="nf">set_display</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the string to print for masked values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_display</span> <span class="o">=</span> <span class="n">s</span>

    <span class="k">def</span> <span class="nf">enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is the use of the display value enabled?</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_enabled</span>

    <span class="k">def</span> <span class="nf">enable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the enabling shrink to `shrink`.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_enabled</span> <span class="o">=</span> <span class="n">shrink</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_display</span><span class="p">)</span>

    <span class="n">__repr__</span> <span class="o">=</span> <span class="n">__str__</span>

<span class="c1"># if you single index into a masked location you get this object.</span>
<span class="n">masked_print_option</span> <span class="o">=</span> <span class="n">_MaskedPrintOption</span><span class="p">(</span><span class="s1">&#39;--&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_recursive_printoption</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">printopt</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Puts printoptions in result where mask is True.</span>

<span class="sd">    Private function allowing for recursion</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="p">(</span><span class="n">curdata</span><span class="p">,</span> <span class="n">curmask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">curdata</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">_recursive_printoption</span><span class="p">(</span><span class="n">curdata</span><span class="p">,</span> <span class="n">curmask</span><span class="p">,</span> <span class="n">printopt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">curdata</span><span class="p">,</span> <span class="n">printopt</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">curmask</span><span class="p">)</span>
    <span class="k">return</span>

<span class="n">_print_templates</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">long_std</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">masked_</span><span class="si">%(name)s</span><span class="s2">(data =</span>
<span class="s2"> </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="s2">       </span><span class="si">%(nlen)s</span><span class="s2"> mask =</span>
<span class="s2"> </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="s2"> </span><span class="si">%(nlen)s</span><span class="s2"> fill_value = </span><span class="si">%(fill)s</span><span class="s2">)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
                        <span class="n">short_std</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">masked_</span><span class="si">%(name)s</span><span class="s2">(data = </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="s2">       </span><span class="si">%(nlen)s</span><span class="s2"> mask = </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="si">%(nlen)s</span><span class="s2">  fill_value = </span><span class="si">%(fill)s</span><span class="s2">)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
                        <span class="n">long_flx</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">masked_</span><span class="si">%(name)s</span><span class="s2">(data =</span>
<span class="s2"> </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="s2">       </span><span class="si">%(nlen)s</span><span class="s2"> mask =</span>
<span class="s2"> </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="si">%(nlen)s</span><span class="s2">  fill_value = </span><span class="si">%(fill)s</span><span class="s2">,</span>
<span class="s2">      </span><span class="si">%(nlen)s</span><span class="s2"> dtype = </span><span class="si">%(dtype)s</span><span class="s2">)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
                        <span class="n">short_flx</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;</span><span class="se">\</span>
<span class="s2">masked_</span><span class="si">%(name)s</span><span class="s2">(data = </span><span class="si">%(data)s</span><span class="s2">,</span>
<span class="si">%(nlen)s</span><span class="s2">        mask = </span><span class="si">%(mask)s</span><span class="s2">,</span>
<span class="si">%(nlen)s</span><span class="s2">  fill_value = </span><span class="si">%(fill)s</span><span class="s2">,</span>
<span class="si">%(nlen)s</span><span class="s2">       dtype = </span><span class="si">%(dtype)s</span><span class="s2">)</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1">###############################################################################</span>
<span class="c1">#                          MaskedArray class                                  #</span>
<span class="c1">###############################################################################</span>


<span class="k">def</span> <span class="nf">_recursive_filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively fill `a` with `fill_value`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">current</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">_recursive_filled</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">fill_value</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">flatten_structured_array</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flatten a structured array.</span>

<span class="sd">    The data type of the output is chosen such that it can represent all of the</span>
<span class="sd">    (nested) fields.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : structured array</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : masked array or ndarray</span>
<span class="sd">        A flattened masked array if the input is a masked array, otherwise a</span>
<span class="sd">        standard ndarray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; ndtype = [(&#39;a&#39;, int), (&#39;b&#39;, float)]</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([(1, 1), (2, 2)], dtype=ndtype)</span>
<span class="sd">    &gt;&gt;&gt; flatten_structured_array(a)</span>
<span class="sd">    array([[1., 1.],</span>
<span class="sd">           [2., 2.]])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">flatten_sequence</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Flattens a compound of nested iterables.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">elm</span> <span class="ow">in</span> <span class="nb">iter</span><span class="p">(</span><span class="n">iterable</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">elm</span><span class="p">,</span> <span class="s1">&#39;__iter__&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">flatten_sequence</span><span class="p">(</span><span class="n">elm</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">f</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">elm</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">inishape</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span>
                              <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">()))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">a</span><span class="p">])</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">inishape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">newshape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">newshape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inishape</span>
        <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">flatten_sequence</span><span class="p">(</span><span class="n">newshape</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">class</span> <span class="nc">_arraymethod</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define a wrapper for basic array methods.</span>

<span class="sd">    Upon call, returns a masked array, where the new ``_data`` array is</span>
<span class="sd">    the output of the corresponding method called on the original</span>
<span class="sd">    ``_data``.</span>

<span class="sd">    If `onmask` is True, the new mask is the output of the method called</span>
<span class="sd">    on the initial mask. Otherwise, the new mask is just a reference</span>
<span class="sd">    to the initial mask.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    _onmask : bool</span>
<span class="sd">        Holds the `onmask` parameter.</span>
<span class="sd">    obj : object</span>
<span class="sd">        The object calling `_arraymethod`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    funcname : str</span>
<span class="sd">        Name of the function to apply on data.</span>
<span class="sd">    onmask : bool</span>
<span class="sd">        Whether the mask must be processed also (True) or left</span>
<span class="sd">        alone (False). Default is True. Make available as `_onmask`</span>
<span class="sd">        attribute.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">onmask</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">funcname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_onmask</span> <span class="o">=</span> <span class="n">onmask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getdoc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">getdoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the doc of the function (from the doc of the method).&quot;</span>
        <span class="n">methdoc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span> \
            <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">methdoc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">methdoc</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">__get__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">objtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="n">methodname</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span>
        <span class="c1"># Fallback : if the instance has not been initialized, use the first</span>
        <span class="c1"># arg</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">instance</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">methodname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_onmask</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">methodname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">all</span><span class="p">()):</span>
                <span class="k">return</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">MaskedIterator</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Flat iterator object to iterate over masked arrays.</span>

<span class="sd">    A `MaskedIterator` iterator is returned by ``x.flat`` for any masked array</span>
<span class="sd">    `x`. It allows iterating over the array as if it were a 1-D array,</span>
<span class="sd">    either in a for-loop or by calling its `next` method.</span>

<span class="sd">    Iteration is done in C-contiguous style, with the last index varying the</span>
<span class="sd">    fastest. The iterator can also be indexed using basic slicing or</span>
<span class="sd">    advanced indexing.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.flat : Return a flat iterator over an array.</span>
<span class="sd">    MaskedArray.flatten : Returns a flattened copy of an array.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    `MaskedIterator` is not exported by the `ma` module. Instead of</span>
<span class="sd">    instantiating a `MaskedIterator` directly, use `MaskedArray.flat`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(arange(6).reshape(2, 3))</span>
<span class="sd">    &gt;&gt;&gt; fl = x.flat</span>
<span class="sd">    &gt;&gt;&gt; type(fl)</span>
<span class="sd">    &lt;class &#39;numpy.ma.core.MaskedIterator&#39;&gt;</span>
<span class="sd">    &gt;&gt;&gt; for item in fl:</span>
<span class="sd">    ...     print item</span>
<span class="sd">    ...</span>
<span class="sd">    0</span>
<span class="sd">    1</span>
<span class="sd">    2</span>
<span class="sd">    3</span>
<span class="sd">    4</span>
<span class="sd">    5</span>

<span class="sd">    Extracting more than a single element b indexing the `MaskedIterator`</span>
<span class="sd">    returns a masked array:</span>

<span class="sd">    &gt;&gt;&gt; fl[2:4]</span>
<span class="sd">    masked_array(data = [2 3],</span>
<span class="sd">                 mask = False,</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ma</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ma</span> <span class="o">=</span> <span class="n">ma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">flat</span>

        <span class="k">if</span> <span class="n">ma</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">flat</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="n">indx</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                <span class="c1"># set shape to match that of data; this is needed for matrices</span>
                <span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">mvoid</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">_mask</span><span class="p">:</span>  <span class="c1"># Just a scalar, masked</span>
                <span class="k">return</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="c1"># This won&#39;t work if ravel makes a copy</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the next value, or raise StopIteration.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([3, 2], mask=[0, 1])</span>
<span class="sd">        &gt;&gt;&gt; fl = x.flat</span>
<span class="sd">        &gt;&gt;&gt; fl.next()</span>
<span class="sd">        3</span>
<span class="sd">        &gt;&gt;&gt; fl.next()</span>
<span class="sd">        masked_array(data = --,</span>
<span class="sd">                     mask = True,</span>
<span class="sd">               fill_value = 1e+20)</span>
<span class="sd">        &gt;&gt;&gt; fl.next()</span>
<span class="sd">        Traceback (most recent call last):</span>
<span class="sd">          File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span>
<span class="sd">          File &quot;/home/ralf/python/numpy/numpy/ma/core.py&quot;, line 2243, in next</span>
<span class="sd">            d = self.dataiter.next()</span>
<span class="sd">        StopIteration</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dataiter</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maskiter</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">mvoid</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">m</span><span class="p">:</span>  <span class="c1"># Just a scalar, masked</span>
                <span class="k">return</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nb">next</span> <span class="o">=</span> <span class="n">__next__</span>


<div class="viewcode-block" id="MaskedArray"><a class="viewcode-back" href="../../../reference/maskedarray.baseclass.html#numpy.ma.MaskedArray">[docs]</a><span class="k">class</span> <span class="nc">MaskedArray</span><span class="p">(</span><span class="n">ndarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An array class with possibly masked values.</span>

<span class="sd">    Masked values of True exclude the corresponding element from any</span>
<span class="sd">    computation.</span>

<span class="sd">    Construction::</span>

<span class="sd">      x = MaskedArray(data, mask=nomask, dtype=None,</span>
<span class="sd">                      copy=False, subok=True, ndmin=0, fill_value=None,</span>
<span class="sd">                      keep_mask=True, hard_mask=None, shrink=True)</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    mask : sequence, optional</span>
<span class="sd">        Mask. Must be convertible to an array of booleans with the same</span>
<span class="sd">        shape as `data`. True indicates a masked (i.e. invalid) data.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type of the output.</span>
<span class="sd">        If `dtype` is None, the type of the data argument (``data.dtype``)</span>
<span class="sd">        is used. If `dtype` is not None and different from ``data.dtype``,</span>
<span class="sd">        a copy is performed.</span>
<span class="sd">    copy : bool, optional</span>
<span class="sd">        Whether to copy the input data (True), or to use a reference instead.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    subok : bool, optional</span>
<span class="sd">        Whether to return a subclass of `MaskedArray` if possible (True) or a</span>
<span class="sd">        plain `MaskedArray`. Default is True.</span>
<span class="sd">    ndmin : int, optional</span>
<span class="sd">        Minimum number of dimensions. Default is 0.</span>
<span class="sd">    fill_value : scalar, optional</span>
<span class="sd">        Value used to fill in the masked values when necessary.</span>
<span class="sd">        If None, a default based on the data-type is used.</span>
<span class="sd">    keep_mask : bool, optional</span>
<span class="sd">        Whether to combine `mask` with the mask of the input data, if any</span>
<span class="sd">        (True), or to use only `mask` for the output (False). Default is True.</span>
<span class="sd">    hard_mask : bool, optional</span>
<span class="sd">        Whether to use a hard mask or not. With a hard mask, masked values</span>
<span class="sd">        cannot be unmasked. Default is False.</span>
<span class="sd">    shrink : bool, optional</span>
<span class="sd">        Whether to force compression of an empty mask. Default is True.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">_defaultmask</span> <span class="o">=</span> <span class="n">nomask</span>
    <span class="n">_defaulthardmask</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">_baseclass</span> <span class="o">=</span> <span class="n">ndarray</span>

<div class="viewcode-block" id="MaskedArray.__new__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__new__.html#numpy.ma.MaskedArray.__new__">[docs]</a>    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="n">cls</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">keep_mask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">hard_mask</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                <span class="o">**</span><span class="n">options</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new masked array from scratch.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        A masked array can also be created by taking a .view(MaskedArray).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process data.</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">)</span>
        <span class="n">_baseclass</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_baseclass&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">_data</span><span class="p">))</span>
        <span class="c1"># Check that we&#39;re not erasing the mask.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># Careful, cls might not always be MaskedArray.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">subok</span><span class="p">:</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="c1"># Backwards compatibility w/ numpy.core.ma.</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">_mask</span>
            <span class="c1"># FIXME _sharedmask is never used.</span>
            <span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="c1"># Process mask.</span>
        <span class="c1"># Number of named fields (or zero if none)</span>
        <span class="n">names_</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="p">()</span>
        <span class="c1"># Type of the mask</span>
        <span class="k">if</span> <span class="n">names_</span><span class="p">:</span>
            <span class="n">mdtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">mdtype</span> <span class="o">=</span> <span class="n">MaskType</span>

        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Case 1. : no mask in input.</span>
            <span class="c1"># Erase the current mask ?</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_mask</span><span class="p">:</span>
                <span class="c1"># With a reduced version</span>
                <span class="k">if</span> <span class="n">shrink</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
                <span class="c1"># With full version</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Check whether we missed something</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># If data is a sequence of masked array</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">data</span><span class="p">],</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># If data is nested</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">nomask</span>
                <span class="c1"># Force shrinking of the mask if needed (and possible)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">mdtype</span> <span class="o">==</span> <span class="n">MaskType</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">False</span>
                    <span class="c1"># Reset the shape of the original mask</span>
                    <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                        <span class="n">data</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Case 2. : With a mask in input.</span>
            <span class="c1"># Read the mask with the current mdtype</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Or assume it&#39;s a sequence of bool/int</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">],</span>
                                <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Make sure the mask and the data have the same shape</span>
            <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">nm</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">nm</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">nm</span> <span class="o">==</span> <span class="n">nd</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;Mask and data not compatible: data size is </span><span class="si">%i</span><span class="s2">, &quot;</span> <span class="o">+</span> \
                          <span class="s2">&quot;mask size is </span><span class="si">%i</span><span class="s2">.&quot;</span>
                    <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">msg</span> <span class="o">%</span> <span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">nm</span><span class="p">))</span>
                <span class="n">copy</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># Set the mask to the new value</span>
            <span class="k">if</span> <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
                <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">copy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_mask</span><span class="p">:</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">copy</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">names_</span><span class="p">:</span>
                        <span class="k">def</span> <span class="nf">_recursive_or</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
                            <span class="s2">&quot;do a|=b on each field of a, recursively&quot;</span>
                            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                                <span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">bf</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="n">name</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="n">name</span><span class="p">])</span>
                                <span class="k">if</span> <span class="n">af</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                                    <span class="n">_recursive_or</span><span class="p">(</span><span class="n">af</span><span class="p">,</span> <span class="n">bf</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">af</span> <span class="o">|=</span> <span class="n">bf</span>
                            <span class="k">return</span>
                        <span class="n">_recursive_or</span><span class="p">(</span><span class="n">_data</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="c1"># Update fill_value.</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_fill_value&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="c1"># But don&#39;t run the check unless we have something to check.</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Process extra options ..</span>
        <span class="k">if</span> <span class="n">hard_mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;_hardmask&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="n">hard_mask</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">_baseclass</span> <span class="o">=</span> <span class="n">_baseclass</span>
        <span class="k">return</span> <span class="n">_data</span></div>


    <span class="k">def</span> <span class="nf">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copies some attributes of obj to self.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="n">_baseclass</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_baseclass</span> <span class="o">=</span> <span class="n">ndarray</span>
        <span class="c1"># We need to copy the _basedict to avoid backward propagation</span>
        <span class="n">_optinfo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">_optinfo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_optinfo&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">_optinfo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_basedict&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">_optinfo</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;__dict__&#39;</span><span class="p">,</span> <span class="p">{}))</span>
        <span class="n">_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">_fill_value</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_fill_value&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">),</span>
                     <span class="n">_hardmask</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_hardmask&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                     <span class="n">_sharedmask</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_sharedmask&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                     <span class="n">_isfield</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_isfield&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">),</span>
                     <span class="n">_baseclass</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_baseclass&#39;</span><span class="p">,</span> <span class="n">_baseclass</span><span class="p">),</span>
                     <span class="n">_optinfo</span><span class="o">=</span><span class="n">_optinfo</span><span class="p">,</span>
                     <span class="n">_basedict</span><span class="o">=</span><span class="n">_optinfo</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_dict</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_optinfo</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finalizes the masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get main attributes.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="c1"># We have to decide how to initialize self.mask, based on</span>
        <span class="c1"># obj.mask. This is very difficult.  There might be some</span>
        <span class="c1"># correspondence between the elements in the array we are being</span>
        <span class="c1"># created from (= obj) and us. Or there might not. This method can</span>
        <span class="c1"># be called in all kinds of places for all kinds of reasons -- could</span>
        <span class="c1"># be empty_like, could be slicing, could be a ufunc, could be a view.</span>
        <span class="c1"># The numpy subclassing interface simply doesn&#39;t give us any way</span>
        <span class="c1"># to know, which means that at best this method will be based on</span>
        <span class="c1"># guesswork and heuristics. To make things worse, there isn&#39;t even any</span>
        <span class="c1"># clear consensus about what the desired behavior is. For instance,</span>
        <span class="c1"># most users think that np.empty_like(marr) -- which goes via this</span>
        <span class="c1"># method -- should return a masked array with an empty mask (see</span>
        <span class="c1"># gh-3404 and linked discussions), but others disagree, and they have</span>
        <span class="c1"># existing code which depends on empty_like returning an array that</span>
        <span class="c1"># matches the input mask.</span>
        <span class="c1">#</span>
        <span class="c1"># Historically our algorithm was: if the template object mask had the</span>
        <span class="c1"># same *number of elements* as us, then we used *it&#39;s mask object</span>
        <span class="c1"># itself* as our mask, so that writes to us would also write to the</span>
        <span class="c1"># original array. This is horribly broken in multiple ways.</span>
        <span class="c1">#</span>
        <span class="c1"># Now what we do instead is, if the template object mask has the same</span>
        <span class="c1"># number of elements as us, and we do not have the same base pointer</span>
        <span class="c1"># as the template object (b/c views like arr[...] should keep the same</span>
        <span class="c1"># mask), then we make a copy of the template object mask and use</span>
        <span class="c1"># that. This is also horribly broken but somewhat less so. Maybe.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
            <span class="c1"># XX: This looks like a bug -- shouldn&#39;t it check self.dtype</span>
            <span class="c1"># instead?</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span>
                                <span class="n">make_mask_none</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>

            <span class="c1"># If self and obj point to exactly the same data, then probably</span>
            <span class="c1"># self is a simple view of obj (e.g., self = obj[...]), so they</span>
            <span class="c1"># should share the same mask. (This isn&#39;t 100% reliable, e.g. self</span>
            <span class="c1"># could be the first row of obj, or have strange strides, but as a</span>
            <span class="c1"># heuristic it&#39;s not bad.) In all other cases, we make a copy of</span>
            <span class="c1"># the mask, so that future modifications to &#39;self&#39; do not end up</span>
            <span class="c1"># side-effecting &#39;obj&#39; as well.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_interface__</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">][</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span>
        <span class="c1"># Finalize the mask</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="c1"># When _mask.shape is not writable (because it&#39;s a void)</span>
                <span class="k">pass</span>
        <span class="c1"># Finalize the fill_value for structured arrays</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span>

<div class="viewcode-block" id="MaskedArray.__array_wrap__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__array_wrap__.html#numpy.ma.MaskedArray.__array_wrap__">[docs]</a>    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">context</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Special hook for ufuncs.</span>

<span class="sd">        Wraps the numpy array and sets the mask according to context.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">context</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">context</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">reduce</span><span class="p">(</span><span class="n">mask_or</span><span class="p">,</span> <span class="p">[</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span><span class="p">])</span>
            <span class="c1"># Get the domain mask</span>
            <span class="n">domain</span> <span class="o">=</span> <span class="n">ufunc_domain</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">domain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># Take the domain, and make sure it&#39;s a ndarray</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="nb">reduce</span><span class="p">(</span><span class="n">domain</span><span class="p">,</span> <span class="n">args</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">domain</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">),</span> <span class="bp">True</span><span class="p">)</span>
                <span class="c1"># Fill the result where the domain is wrong</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Binary domain: take the last value</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">func</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># Unary domain: just use this one</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">func</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="c1"># Domain not recognized, use fill_value instead</span>
                    <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">d</span><span class="p">)</span>
                <span class="c1"># Update the mask</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">d</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">d</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t modify inplace, we risk back-propagation</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span> <span class="o">|</span> <span class="n">d</span><span class="p">)</span>
            <span class="c1"># Make sure the mask has the proper size</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="n">m</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
                <span class="n">result</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MaskedArray.view"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.view.html#numpy.ma.MaskedArray.view">[docs]</a>    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a view of the MaskedArray data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : data-type or ndarray sub-class, optional</span>
<span class="sd">            Data-type descriptor of the returned view, e.g., float32 or int16.</span>
<span class="sd">            The default, None, results in the view having the same data-type</span>
<span class="sd">            as `a`. As with ``ndarray.view``, dtype can also be specified as</span>
<span class="sd">            an ndarray sub-class, which then specifies the type of the</span>
<span class="sd">            returned object (this is equivalent to setting the ``type``</span>
<span class="sd">            parameter).</span>
<span class="sd">        type : Python type, optional</span>
<span class="sd">            Type of the returned view, e.g., ndarray or matrix.  Again, the</span>
<span class="sd">            default None results in type preservation.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        ``a.view()`` is used two different ways:</span>

<span class="sd">        ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view</span>
<span class="sd">        of the array&#39;s memory with a different data-type.  This can cause a</span>
<span class="sd">        reinterpretation of the bytes of memory.</span>

<span class="sd">        ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just</span>
<span class="sd">        returns an instance of `ndarray_subclass` that looks at the same array</span>
<span class="sd">        (same shape, dtype, etc.)  This does not cause a reinterpretation of the</span>
<span class="sd">        memory.</span>

<span class="sd">        If `fill_value` is not specified, but `dtype` is specified (and is not</span>
<span class="sd">        an ndarray sub-class), the `fill_value` of the MaskedArray will be</span>
<span class="sd">        reset. If neither `fill_value` nor `dtype` are specified (or if</span>
<span class="sd">        `dtype` is an ndarray sub-class), then the fill value is preserved.</span>
<span class="sd">        Finally, if `fill_value` is specified, but `dtype` is not, the fill</span>
<span class="sd">        value is set to the specified value.</span>

<span class="sd">        For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of</span>
<span class="sd">        bytes per entry than the previous dtype (for example, converting a</span>
<span class="sd">        regular array to a structured array), then the behavior of the view</span>
<span class="sd">        cannot be predicted just from the superficial appearance of ``a`` (shown</span>
<span class="sd">        by ``print(a)``). It also depends on exactly how ``a`` is stored in</span>
<span class="sd">        memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus</span>
<span class="sd">        defined as a slice or transpose, etc., the view may give different</span>
<span class="sd">        results.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">):</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
                    <span class="n">dtype</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

        <span class="c1"># also make the mask be a view (so attr changes to the view&#39;s</span>
        <span class="c1"># mask do no affect original object&#39;s mask)</span>
        <span class="c1"># (especially important to avoid affecting np.masked singleton)</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">):</span>
            <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>

        <span class="c1"># Make sure to reset the _fill_value if needed</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="s1">&#39;_fill_value&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># leave _fill_value as is</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">return</span> <span class="n">output</span></div>
    <span class="n">view</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="MaskedArray.astype"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.astype.html#numpy.ma.MaskedArray.astype">[docs]</a>    <span class="k">def</span> <span class="nf">astype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of the MaskedArray cast to given newtype.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : MaskedArray</span>
<span class="sd">            A copy of self cast to input newtype.</span>
<span class="sd">            The returned record shape matches self.shape.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3.1],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[1.0 -- 3.1]</span>
<span class="sd">         [-- 5.0 --]</span>
<span class="sd">         [7.0 -- 9.0]]</span>
<span class="sd">        &gt;&gt;&gt; print x.astype(int32)</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">newtype</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">newtype</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">output</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">astype</span><span class="p">([(</span><span class="n">n</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>
        <span class="c1"># Don&#39;t check _fill_value if it&#39;s None, that&#39;ll speed things up</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">output</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">,</span> <span class="n">newtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="MaskedArray.__getitem__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__getitem__.html#numpy.ma.MaskedArray.__getitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        x.__getitem__(y) &lt;==&gt; x[y]</span>

<span class="sd">        Return the item described by i, as a masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dout</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
        <span class="c1"># We could directly use ndarray.__getitem__ on self.</span>
        <span class="c1"># But then we would have to modify __array_finalize__ to prevent the</span>
        <span class="c1"># mask of being reshaped if it hasn&#39;t been set up properly yet</span>
        <span class="c1"># So it&#39;s easier to stick to the current version</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="c1"># Did we extract a single item?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="c1"># A record</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
                <span class="c1"># We should always re-cast to mvoid, otherwise users can</span>
                <span class="c1"># change masks on rows that already have masked values, but not</span>
                <span class="c1"># on rows that have no masked values, which is inconsistent.</span>
                <span class="n">dout</span> <span class="o">=</span> <span class="n">mvoid</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">)</span>
            <span class="c1"># Just a scalar</span>
            <span class="k">elif</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">masked</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">object_</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dout</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="c1"># self contains an object array of arrays (yes, that happens).</span>
            <span class="c1"># If masked, turn into a MaskedArray, with everything masked.</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">dout</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Force dout to MA</span>
            <span class="n">dout</span> <span class="o">=</span> <span class="n">dout</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="c1"># Inherit attributes from self</span>
            <span class="n">dout</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="c1"># Check the fill_value</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">dout</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
                <span class="n">dout</span><span class="o">.</span><span class="n">_isfield</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="c1"># Update the mask if needed</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">dout</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
                <span class="c1"># set shape to match that of data; this is needed for matrices</span>
                <span class="n">dout</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">dout</span><span class="o">.</span><span class="n">shape</span>
                <span class="n">dout</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="c1"># Note: Don&#39;t try to check for m.any(), that&#39;ll take too long</span>
        <span class="k">return</span> <span class="n">dout</span></div>

<div class="viewcode-block" id="MaskedArray.__setitem__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__setitem__.html#numpy.ma.MaskedArray.__setitem__">[docs]</a>    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        x.__setitem__(i, y) &lt;==&gt; x[i]=y</span>

<span class="sd">        Set item described by index. If value is masked, masks those</span>
<span class="sd">        locations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="s1">&#39;Cannot alter the masked element.&#39;</span><span class="p">)</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">_dtype</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">nbfields</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">or</span> <span class="p">())</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="c1"># The mask wasn&#39;t set: create a full version.</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">)</span>
            <span class="c1"># Now, set the mask to its value.</span>
            <span class="k">if</span> <span class="n">nbfields</span><span class="p">:</span>
                <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">True</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbfields</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isfield</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span>

        <span class="c1"># Get the _data part of the new value</span>
        <span class="n">dval</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1"># Get the _mask part of the new value</span>
        <span class="n">mval</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">nbfields</span> <span class="ow">and</span> <span class="n">mval</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">mval</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbfields</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="c1"># Set the data, then the mask</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dval</span>
            <span class="k">if</span> <span class="n">mval</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">_dtype</span><span class="p">)</span>
                <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mval</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
            <span class="c1"># Unshare the mask if necessary to avoid propagation</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_isfield</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unshare_mask</span><span class="p">()</span>
                <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="c1"># Set the data, then the mask</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dval</span>
            <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mval</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">indx</span><span class="p">,</span> <span class="s1">&#39;dtype&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">indx</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">MaskType</span><span class="p">):</span>
            <span class="n">indx</span> <span class="o">=</span> <span class="n">indx</span> <span class="o">*</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">_mask</span><span class="p">)</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dval</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nbfields</span><span class="p">:</span>
                <span class="n">err_msg</span> <span class="o">=</span> <span class="s2">&quot;Flexible &#39;hard&#39; masks are not yet supported.&quot;</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="n">err_msg</span><span class="p">)</span>
            <span class="n">mindx</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">],</span> <span class="n">mval</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">dindx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">dindx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">dindx</span><span class="p">,</span> <span class="n">dval</span><span class="p">,</span> <span class="n">where</span><span class="o">=~</span><span class="n">mindx</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mindx</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">dindx</span> <span class="o">=</span> <span class="n">dval</span>
            <span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">dindx</span>
            <span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">mindx</span>
        <span class="k">return</span></div>

    <span class="k">def</span> <span class="nf">__setattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setattr__</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;dtype&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">make_mask_descr</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">ndarray</span><span class="p">)</span>
            <span class="c1"># Try to reset the shape of the mask (if we don&#39;t have a void)</span>
            <span class="c1"># This raises a ValueError if the dtype change won&#39;t work</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
                <span class="k">pass</span>

<div class="viewcode-block" id="MaskedArray.__getslice__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__getslice__.html#numpy.ma.MaskedArray.__getslice__">[docs]</a>    <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        x.__getslice__(i, j) &lt;==&gt; x[i:j]</span>

<span class="sd">        Return the slice described by (i, j).  The use of negative indices</span>
<span class="sd">        is not supported.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span></div>

<div class="viewcode-block" id="MaskedArray.__setslice__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__setslice__.html#numpy.ma.MaskedArray.__setslice__">[docs]</a>    <span class="k">def</span> <span class="nf">__setslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        x.__setslice__(i, j, value) &lt;==&gt; x[i:j]=value</span>

<span class="sd">        Set the slice (i,j) of a to value. If value is masked, mask those</span>
<span class="sd">        locations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__setitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__setmask__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__setmask__.html#numpy.ma.MaskedArray.__setmask__">[docs]</a>    <span class="k">def</span> <span class="nf">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">idtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="n">current_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">True</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">current_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
            <span class="c1"># Make sure the mask is set</span>
            <span class="c1"># Just don&#39;t do anything if there&#39;s nothing to do.</span>
            <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="n">current_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">idtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">idtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># No named fields.</span>
            <span class="c1"># Hardmask: don&#39;t unmask the data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
                <span class="n">current_mask</span> <span class="o">|=</span> <span class="n">mask</span>
            <span class="c1"># Softmask: set everything to False</span>
            <span class="c1"># If it&#39;s obviously a compatible scalar, use a quick update</span>
            <span class="c1"># method.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)):</span>
                <span class="n">current_mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="c1"># Otherwise fall back to the slower, general purpose way.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_mask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Named fields w/</span>
            <span class="n">mdtype</span> <span class="o">=</span> <span class="n">current_mask</span><span class="o">.</span><span class="n">dtype</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="c1"># Mask is a singleton</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">mask</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># It&#39;s a boolean : make a record</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">mask</span><span class="o">.</span><span class="n">item</span><span class="p">()]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdtype</span><span class="p">)),</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
                <span class="c1"># It&#39;s a record: make sure the dtype is correct</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Mask is a sequence</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Make sure the new mask is a ndarray with the proper dtype</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
                <span class="c1"># Or assume it&#39;s a sequence of bool/int</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">tuple</span><span class="p">([</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">mdtype</span><span class="p">))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">],</span>
                                    <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
            <span class="c1"># Hardmask: don&#39;t unmask the data</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">idtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">current_mask</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="c1"># Softmask: set everything to False</span>
            <span class="c1"># If it&#39;s obviously a compatible scalar, use a quick update</span>
            <span class="c1"># method.</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">number</span><span class="p">)):</span>
                <span class="n">current_mask</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="c1"># Otherwise fall back to the slower, general purpose way.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">current_mask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="c1"># Reshape if needed</span>
        <span class="k">if</span> <span class="n">current_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">current_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">return</span></div>

    <span class="n">_set_mask</span> <span class="o">=</span> <span class="n">__setmask__</span>

    <span class="k">def</span> <span class="nf">_get_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We could try to force a reshape, but that wouldn&#39;t work in some</span>
        <span class="c1"># cases.</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_mask</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">__setmask__</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Mask&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_recordmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mask of the records.</span>

<span class="sd">        A record is masked when all the fields are masked.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_mask</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">flatten_structured_array</span><span class="p">(</span><span class="n">_mask</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_recordmask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the mask of the records.</span>

<span class="sd">        A record is masked when all the fields are masked.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;Coming soon: setting the mask per records!&quot;</span><span class="p">)</span>

    <span class="n">recordmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_recordmask</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.harden_mask"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.harden_mask.html#numpy.ma.MaskedArray.harden_mask">[docs]</a>    <span class="k">def</span> <span class="nf">harden_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the mask to hard.</span>

<span class="sd">        Whether the mask of a masked array is hard or soft is determined by</span>
<span class="sd">        its `hardmask` property. `harden_mask` sets `hardmask` to True.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hardmask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.soften_mask"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.soften_mask.html#numpy.ma.MaskedArray.soften_mask">[docs]</a>    <span class="k">def</span> <span class="nf">soften_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the mask to soft.</span>

<span class="sd">        Whether the mask of a masked array is hard or soft is determined by</span>
<span class="sd">        its `hardmask` property. `soften_mask` sets `hardmask` to False.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        hardmask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="n">hardmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">,</span>
                        <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Hardness of the mask&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.unshare_mask"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.unshare_mask.html#numpy.ma.MaskedArray.unshare_mask">[docs]</a>    <span class="k">def</span> <span class="nf">unshare_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy the mask and set the sharedmask flag to False.</span>

<span class="sd">        Whether the mask is shared between masked arrays can be seen from</span>
<span class="sd">        the `sharedmask` property. `unshare_mask` ensures the mask is not shared.</span>
<span class="sd">        A copy of the mask is only made if it was shared.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sharedmask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sharedmask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="n">sharedmask</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sharedmask</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Share status of the mask (read-only).&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.shrink_mask"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.shrink_mask.html#numpy.ma.MaskedArray.shrink_mask">[docs]</a>    <span class="k">def</span> <span class="nf">shrink_mask</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reduce a mask to nomask when possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)</span>
<span class="sd">        &gt;&gt;&gt; x.mask</span>
<span class="sd">        array([[False, False],</span>
<span class="sd">               [False, False]], dtype=bool)</span>
<span class="sd">        &gt;&gt;&gt; x.shrink_mask()</span>
<span class="sd">        &gt;&gt;&gt; x.mask</span>
<span class="sd">        False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">return</span> <span class="bp">self</span></div>

    <span class="n">baseclass</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">,</span>
                         <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Class of the underlying data (read-only).&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the current data, as a view of the original</span>
<span class="sd">        underlying data.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">)</span>

    <span class="n">_data</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_data</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return a flat iterator.&quot;</span>
        <span class="k">return</span> <span class="n">MaskedIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_set_flat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="s2">&quot;Set a flattened version of self to value.&quot;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">y</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">flat</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_flat</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">_set_flat</span><span class="p">,</span>
                    <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Flat version of the array.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.get_fill_value"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.get_fill_value.html#numpy.ma.MaskedArray.get_fill_value">[docs]</a>    <span class="k">def</span> <span class="nf">get_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the filling value of the masked array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        fill_value : scalar</span>
<span class="sd">            The filling value.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for dt in [np.int32, np.int64, np.float64, np.complex128]:</span>
<span class="sd">        ...     np.ma.array([0, 1], dtype=dt).get_fill_value()</span>
<span class="sd">        ...</span>
<span class="sd">        999999</span>
<span class="sd">        999999</span>
<span class="sd">        1e+20</span>
<span class="sd">        (1e+20+0j)</span>

<span class="sd">        &gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=-np.inf)</span>
<span class="sd">        &gt;&gt;&gt; x.get_fill_value()</span>
<span class="sd">        -inf</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">[()]</span></div>

<div class="viewcode-block" id="MaskedArray.set_fill_value"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.set_fill_value.html#numpy.ma.MaskedArray.set_fill_value">[docs]</a>    <span class="k">def</span> <span class="nf">set_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the filling value of the masked array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value : scalar, optional</span>
<span class="sd">            The new filling value. Default is None, in which case a default</span>
<span class="sd">            based on the data type is used.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ma.set_fill_value : Equivalent function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([0, 1.], fill_value=-np.inf)</span>
<span class="sd">        &gt;&gt;&gt; x.fill_value</span>
<span class="sd">        -inf</span>
<span class="sd">        &gt;&gt;&gt; x.set_fill_value(np.pi)</span>
<span class="sd">        &gt;&gt;&gt; x.fill_value</span>
<span class="sd">        3.1415926535897931</span>

<span class="sd">        Reset to default:</span>

<span class="sd">        &gt;&gt;&gt; x.set_fill_value()</span>
<span class="sd">        &gt;&gt;&gt; x.fill_value</span>
<span class="sd">        1e+20</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">_fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span>
        <span class="k">if</span> <span class="n">_fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Create the attribute if it was undefined</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span> <span class="o">=</span> <span class="n">target</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Don&#39;t overwrite the attribute, just fill it (for propagation)</span>
            <span class="n">_fill_value</span><span class="p">[()]</span> <span class="o">=</span> <span class="n">target</span></div>

    <span class="n">fill_value</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_fill_value</span><span class="p">,</span> <span class="n">fset</span><span class="o">=</span><span class="n">set_fill_value</span><span class="p">,</span>
                          <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Filling value.&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.filled"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.filled.html#numpy.ma.MaskedArray.filled">[docs]</a>    <span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy of self, with masked values filled with a given value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            The value to use for invalid entries (None by default).</span>
<span class="sd">            If None, the `fill_value` attribute of the array is used instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled_array : ndarray</span>
<span class="sd">            A copy of ``self`` with invalid entries replaced by *fill_value*</span>
<span class="sd">            (be it the function argument or the attribute of ``self``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The result is **not** a MaskedArray!</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)</span>
<span class="sd">        &gt;&gt;&gt; x.filled()</span>
<span class="sd">        array([1, 2, -999, 4, -999])</span>
<span class="sd">        &gt;&gt;&gt; type(x.filled())</span>
<span class="sd">        &lt;type &#39;numpy.ndarray&#39;&gt;</span>

<span class="sd">        Subclassing is preserved. This means that if the data part of the masked</span>
<span class="sd">        array is a matrix, `filled` returns a matrix:</span>

<span class="sd">        &gt;&gt;&gt; x = np.ma.array(np.matrix([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; x.filled()</span>
<span class="sd">        matrix([[     1, 999999],</span>
<span class="sd">                [999999,      4]])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">_check_fill_value</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked_singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
            <span class="n">_recursive_filled</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s1">&#39;K&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">AttributeError</span><span class="p">):</span>
                <span class="n">fill_value</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">object</span><span class="p">)</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="c1"># ok, if scalar</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                    <span class="k">raise</span>
                <span class="k">elif</span> <span class="n">m</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MaskedArray.compressed"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.compressed.html#numpy.ma.MaskedArray.compressed">[docs]</a>    <span class="k">def</span> <span class="nf">compressed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return all the non-masked data as a 1-D array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data : ndarray</span>
<span class="sd">            A new `ndarray` holding the non-masked data is returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The result is **not** a MaskedArray!</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)</span>
<span class="sd">        &gt;&gt;&gt; x.compressed()</span>
<span class="sd">        array([0, 1])</span>
<span class="sd">        &gt;&gt;&gt; type(x.compressed())</span>
<span class="sd">        &lt;type &#39;numpy.ndarray&#39;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">data</span></div>

<div class="viewcode-block" id="MaskedArray.compress"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.compress.html#numpy.ma.MaskedArray.compress">[docs]</a>    <span class="k">def</span> <span class="nf">compress</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return `a` where condition is ``True``.</span>

<span class="sd">        If condition is a `MaskedArray`, missing values are considered</span>
<span class="sd">        as ``False``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        condition : var</span>
<span class="sd">            Boolean 1-d array selecting which entries to return. If len(condition)</span>
<span class="sd">            is less than the size of a along the axis, then output is truncated</span>
<span class="sd">            to length of condition array.</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which the operation must be performed.</span>
<span class="sd">        out : {None, ndarray}, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must have</span>
<span class="sd">            the same shape as the expected output but the type will be cast if</span>
<span class="sd">            necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MaskedArray</span>
<span class="sd">            A :class:`MaskedArray` object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Please note the difference with :meth:`compressed` !</span>
<span class="sd">        The output of :meth:`compress` has a mask, the output of</span>
<span class="sd">        :meth:`compressed` does not.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; x.compress([1, 0, 1])</span>
<span class="sd">        masked_array(data = [1 3],</span>
<span class="sd">              mask = [False False],</span>
<span class="sd">              fill_value=999999)</span>

<span class="sd">        &gt;&gt;&gt; x.compress([1, 0, 1], axis=1)</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[1 3]</span>
<span class="sd">         [-- --]</span>
<span class="sd">         [7 9]],</span>
<span class="sd">              mask =</span>
<span class="sd">         [[False False]</span>
<span class="sd">         [ True  True]</span>
<span class="sd">         [False False]],</span>
<span class="sd">              fill_value=999999)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the basic components</span>
        <span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>

        <span class="c1"># Force the condition to a regular ndarray and forget the missing</span>
        <span class="c1"># values.</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">_new</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">_new</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">_new</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">compress</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_new</span></div>

<div class="viewcode-block" id="MaskedArray.__str__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__str__.html#numpy.ma.MaskedArray.__str__">[docs]</a>    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        String representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">masked_print_option</span><span class="o">.</span><span class="n">enabled</span><span class="p">():</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">masked_print_option</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                        <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span>
                        <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="nb">tuple</span><span class="p">((</span><span class="n">f</span> <span class="k">if</span> <span class="n">_m</span> <span class="k">else</span> <span class="n">_d</span><span class="p">)</span> <span class="k">for</span> <span class="n">_d</span><span class="p">,</span> <span class="n">_m</span> <span class="ow">in</span>
                                             <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">m</span><span class="p">)))</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">m</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
                <span class="c1"># convert to object array to make filled work</span>
                <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
                <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s2">&quot;O&quot;</span><span class="p">)</span>
                    <span class="n">res</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)[</span><span class="n">m</span><span class="p">]</span> <span class="o">=</span> <span class="n">f</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rdtype</span> <span class="o">=</span> <span class="n">_recursive_make_descr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">)</span>
                    <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">)</span>
                    <span class="n">_recursive_printoption</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__repr__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__repr__.html#numpy.ma.MaskedArray.__repr__">[docs]</a>    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Literal string representation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;array&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="o">.</span><span class="n">__name__</span>

        <span class="n">parameters</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">nlen</span><span class="o">=</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">name</span><span class="p">),</span>
                          <span class="n">data</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">mask</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">),</span>
                          <span class="n">fill</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">_print_templates</span><span class="p">[</span><span class="s1">&#39;short_flx&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">parameters</span>
            <span class="k">return</span> <span class="n">_print_templates</span><span class="p">[</span><span class="s1">&#39;long_flx&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">parameters</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_print_templates</span><span class="p">[</span><span class="s1">&#39;short_std&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">parameters</span>
        <span class="k">return</span> <span class="n">_print_templates</span><span class="p">[</span><span class="s1">&#39;long_std&#39;</span><span class="p">]</span> <span class="o">%</span> <span class="n">parameters</span></div>

    <span class="k">def</span> <span class="nf">_delegate_binop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="c1"># This emulates the logic in</span>
        <span class="c1"># multiarray/number.c:PyArray_GenericBinaryFunction</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;__numpy_ufunc__&quot;</span><span class="p">)):</span>
            <span class="n">other_priority</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;__array_priority__&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1000000</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__array_priority__</span> <span class="o">&lt;</span> <span class="n">other_priority</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span>

<div class="viewcode-block" id="MaskedArray.__eq__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__eq__.html#numpy.ma.MaskedArray.__eq__">[docs]</a>    <span class="k">def</span> <span class="nf">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether other equals self elementwise.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="n">omask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">omask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">check</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">check</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># Dang, we have a bool instead of an array: return the bool</span>
                <span class="k">return</span> <span class="n">check</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">odata</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">__eq__</span><span class="p">(</span><span class="n">odata</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">check</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">omask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">omask</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">axis</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="n">bool_</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
                                       <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="n">check</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">check</span></div>

<div class="viewcode-block" id="MaskedArray.__ne__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__ne__.html#numpy.ma.MaskedArray.__ne__">[docs]</a>    <span class="k">def</span> <span class="nf">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check whether other doesn&#39;t equal self elementwise</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="n">omask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">omask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">check</span> <span class="o">=</span> <span class="n">check</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">check</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="c1"># In case check is a boolean (or a numpy.bool)</span>
                <span class="k">return</span> <span class="n">check</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">odata</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">check</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">__ne__</span><span class="p">(</span><span class="n">odata</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">check</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">omask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">omask</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">axis</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">axis</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">view</span><span class="p">((</span><span class="n">bool_</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">([[</span><span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mask</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
                                       <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mask</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="n">check</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
        <span class="k">return</span> <span class="n">check</span></div>

<div class="viewcode-block" id="MaskedArray.__add__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__add__.html#numpy.ma.MaskedArray.__add__">[docs]</a>    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add self to other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__radd__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__radd__.html#numpy.ma.MaskedArray.__radd__">[docs]</a>    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add other to self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In analogy with __rsub__ and __rdiv__, use original order:</span>
        <span class="c1"># we get here from `other + self`.</span>
        <span class="k">return</span> <span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__sub__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__sub__.html#numpy.ma.MaskedArray.__sub__">[docs]</a>    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract other from self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__rsub__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__rsub__.html#numpy.ma.MaskedArray.__rsub__">[docs]</a>    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract self from other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__mul__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__mul__.html#numpy.ma.MaskedArray.__mul__">[docs]</a>    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="s2">&quot;Multiply self by other, and return a new masked array.&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__rmul__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__rmul__.html#numpy.ma.MaskedArray.__rmul__">[docs]</a>    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply other by self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># In analogy with __rsub__ and __rdiv__, use original order:</span>
        <span class="c1"># we get here from `other * self`.</span>
        <span class="k">return</span> <span class="n">multiply</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__div__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__div__.html#numpy.ma.MaskedArray.__div__">[docs]</a>    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide other into self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__truediv__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__truediv__.html#numpy.ma.MaskedArray.__truediv__">[docs]</a>    <span class="k">def</span> <span class="nf">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide other into self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">true_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__rtruediv__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__rtruediv__.html#numpy.ma.MaskedArray.__rtruediv__">[docs]</a>    <span class="k">def</span> <span class="nf">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide self into other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">true_divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__floordiv__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__floordiv__.html#numpy.ma.MaskedArray.__floordiv__">[docs]</a>    <span class="k">def</span> <span class="nf">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide other into self, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">floor_divide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__rfloordiv__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__rfloordiv__.html#numpy.ma.MaskedArray.__rfloordiv__">[docs]</a>    <span class="k">def</span> <span class="nf">__rfloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide self into other, and return a new masked array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">floor_divide</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__pow__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__pow__.html#numpy.ma.MaskedArray.__pow__">[docs]</a>    <span class="k">def</span> <span class="nf">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise self to the power other, masking the potential NaNs/Infs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_delegate_binop</span><span class="p">(</span><span class="n">other</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__rpow__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__rpow__.html#numpy.ma.MaskedArray.__rpow__">[docs]</a>    <span class="k">def</span> <span class="nf">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise other to the power self, masking the potential NaNs/Infs</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">power</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.__iadd__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__iadd__.html#numpy.ma.MaskedArray.__iadd__">[docs]</a>    <span class="k">def</span> <span class="nf">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add other to self in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__iadd__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                     <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.__isub__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__isub__.html#numpy.ma.MaskedArray.__isub__">[docs]</a>    <span class="k">def</span> <span class="nf">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Subtract other from self in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__isub__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
                                     <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.__imul__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__imul__.html#numpy.ma.MaskedArray.__imul__">[docs]</a>    <span class="k">def</span> <span class="nf">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiply self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="k">elif</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">+=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__imul__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                     <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.__idiv__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__idiv__.html#numpy.ma.MaskedArray.__idiv__">[docs]</a>    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Divide self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dom_mask</span> <span class="o">=</span> <span class="n">_DomainSafeDivide</span><span class="p">()</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">dom_mask</span><span class="p">)</span>
        <span class="c1"># The following 3 lines control the domain filling</span>
        <span class="k">if</span> <span class="n">dom_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">]</span>
            <span class="n">other_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dom_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">new_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__idiv__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                     <span class="n">other_data</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.__ifloordiv__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__ifloordiv__.html#numpy.ma.MaskedArray.__ifloordiv__">[docs]</a>    <span class="k">def</span> <span class="nf">__ifloordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Floor divide self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dom_mask</span> <span class="o">=</span> <span class="n">_DomainSafeDivide</span><span class="p">()</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">dom_mask</span><span class="p">)</span>
        <span class="c1"># The following 3 lines control the domain filling</span>
        <span class="k">if</span> <span class="n">dom_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">floor_divide</span><span class="p">]</span>
            <span class="n">other_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dom_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">new_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__ifloordiv__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                          <span class="n">other_data</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.__itruediv__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__itruediv__.html#numpy.ma.MaskedArray.__itruediv__">[docs]</a>    <span class="k">def</span> <span class="nf">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        True divide self by other in-place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">dom_mask</span> <span class="o">=</span> <span class="n">_DomainSafeDivide</span><span class="p">()</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">dom_mask</span><span class="p">)</span>
        <span class="c1"># The following 3 lines control the domain filling</span>
        <span class="k">if</span> <span class="n">dom_mask</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">fval</span><span class="p">)</span> <span class="o">=</span> <span class="n">ufunc_fills</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">true_divide</span><span class="p">]</span>
            <span class="n">other_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dom_mask</span><span class="p">,</span> <span class="n">fval</span><span class="p">,</span> <span class="n">other_data</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">new_mask</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__itruediv__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                         <span class="n">other_data</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.__ipow__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__ipow__.html#numpy.ma.MaskedArray.__ipow__">[docs]</a>    <span class="k">def</span> <span class="nf">__ipow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Raise self to the power other, in place.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other_data</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">other_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__ipow__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                         <span class="n">other_data</span><span class="p">))</span>
        <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">invalid</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">|=</span> <span class="n">invalid</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">invalid</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">invalid</span><span class="p">)</span>
        <span class="n">new_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">other_mask</span><span class="p">,</span> <span class="n">invalid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">new_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="MaskedArray.__float__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__float__.html#numpy.ma.MaskedArray.__float__">[docs]</a>    <span class="k">def</span> <span class="nf">__float__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to float.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only length-1 arrays can be converted &quot;</span>
                            <span class="s2">&quot;to Python scalars&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Warning: converting a masked element to nan.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">())</span></div>

<div class="viewcode-block" id="MaskedArray.__int__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__int__.html#numpy.ma.MaskedArray.__int__">[docs]</a>    <span class="k">def</span> <span class="nf">__int__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert to int.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Only length-1 arrays can be converted &quot;</span>
                            <span class="s2">&quot;to Python scalars&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="s1">&#39;Cannot convert masked element to a Python int.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">item</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="nf">get_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the imaginary part of the masked array.</span>

<span class="sd">        The returned array is a view on the imaginary part of the `MaskedArray`</span>
<span class="sd">        whose `get_imag` method is called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MaskedArray</span>
<span class="sd">            The imaginary part of the masked array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_real, real, imag</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])</span>
<span class="sd">        &gt;&gt;&gt; x.get_imag()</span>
<span class="sd">        masked_array(data = [1.0 -- 1.6],</span>
<span class="sd">                     mask = [False  True False],</span>
<span class="sd">               fill_value = 1e+20)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">imag</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_imag</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Imaginary part.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the real part of the masked array.</span>

<span class="sd">        The returned array is a view on the real part of the `MaskedArray`</span>
<span class="sd">        whose `get_real` method is called.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : MaskedArray</span>
<span class="sd">            The real part of the masked array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        get_imag, real, imag</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])</span>
<span class="sd">        &gt;&gt;&gt; x.get_real()</span>
<span class="sd">        masked_array(data = [1.0 -- 3.45],</span>
<span class="sd">                     mask = [False  True False],</span>
<span class="sd">               fill_value = 1e+20)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="n">real</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">get_real</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;Real part&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.count"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.count.html#numpy.ma.MaskedArray.count">[docs]</a>    <span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Count the non-masked elements of the array along the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to count the non-masked elements. If `axis` is</span>
<span class="sd">            `None`, all non-masked elements are counted.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : int or ndarray</span>
<span class="sd">            If `axis` is `None`, an integer count is returned. When `axis` is</span>
<span class="sd">            not `None`, an array with shape determined by the lengths of the</span>
<span class="sd">            remaining axes, is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        count_masked : Count masked elements in array or along a given axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">        &gt;&gt;&gt; a = ma.arange(6).reshape((2, 3))</span>
<span class="sd">        &gt;&gt;&gt; a[1, :] = ma.masked</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[0 1 2]</span>
<span class="sd">         [-- -- --]],</span>
<span class="sd">                     mask =</span>
<span class="sd">         [[False False False]</span>
<span class="sd">         [ True  True  True]],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; a.count()</span>
<span class="sd">        3</span>

<span class="sd">        When the `axis` keyword is specified an array of appropriate size is</span>
<span class="sd">        returned.</span>

<span class="sd">        &gt;&gt;&gt; a.count(axis=0)</span>
<span class="sd">        array([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; a.count(axis=1)</span>
<span class="sd">        array([3, 0])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">n</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">t</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="n">n2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">narray</span><span class="p">(</span><span class="n">n1</span> <span class="o">-</span> <span class="n">n2</span><span class="p">)</span></div>

    <span class="n">flatten</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;flatten&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.ravel"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.ravel.html#numpy.ma.MaskedArray.ravel">[docs]</a>    <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 1D version of self, as a view.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        order : {&#39;C&#39;, &#39;F&#39;, &#39;A&#39;, &#39;K&#39;}, optional</span>
<span class="sd">            The elements of `a` are read using this index order. &#39;C&#39; means to</span>
<span class="sd">            index the elements in C-like order, with the last axis index</span>
<span class="sd">            changing fastest, back to the first axis index changing slowest.</span>
<span class="sd">            &#39;F&#39; means to index the elements in Fortran-like index order, with</span>
<span class="sd">            the first index changing fastest, and the last index changing</span>
<span class="sd">            slowest. Note that the &#39;C&#39; and &#39;F&#39; options take no account of the</span>
<span class="sd">            memory layout of the underlying array, and only refer to the order</span>
<span class="sd">            of axis indexing.  &#39;A&#39; means to read the elements in Fortran-like</span>
<span class="sd">            index order if `m` is Fortran *contiguous* in memory, C-like order</span>
<span class="sd">            otherwise.  &#39;K&#39; means to read the elements in the order they occur</span>
<span class="sd">            in memory, except for reversing the data when strides are negative.</span>
<span class="sd">            By default, &#39;C&#39; index order is used.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        MaskedArray</span>
<span class="sd">            Output view is of shape ``(self.size,)`` (or</span>
<span class="sd">            ``(np.ma.product(self.shape),)``).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; print x.ravel()</span>
<span class="sd">        [1 -- 3 -- 5 -- 7 -- 9]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">r</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">ravel</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">return</span> <span class="n">r</span></div>

    <span class="n">repeat</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;repeat&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="MaskedArray.reshape"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.reshape.html#numpy.ma.MaskedArray.reshape">[docs]</a>    <span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Give a new shape to the array without changing its data.</span>

<span class="sd">        Returns a masked array containing the same data, but with a new shape.</span>
<span class="sd">        The result is a view on the original array; if this is not possible, a</span>
<span class="sd">        ValueError is raised.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : int or tuple of ints</span>
<span class="sd">            The new shape should be compatible with the original shape. If an</span>
<span class="sd">            integer is supplied, then the result will be a 1-D array of that</span>
<span class="sd">            length.</span>
<span class="sd">        order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">            Determines whether the array data should be viewed as in C</span>
<span class="sd">            (row-major) or FORTRAN (column-major) order.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        reshaped_array : array</span>
<span class="sd">            A new view on the array.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        reshape : Equivalent function in the masked array module.</span>
<span class="sd">        numpy.ndarray.reshape : Equivalent method on ndarray object.</span>
<span class="sd">        numpy.reshape : Equivalent function in the NumPy module.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The reshaping operation cannot guarantee that a copy will not be made,</span>
<span class="sd">        to modify the shape in place, use ``a.shape = s``</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[-- 2]</span>
<span class="sd">         [3 --]]</span>
<span class="sd">        &gt;&gt;&gt; x = x.reshape((4,1))</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[--]</span>
<span class="sd">         [2]</span>
<span class="sd">         [3]</span>
<span class="sd">         [--]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;order&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MaskedArray.resize"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.resize.html#numpy.ma.MaskedArray.resize">[docs]</a>    <span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">newshape</span><span class="p">,</span> <span class="n">refcheck</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. warning::</span>

<span class="sd">            This method does nothing, except raise a ValueError exception. A</span>
<span class="sd">            masked array does not own its data and therefore cannot safely be</span>
<span class="sd">            resized in place. Use the `numpy.ma.resize` function instead.</span>

<span class="sd">        This method is difficult to implement safely and may be deprecated in</span>
<span class="sd">        future releases of NumPy.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Note : the &#39;order&#39; keyword looks broken, let&#39;s just drop it</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;A masked array does not own its data &quot;</span>\
                 <span class="s2">&quot;and therefore cannot be resized.</span><span class="se">\n</span><span class="s2">&quot;</span> \
                 <span class="s2">&quot;Use the numpy.ma.resize function instead.&quot;</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.put"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.put.html#numpy.ma.MaskedArray.put">[docs]</a>    <span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set storage-indexed locations to corresponding values.</span>

<span class="sd">        Sets self._data.flat[n] = values[n] for each n in indices.</span>
<span class="sd">        If `values` is shorter than `indices` then it will repeat.</span>
<span class="sd">        If `values` has some masked values, the initial mask is updated</span>
<span class="sd">        in consequence, else the corresponding values are unmasked.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices : 1-D array_like</span>
<span class="sd">            Target indices, interpreted as integers.</span>
<span class="sd">        values : array_like</span>
<span class="sd">            Values to place in self._data copy at target indices.</span>
<span class="sd">        mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">            Specifies how out-of-bounds indices will behave.</span>
<span class="sd">            &#39;raise&#39; : raise an error.</span>
<span class="sd">            &#39;wrap&#39; : wrap around.</span>
<span class="sd">            &#39;clip&#39; : clip to the range.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        `values` can be a scalar or length 1 array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; x.put([0,4,8],[10,20,30])</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[10 -- 3]</span>
<span class="sd">         [-- 20 --]</span>
<span class="sd">         [7 -- 30]]</span>

<span class="sd">        &gt;&gt;&gt; x.put(4,999)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[10 -- 3]</span>
<span class="sd">         [-- 999 --]</span>
<span class="sd">         [7 -- 30]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="c1"># Hard mask: Get rid of the values/indices that fall on masked data</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">values</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">indices</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="o">~</span><span class="n">mask</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">m</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="bp">False</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">m</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span></div>

<div class="viewcode-block" id="MaskedArray.ids"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.ids.html#numpy.ma.MaskedArray.ids">[docs]</a>    <span class="k">def</span> <span class="nf">ids</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the addresses of the data and mask areas.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1, 2, 3], mask=[0, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; x.ids()</span>
<span class="sd">        (166670640, 166659832)</span>

<span class="sd">        If the array has no mask, the address of `nomask` is returned. This address</span>
<span class="sd">        is typically not close to the data in memory:</span>

<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.ids()</span>
<span class="sd">        (166691080, 3083169284L)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="nb">id</span><span class="p">(</span><span class="n">nomask</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">ctypes</span><span class="o">.</span><span class="n">data</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.iscontiguous"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.iscontiguous.html#numpy.ma.MaskedArray.iscontiguous">[docs]</a>    <span class="k">def</span> <span class="nf">iscontiguous</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a boolean indicating whether the data is contiguous.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([1, 2, 3])</span>
<span class="sd">        &gt;&gt;&gt; x.iscontiguous()</span>
<span class="sd">        True</span>

<span class="sd">        `iscontiguous` returns one of the flags of the masked array:</span>

<span class="sd">        &gt;&gt;&gt; x.flags</span>
<span class="sd">          C_CONTIGUOUS : True</span>
<span class="sd">          F_CONTIGUOUS : True</span>
<span class="sd">          OWNDATA : False</span>
<span class="sd">          WRITEABLE : True</span>
<span class="sd">          ALIGNED : True</span>
<span class="sd">          UPDATEIFCOPY : False</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">[</span><span class="s1">&#39;CONTIGUOUS&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="MaskedArray.all"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.all.html#numpy.ma.MaskedArray.all">[docs]</a>    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if all of the elements of `a` are true.</span>

<span class="sd">        Performs a :func:`logical_and` over the given axis and returns the result.</span>
<span class="sd">        Masked values are considered as True during computation.</span>
<span class="sd">        For convenience, the output array is masked where ALL the values along the</span>
<span class="sd">        current axis are masked: if the output would have been a scalar and that</span>
<span class="sd">        all the values are masked, then the output is `masked`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, integer}</span>
<span class="sd">            Axis to perform the operation over.</span>
<span class="sd">            If None, perform over flattened array.</span>
<span class="sd">        out : {None, array}, optional</span>
<span class="sd">            Array into which the result can be placed. Its type is preserved</span>
<span class="sd">            and it must be of the right shape to hold the output.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        all : equivalent function</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; np.ma.array([1,2,3]).all()</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([1,2,3], mask=True)</span>
<span class="sd">        &gt;&gt;&gt; (a.all() is np.ma.masked)</span>
<span class="sd">        True</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mask</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MaskedArray.any"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.any.html#numpy.ma.MaskedArray.any">[docs]</a>    <span class="k">def</span> <span class="nf">any</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check if any of the elements of `a` are true.</span>

<span class="sd">        Performs a logical_or over the given axis and returns the result.</span>
<span class="sd">        Masked values are considered as False during computation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, integer}</span>
<span class="sd">            Axis to perform the operation over.</span>
<span class="sd">            If None, perform over flattened array and return a scalar.</span>
<span class="sd">        out : {None, array}, optional</span>
<span class="sd">            Array into which the result can be placed. Its type is preserved</span>
<span class="sd">            and it must be of the right shape to hold the output.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        any : equivalent function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="n">d</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">ndim</span> <span class="ow">or</span> <span class="n">mask</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MaskedArray.nonzero"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.nonzero.html#numpy.ma.MaskedArray.nonzero">[docs]</a>    <span class="k">def</span> <span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the indices of unmasked elements that are not zero.</span>

<span class="sd">        Returns a tuple of arrays, one for each dimension, containing the</span>
<span class="sd">        indices of the non-zero elements in that dimension. The corresponding</span>
<span class="sd">        non-zero values can be obtained with::</span>

<span class="sd">            a[a.nonzero()]</span>

<span class="sd">        To group the indices by element, rather than dimension, use</span>
<span class="sd">        instead::</span>

<span class="sd">            np.transpose(a.nonzero())</span>

<span class="sd">        The result of this is always a 2d array, with a row for each non-zero</span>
<span class="sd">        element.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        tuple_of_arrays : tuple</span>
<span class="sd">            Indices of elements that are non-zero.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.nonzero :</span>
<span class="sd">            Function operating on ndarrays.</span>
<span class="sd">        flatnonzero :</span>
<span class="sd">            Return indices that are non-zero in the flattened version of the input</span>
<span class="sd">            array.</span>
<span class="sd">        ndarray.nonzero :</span>
<span class="sd">            Equivalent ndarray method.</span>
<span class="sd">        count_nonzero :</span>
<span class="sd">            Counts the number of non-zero elements in the input array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">        &gt;&gt;&gt; x = ma.array(np.eye(3))</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[ 1.  0.  0.]</span>
<span class="sd">         [ 0.  1.  0.]</span>
<span class="sd">         [ 0.  0.  1.]],</span>
<span class="sd">              mask =</span>
<span class="sd">         False,</span>
<span class="sd">              fill_value=1e+20)</span>
<span class="sd">        &gt;&gt;&gt; x.nonzero()</span>
<span class="sd">        (array([0, 1, 2]), array([0, 1, 2]))</span>

<span class="sd">        Masked elements are ignored.</span>

<span class="sd">        &gt;&gt;&gt; x[1, 1] = ma.masked</span>
<span class="sd">        &gt;&gt;&gt; x</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[1.0 0.0 0.0]</span>
<span class="sd">         [0.0 -- 0.0]</span>
<span class="sd">         [0.0 0.0 1.0]],</span>
<span class="sd">              mask =</span>
<span class="sd">         [[False False False]</span>
<span class="sd">         [False  True False]</span>
<span class="sd">         [False False False]],</span>
<span class="sd">              fill_value=1e+20)</span>
<span class="sd">        &gt;&gt;&gt; x.nonzero()</span>
<span class="sd">        (array([0, 2]), array([0, 2]))</span>

<span class="sd">        Indices can also be grouped by element.</span>

<span class="sd">        &gt;&gt;&gt; np.transpose(x.nonzero())</span>
<span class="sd">        array([[0, 0],</span>
<span class="sd">               [2, 2]])</span>

<span class="sd">        A common use for ``nonzero`` is to find the indices of an array, where</span>
<span class="sd">        a condition is True.  Given an array `a`, the condition `a` &gt; 3 is a</span>
<span class="sd">        boolean array and since False is interpreted as 0, ma.nonzero(a &gt; 3)</span>
<span class="sd">        yields the indices of the `a` where the condition is true.</span>

<span class="sd">        &gt;&gt;&gt; a = ma.array([[1,2,3],[4,5,6],[7,8,9]])</span>
<span class="sd">        &gt;&gt;&gt; a &gt; 3</span>
<span class="sd">        masked_array(data =</span>
<span class="sd">         [[False False False]</span>
<span class="sd">         [ True  True  True]</span>
<span class="sd">         [ True  True  True]],</span>
<span class="sd">              mask =</span>
<span class="sd">         False,</span>
<span class="sd">              fill_value=999999)</span>
<span class="sd">        &gt;&gt;&gt; ma.nonzero(a &gt; 3)</span>
<span class="sd">        (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">        The ``nonzero`` method of the condition array can also be called.</span>

<span class="sd">        &gt;&gt;&gt; (a &gt; 3).nonzero()</span>
<span class="sd">        (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">narray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span></div>

<div class="viewcode-block" id="MaskedArray.trace"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.trace.html#numpy.ma.MaskedArray.trace">[docs]</a>    <span class="k">def</span> <span class="nf">trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (this docstring should be overwritten)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#!!!: implement out + test!</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">trace</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span>
                                                    <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="n">axis1</span><span class="p">,</span> <span class="n">axis2</span><span class="o">=</span><span class="n">axis2</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">D</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>
    <span class="n">trace</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">trace</span><span class="o">.</span><span class="n">__doc__</span>

    <span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a.dot(b, out=None)</span>

<span class="sd">        Masked dot product of two arrays. Note that `out` and `strict` are</span>
<span class="sd">        located in different positions than in `ma.dot`. In order to</span>
<span class="sd">        maintain compatibility with the functional version, it is</span>
<span class="sd">        recommended that the optional arguments be treated as keyword only.</span>
<span class="sd">        At some point that may be mandatory.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        b : masked_array_like</span>
<span class="sd">            Inputs array.</span>
<span class="sd">        out : masked_array, optional</span>
<span class="sd">            Output argument. This must have the exact kind that would be</span>
<span class="sd">            returned if it was not used. In particular, it must have the</span>
<span class="sd">            right type, must be C-contiguous, and its dtype must be the</span>
<span class="sd">            dtype that would be returned for `ma.dot(a,b)`. This is a</span>
<span class="sd">            performance feature. Therefore, if these conditions are not</span>
<span class="sd">            met, an exception is raised, instead of attempting to be</span>
<span class="sd">            flexible.</span>
<span class="sd">        strict : bool, optional</span>
<span class="sd">            Whether masked data are propagated (True) or set to 0 (False)</span>
<span class="sd">            for the computation. Default is False.  Propagating the mask</span>
<span class="sd">            means that if a masked value appears in a row or column, the</span>
<span class="sd">            whole row or column is considered masked.</span>

<span class="sd">            .. versionadded:: 1.10.2</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ma.dot : equivalent function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.sum"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.sum.html#numpy.ma.MaskedArray.sum">[docs]</a>    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sum of the array elements over the given axis.</span>
<span class="sd">        Masked elements are set to 0 internally.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, -1, int}, optional</span>
<span class="sd">            Axis along which the sum is computed. The default</span>
<span class="sd">            (`axis` = None) is to compute over the flattened array.</span>
<span class="sd">        dtype : {None, dtype}, optional</span>
<span class="sd">            Determines the type of the returned array and of the accumulator</span>
<span class="sd">            where the elements are summed. If dtype has the value None and</span>
<span class="sd">            the type of a is an integer type of precision less than the default</span>
<span class="sd">            platform integer, then the default platform integer precision is</span>
<span class="sd">            used.  Otherwise, the dtype is the same as that of a.</span>
<span class="sd">        out :  {None, ndarray}, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must</span>
<span class="sd">            have the same shape and buffer length as the expected output</span>
<span class="sd">            but the type will be cast if necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sum_along_axis : MaskedArray or scalar</span>
<span class="sd">            An array with the same shape as self, with the specified</span>
<span class="sd">            axis removed.   If self is a 0-d array, or if `axis` is None, a scalar</span>
<span class="sd">            is returned.  If an output array is specified, a reference to</span>
<span class="sd">            `out` is returned.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; print x.sum()</span>
<span class="sd">        25</span>
<span class="sd">        &gt;&gt;&gt; print x.sum(axis=1)</span>
<span class="sd">        [4 5 16]</span>
<span class="sd">        &gt;&gt;&gt; print x.sum(axis=0)</span>
<span class="sd">        [8 5 12]</span>
<span class="sd">        &gt;&gt;&gt; print type(x.sum(axis=0, dtype=np.int64)[0])</span>
<span class="sd">        &lt;type &#39;numpy.int64&#39;&gt;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">rndim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rndim</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MaskedArray.cumsum"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.cumsum.html#numpy.ma.MaskedArray.cumsum">[docs]</a>    <span class="k">def</span> <span class="nf">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative sum of the elements along the given axis.</span>
<span class="sd">        The cumulative sum is calculated over the flattened array by</span>
<span class="sd">        default, otherwise over the specified axis.</span>

<span class="sd">        Masked values are set to 0 internally during the computation.</span>
<span class="sd">        However, their position is saved, and the result will be masked at</span>
<span class="sd">        the same locations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, -1, int}, optional</span>
<span class="sd">            Axis along which the sum is computed. The default (`axis` = None) is to</span>
<span class="sd">            compute over the flattened array. `axis` may be negative, in which case</span>
<span class="sd">            it counts from the   last to the first axis.</span>
<span class="sd">        dtype : {None, dtype}, optional</span>
<span class="sd">            Type of the returned array and of the accumulator in which the</span>
<span class="sd">            elements are summed.  If `dtype` is not specified, it defaults</span>
<span class="sd">            to the dtype of `a`, unless `a` has an integer dtype with a</span>
<span class="sd">            precision less than that of the default platform integer.  In</span>
<span class="sd">            that case, the default platform integer is used.</span>
<span class="sd">        out : ndarray, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must</span>
<span class="sd">            have the same shape and buffer length as the expected output</span>
<span class="sd">            but the type will be cast if necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cumsum : ndarray.</span>
<span class="sd">            A new array holding the result is returned unless ``out`` is</span>
<span class="sd">            specified, in which case a reference to ``out`` is returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The mask is lost if `out` is not a valid :class:`MaskedArray` !</span>

<span class="sd">        Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">        raised on overflow.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])</span>
<span class="sd">        &gt;&gt;&gt; print marr.cumsum()</span>
<span class="sd">        [0 1 3 -- -- -- 9 16 24 33]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MaskedArray.prod"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.prod.html#numpy.ma.MaskedArray.prod">[docs]</a>    <span class="k">def</span> <span class="nf">prod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the product of the array elements over the given axis.</span>
<span class="sd">        Masked elements are set to 1 internally for computation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis over which the product is taken. If None is used, then the</span>
<span class="sd">            product is over all the array elements.</span>
<span class="sd">        dtype : {None, dtype}, optional</span>
<span class="sd">            Determines the type of the returned array and of the accumulator</span>
<span class="sd">            where the elements are multiplied. If ``dtype`` has the value ``None``</span>
<span class="sd">            and the type of a is an integer type of precision less than the default</span>
<span class="sd">            platform integer, then the default platform integer precision is</span>
<span class="sd">            used.  Otherwise, the dtype is the same as that of a.</span>
<span class="sd">        out : {None, array}, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must have</span>
<span class="sd">            the same shape as the expected output but the type will be cast if</span>
<span class="sd">            necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        product_along_axis : {array, scalar}, see dtype parameter above.</span>
<span class="sd">            Returns an array whose shape is the same as a with the specified</span>
<span class="sd">            axis removed. Returns a 0d array when a is 1d or axis=None.</span>
<span class="sd">            Returns a reference to the specified output array if specified.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        prod : equivalent function</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Arithmetic is modular when using integer types, and no error is raised</span>
<span class="sd">        on overflow.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; np.prod([1.,2.])</span>
<span class="sd">        2.0</span>
<span class="sd">        &gt;&gt;&gt; np.prod([1.,2.], dtype=np.int32)</span>
<span class="sd">        2</span>
<span class="sd">        &gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]])</span>
<span class="sd">        24.0</span>
<span class="sd">        &gt;&gt;&gt; np.prod([[1.,2.],[3.,4.]], axis=1)</span>
<span class="sd">        array([  2.,  12.])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">rndim</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;ndim&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">rndim</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="n">product</span> <span class="o">=</span> <span class="n">prod</span>

<div class="viewcode-block" id="MaskedArray.cumprod"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.cumprod.html#numpy.ma.MaskedArray.cumprod">[docs]</a>    <span class="k">def</span> <span class="nf">cumprod</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the cumulative product of the elements along the given axis.</span>
<span class="sd">        The cumulative product is taken over the flattened array by</span>
<span class="sd">        default, otherwise over the specified axis.</span>

<span class="sd">        Masked values are set to 1 internally during the computation.</span>
<span class="sd">        However, their position is saved, and the result will be masked at</span>
<span class="sd">        the same locations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, -1, int}, optional</span>
<span class="sd">            Axis along which the product is computed. The default</span>
<span class="sd">            (`axis` = None) is to compute over the flattened array.</span>
<span class="sd">        dtype : {None, dtype}, optional</span>
<span class="sd">            Determines the type of the returned array and of the accumulator</span>
<span class="sd">            where the elements are multiplied. If ``dtype`` has the value ``None``</span>
<span class="sd">            and the type of ``a`` is an integer type of precision less than the</span>
<span class="sd">            default platform integer, then the default platform integer precision</span>
<span class="sd">            is used.  Otherwise, the dtype is the same as that of ``a``.</span>
<span class="sd">        out : ndarray, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must</span>
<span class="sd">            have the same shape and buffer length as the expected output</span>
<span class="sd">            but the type will be cast if necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cumprod : ndarray</span>
<span class="sd">            A new array holding the result is returned unless out is specified,</span>
<span class="sd">            in which case a reference to out is returned.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The mask is lost if `out` is not a valid MaskedArray !</span>

<span class="sd">        Arithmetic is modular when using integer types, and no error is</span>
<span class="sd">        raised on overflow.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cumprod</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MaskedArray.mean"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.mean.html#numpy.ma.MaskedArray.mean">[docs]</a>    <span class="k">def</span> <span class="nf">mean</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the average of the array elements.</span>

<span class="sd">        Masked entries are ignored.</span>
<span class="sd">        The average is taken over the flattened array by default, otherwise over</span>
<span class="sd">        the specified axis. Refer to `numpy.mean` for the full documentation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : array_like</span>
<span class="sd">            Array containing numbers whose mean is desired. If `a` is not an</span>
<span class="sd">            array, a conversion is attempted.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which the means are computed. The default is to compute</span>
<span class="sd">            the mean of the flattened array.</span>
<span class="sd">        dtype : dtype, optional</span>
<span class="sd">            Type to use in computing the mean. For integer inputs, the default</span>
<span class="sd">            is float64; for floating point, inputs it is the same as the input</span>
<span class="sd">            dtype.</span>
<span class="sd">        out : ndarray, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must have</span>
<span class="sd">            the same shape as the expected output but the type will be cast if</span>
<span class="sd">            necessary.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mean : ndarray, see dtype parameter above</span>
<span class="sd">            If `out=None`, returns a new array containing the mean values,</span>
<span class="sd">            otherwise a reference to the output array is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.ma.mean : Equivalent function.</span>
<span class="sd">        numpy.mean : Equivalent function on non-masked arrays.</span>
<span class="sd">        numpy.ma.average: Weighted average.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([1,2,3], mask=[False, False, True])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        masked_array(data = [1 2 --],</span>
<span class="sd">                     mask = [False False  True],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; a.mean()</span>
<span class="sd">        1.5</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dsum</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cnt</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">dsum</span> <span class="o">*</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">cnt</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">result</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                    <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
                <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="MaskedArray.anom"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.anom.html#numpy.ma.MaskedArray.anom">[docs]</a>    <span class="k">def</span> <span class="nf">anom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the anomalies (deviations from the arithmetic mean)</span>
<span class="sd">        along the given axis.</span>

<span class="sd">        Returns an array of anomalies, with the same shape as the input and</span>
<span class="sd">        where the arithmetic mean is computed along the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis over which the anomalies are taken.</span>
<span class="sd">            The default is to use the mean of the flattened array as reference.</span>
<span class="sd">        dtype : dtype, optional</span>
<span class="sd">            Type to use in computing the variance. For arrays of integer type</span>
<span class="sd">             the default is float32; for arrays of float types it is the same as</span>
<span class="sd">             the array type.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        mean : Compute the mean of the array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([1,2,3])</span>
<span class="sd">        &gt;&gt;&gt; a.anom()</span>
<span class="sd">        masked_array(data = [-1.  0.  1.],</span>
<span class="sd">                     mask = False,</span>
<span class="sd">               fill_value = 1e+20)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">m</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span> <span class="o">-</span> <span class="n">expand_dims</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span></div>

<div class="viewcode-block" id="MaskedArray.var"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.var.html#numpy.ma.MaskedArray.var">[docs]</a>    <span class="k">def</span> <span class="nf">var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s2">&quot;&quot;</span>
        <span class="c1"># Easy case: nomask, business as usual</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        <span class="c1"># Some data are masked, yay!</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span> <span class="o">-</span> <span class="n">ddof</span>
        <span class="n">danom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">anom</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">iscomplexobj</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">danom</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">danom</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">danom</span> <span class="o">*=</span> <span class="n">danom</span>
        <span class="n">dvar</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="n">danom</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="n">cnt</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="c1"># Apply the mask if it&#39;s not a scalar</span>
        <span class="k">if</span> <span class="n">dvar</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="n">dvar</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="p">),</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span>
            <span class="n">dvar</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">dvar</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">):</span>
            <span class="c1"># Make sure that masked is returned when the scalar is masked.</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;biu&#39;</span><span class="p">:</span>
                    <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Masked data information would be lost in one or &quot;</span>\
                             <span class="s2">&quot;more location.&quot;</span>
                    <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="k">return</span> <span class="n">out</span>
        <span class="c1"># In case with have an explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Set the data</span>
            <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">dvar</span>
            <span class="c1"># Set the mask if needed</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
                <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">dvar</span><span class="o">.</span><span class="n">mask</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">return</span> <span class="n">dvar</span></div>
    <span class="n">var</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="MaskedArray.std"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.std.html#numpy.ma.MaskedArray.std">[docs]</a>    <span class="k">def</span> <span class="nf">std</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="s2">&quot;&quot;</span>
        <span class="n">dvar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dvar</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">out</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">dvar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dvar</span></div>
    <span class="n">std</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="MaskedArray.round"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.round.html#numpy.ma.MaskedArray.round">[docs]</a>    <span class="k">def</span> <span class="nf">round</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an array rounded a to the given number of decimals.</span>

<span class="sd">        Refer to `numpy.around` for full documentation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.around : equivalent function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span><span class="o">=</span><span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># No explicit output: we&#39;re done</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>
    <span class="nb">round</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">round</span><span class="o">.</span><span class="n">__doc__</span>

<div class="viewcode-block" id="MaskedArray.argsort"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.argsort.html#numpy.ma.MaskedArray.argsort">[docs]</a>    <span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an ndarray of indices that sort the array along the</span>
<span class="sd">        specified axis.  Masked values are filled beforehand to</span>
<span class="sd">        `fill_value`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to sort.  The default is -1 (last axis).</span>
<span class="sd">            If None, the flattened array is used.</span>
<span class="sd">        fill_value : var, optional</span>
<span class="sd">            Value used to fill the array before sorting.</span>
<span class="sd">            The default is the `fill_value` attribute of the input array.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">            Sorting algorithm.</span>
<span class="sd">        order : list, optional</span>
<span class="sd">            When `a` is an array with fields defined, this argument specifies</span>
<span class="sd">            which fields to compare first, second, etc.  Not all fields need be</span>
<span class="sd">            specified.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index_array : ndarray, int</span>
<span class="sd">            Array of indices that sort `a` along the specified axis.</span>
<span class="sd">            In other words, ``a[index_array]`` yields a sorted `a`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sort : Describes sorting algorithms used.</span>
<span class="sd">        lexsort : Indirect stable sort with multiple keys.</span>
<span class="sd">        ndarray.sort : Inplace sort.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See `sort` for notes on the different sorting algorithms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.ma.array([3,2,1], mask=[False, False, True])</span>
<span class="sd">        &gt;&gt;&gt; a</span>
<span class="sd">        masked_array(data = [3 2 --],</span>
<span class="sd">                     mask = [False False  True],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; a.argsort()</span>
<span class="sd">        array([1, 0, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.argmin"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.argmin.html#numpy.ma.MaskedArray.argmin">[docs]</a>    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return array of indices to the minimum values along the given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, integer}</span>
<span class="sd">            If None, the index is into the flattened array, otherwise along</span>
<span class="sd">            the specified axis</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.  If None, the output of</span>
<span class="sd">            minimum_fill_value(self._data) is used instead.</span>
<span class="sd">        out : {None, array}, optional</span>
<span class="sd">            Array into which the result can be placed. Its type is preserved</span>
<span class="sd">            and it must be of the right shape to hold the output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray or scalar</span>
<span class="sd">            If multi-dimension input, returns a new ndarray of indices to the</span>
<span class="sd">            minimum values along the given axis.  Otherwise, returns a scalar</span>
<span class="sd">            of index to the minimum values along the given axis.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(arange(4), mask=[1,1,0,0])</span>
<span class="sd">        &gt;&gt;&gt; x.shape = (2,2)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[-- --]</span>
<span class="sd">         [2 3]]</span>
<span class="sd">        &gt;&gt;&gt; print x.argmin(axis=0, fill_value=-1)</span>
<span class="sd">        [0 0]</span>
<span class="sd">        &gt;&gt;&gt; print x.argmin(axis=0, fill_value=9)</span>
<span class="sd">        [1 1]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">minimum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.argmax"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.argmax.html#numpy.ma.MaskedArray.argmax">[docs]</a>    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns array of indices of the maximum values along the given axis.</span>
<span class="sd">        Masked values are treated as if they had the value fill_value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, integer}</span>
<span class="sd">            If None, the index is into the flattened array, otherwise along</span>
<span class="sd">            the specified axis</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.  If None, the output of</span>
<span class="sd">            maximum_fill_value(self._data) is used instead.</span>
<span class="sd">        out : {None, array}, optional</span>
<span class="sd">            Array into which the result can be placed. Its type is preserved</span>
<span class="sd">            and it must be of the right shape to hold the output.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index_array : {integer_array}</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = np.arange(6).reshape(2,3)</span>
<span class="sd">        &gt;&gt;&gt; a.argmax()</span>
<span class="sd">        5</span>
<span class="sd">        &gt;&gt;&gt; a.argmax(0)</span>
<span class="sd">        array([1, 1, 1])</span>
<span class="sd">        &gt;&gt;&gt; a.argmax(1)</span>
<span class="sd">        array([2, 2])</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maximum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.sort"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.sort.html#numpy.ma.MaskedArray.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
             <span class="n">endwith</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the array, in-place</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        a : array_like</span>
<span class="sd">            Array to be sorted.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            Axis along which to sort. If None, the array is flattened before</span>
<span class="sd">            sorting. The default is -1, which sorts along the last axis.</span>
<span class="sd">        kind : {&#39;quicksort&#39;, &#39;mergesort&#39;, &#39;heapsort&#39;}, optional</span>
<span class="sd">            Sorting algorithm. Default is &#39;quicksort&#39;.</span>
<span class="sd">        order : list, optional</span>
<span class="sd">            When `a` is a structured array, this argument specifies which fields</span>
<span class="sd">            to compare first, second, and so on.  This list does not need to</span>
<span class="sd">            include all of the fields.</span>
<span class="sd">        endwith : {True, False}, optional</span>
<span class="sd">            Whether missing values (if any) should be forced in the upper indices</span>
<span class="sd">            (at the end of the array) (True) or lower indices (at the beginning).</span>
<span class="sd">            When the array contains unmasked values of the largest (or smallest if</span>
<span class="sd">            False) representable value of the datatype the ordering of these values</span>
<span class="sd">            and the masked values is undefined.  To enforce the masked values are</span>
<span class="sd">            at the end (beginning) in this case one must sort the mask.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used internally for the masked values.</span>
<span class="sd">            If ``fill_value`` is not None, it supersedes ``endwith``.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sorted_array : ndarray</span>
<span class="sd">            Array of the same type and shape as `a`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.sort : Method to sort an array in-place.</span>
<span class="sd">        argsort : Indirect sort.</span>
<span class="sd">        lexsort : Indirect stable sort on multiple keys.</span>
<span class="sd">        searchsorted : Find elements in a sorted array.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        See ``sort`` for notes on the different sorting algorithms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; # Default</span>
<span class="sd">        &gt;&gt;&gt; a.sort()</span>
<span class="sd">        &gt;&gt;&gt; print a</span>
<span class="sd">        [1 3 5 -- --]</span>

<span class="sd">        &gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; # Put missing values in the front</span>
<span class="sd">        &gt;&gt;&gt; a.sort(endwith=False)</span>
<span class="sd">        &gt;&gt;&gt; print a</span>
<span class="sd">        [-- -- 1 3 5]</span>

<span class="sd">        &gt;&gt;&gt; a = ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])</span>
<span class="sd">        &gt;&gt;&gt; # fill_value takes over endwith</span>
<span class="sd">        &gt;&gt;&gt; a.sort(endwith=False, fill_value=3)</span>
<span class="sd">        &gt;&gt;&gt; print a</span>
<span class="sd">        [1 -- -- 3 5]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">ndarray</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span>
            <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">endwith</span><span class="p">:</span>
                    <span class="c1"># nan &gt; inf</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                        <span class="n">filler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">filler</span> <span class="o">=</span> <span class="n">minimum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">filler</span> <span class="o">=</span> <span class="n">maximum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filler</span> <span class="o">=</span> <span class="n">fill_value</span>

            <span class="n">sidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">filler</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
                                               <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
            <span class="c1"># save meshgrid memory for 1d arrays</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">sidx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                  <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
                <span class="n">idx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sidx</span>
            <span class="n">tmp_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span>
            <span class="n">tmp_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">flat</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">tmp_data</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">tmp_mask</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="MaskedArray.min"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.min.html#numpy.ma.MaskedArray.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the minimum along a given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which to operate.  By default, ``axis`` is None and the</span>
<span class="sd">            flattened input is used.</span>
<span class="sd">        out : array_like, optional</span>
<span class="sd">            Alternative output array in which to place the result.  Must be of</span>
<span class="sd">            the same shape and buffer length as the expected output.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.</span>
<span class="sd">            If None, use the output of `minimum_fill_value`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        amin : array_like</span>
<span class="sd">            New array holding the result.</span>
<span class="sd">            If ``out`` was specified, ``out`` is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        minimum_fill_value</span>
<span class="sd">            Returns the minimum filling value for a given datatype.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">minimum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># Set the mask</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
                <span class="c1"># Get rid of Infs</span>
                <span class="k">if</span> <span class="n">newmask</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;biu&#39;</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Masked data information would be lost in one or more&quot;</span>\
                         <span class="s2">&quot; location.&quot;</span>
                <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="k">def</span> <span class="nf">mini</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array minimum along the specified axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            The axis along which to find the minima. Default is None, in which case</span>
<span class="sd">            the minimum value in the whole array is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        min : scalar or MaskedArray</span>
<span class="sd">            If `axis` is None, the result is a scalar. Otherwise, if `axis` is</span>
<span class="sd">            given and the array is at least 2-D, the result is a masked array with</span>
<span class="sd">            dimension one smaller than the array on which `mini` is called.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[0 --]</span>
<span class="sd">         [2 3]</span>
<span class="sd">         [4 --]]</span>
<span class="sd">        &gt;&gt;&gt; x.mini()</span>
<span class="sd">        0</span>
<span class="sd">        &gt;&gt;&gt; x.mini(axis=0)</span>
<span class="sd">        masked_array(data = [0 3],</span>
<span class="sd">                     mask = [False False],</span>
<span class="sd">               fill_value = 999999)</span>
<span class="sd">        &gt;&gt;&gt; print x.mini(axis=1)</span>
<span class="sd">        [0 2 4]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">minimum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">minimum</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.max"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.max.html#numpy.ma.MaskedArray.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the maximum along a given axis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which to operate.  By default, ``axis`` is None and the</span>
<span class="sd">            flattened input is used.</span>
<span class="sd">        out : array_like, optional</span>
<span class="sd">            Alternative output array in which to place the result.  Must</span>
<span class="sd">            be of the same shape and buffer length as the expected output.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.</span>
<span class="sd">            If None, use the output of maximum_fill_value().</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        amax : array_like</span>
<span class="sd">            New array holding the result.</span>
<span class="sd">            If ``out`` was specified, ``out`` is returned.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        maximum_fill_value</span>
<span class="sd">            Returns the maximum filling value for a given datatype.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="n">newmask</span> <span class="o">=</span> <span class="n">_check_mask_axis</span><span class="p">(</span><span class="n">_mask</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="n">maximum_fill_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># No explicit output</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                <span class="c1"># Set the mask</span>
                <span class="n">result</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">newmask</span><span class="p">)</span>
                <span class="c1"># Get rid of Infs</span>
                <span class="k">if</span> <span class="n">newmask</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">newmask</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">masked</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="c1"># Explicit output</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">outmask</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">outmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">outmask</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="n">newmask</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="s1">&#39;biu&#39;</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Masked data information would be lost in one or more&quot;</span>\
                         <span class="s2">&quot; location.&quot;</span>
                <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">newmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MaskedArray.ptp"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.ptp.html#numpy.ma.MaskedArray.ptp">[docs]</a>    <span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return (maximum - minimum) along the the given dimension</span>
<span class="sd">        (i.e. peak-to-peak value).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : {None, int}, optional</span>
<span class="sd">            Axis along which to find the peaks.  If None (default) the</span>
<span class="sd">            flattened array is used.</span>
<span class="sd">        out : {None, array_like}, optional</span>
<span class="sd">            Alternative output array in which to place the result. It must</span>
<span class="sd">            have the same shape and buffer length as the expected output</span>
<span class="sd">            but the type will be cast if necessary.</span>
<span class="sd">        fill_value : {var}, optional</span>
<span class="sd">            Value used to fill in the masked values.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ptp : ndarray.</span>
<span class="sd">            A new array holding the result, unless ``out`` was</span>
<span class="sd">            specified, in which case a reference to ``out`` is returned.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">result</span>
        <span class="n">out</span><span class="o">.</span><span class="n">flat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="n">min_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">min_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="MaskedArray.take"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.take.html#numpy.ma.MaskedArray.take">[docs]</a>    <span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="n">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Make sure the indices are not masked</span>
        <span class="n">maskindices</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">nomask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">maskindices</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="n">indices</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Get the data</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
        <span class="c1"># Get the mask</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">maskindices</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">outmask</span> <span class="o">=</span> <span class="n">_mask</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
                <span class="n">outmask</span> <span class="o">|=</span> <span class="n">maskindices</span>
            <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">outmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

    <span class="c1"># Array methods</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">)</span>
    <span class="n">diagonal</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;diagonal&#39;</span><span class="p">)</span>
    <span class="n">transpose</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;transpose&#39;</span><span class="p">)</span>
    <span class="n">T</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="k">lambda</span> <span class="bp">self</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span>
    <span class="n">swapaxes</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;swapaxes&#39;</span><span class="p">)</span>
    <span class="n">clip</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;clip&#39;</span><span class="p">,</span> <span class="n">onmask</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">copy</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">)</span>
    <span class="n">squeeze</span> <span class="o">=</span> <span class="n">_arraymethod</span><span class="p">(</span><span class="s1">&#39;squeeze&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="MaskedArray.tolist"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.tolist.html#numpy.ma.MaskedArray.tolist">[docs]</a>    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the data portion of the masked array as a hierarchical Python list.</span>

<span class="sd">        Data items are converted to the nearest compatible Python type.</span>
<span class="sd">        Masked values are converted to `fill_value`. If `fill_value` is None,</span>
<span class="sd">        the corresponding entries in the output list will be ``None``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            The value to use for invalid entries. Default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        result : list</span>
<span class="sd">            The Python list representation of the masked array.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; x.tolist()</span>
<span class="sd">        [[1, None, 3], [None, 5, None], [7, None, 9]]</span>
<span class="sd">        &gt;&gt;&gt; x.tolist(-999)</span>
<span class="sd">        [[1, -999, 3], [-999, 5, -999], [7, -999, 9]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="c1"># No mask ? Just return .data.tolist ?</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Explicit fill_value: fill the array and get the list</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Structured array.</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
        <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">astype</span><span class="p">([(</span><span class="n">_</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">names</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">_mask</span><span class="p">[</span><span class="n">n</span><span class="p">]]</span> <span class="o">=</span> <span class="bp">None</span>
            <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="c1"># Standard arrays.</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span>
        <span class="c1"># Set temps to save time when dealing w/ marrays.</span>
        <span class="n">inishape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="n">result</span><span class="p">[</span><span class="n">_mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">inishape</span>
        <span class="k">return</span> <span class="n">result</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="MaskedArray.tostring"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.tostring.html#numpy.ma.MaskedArray.tostring">[docs]</a>    <span class="k">def</span> <span class="nf">tostring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function is a compatibility alias for tobytes. Despite its name it</span>
<span class="sd">        returns bytes not strings.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.tobytes"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.tobytes.html#numpy.ma.MaskedArray.tobytes">[docs]</a>    <span class="k">def</span> <span class="nf">tobytes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the array data as a string containing the raw bytes in the array.</span>

<span class="sd">        The array is filled with a fill value before the string conversion.</span>

<span class="sd">        .. versionadded:: 1.9.0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            Value used to fill in the masked values. Deafult is None, in which</span>
<span class="sd">            case `MaskedArray.fill_value` is used.</span>
<span class="sd">        order : {&#39;C&#39;,&#39;F&#39;,&#39;A&#39;}, optional</span>
<span class="sd">            Order of the data item in the copy. Default is &#39;C&#39;.</span>

<span class="sd">            - &#39;C&#39;   -- C order (row major).</span>
<span class="sd">            - &#39;F&#39;   -- Fortran order (column major).</span>
<span class="sd">            - &#39;A&#39;   -- Any, current order of array.</span>
<span class="sd">            - None  -- Same as &#39;A&#39;.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ndarray.tobytes</span>
<span class="sd">        tolist, tofile</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        As for `ndarray.tobytes`, information about the shape, dtype, etc.,</span>
<span class="sd">        but also about `fill_value`, will be lost.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])</span>
<span class="sd">        &gt;&gt;&gt; x.tobytes()</span>
<span class="sd">        &#39;\\x01\\x00\\x00\\x00?B\\x0f\\x00?B\\x0f\\x00\\x04\\x00\\x00\\x00&#39;</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.tofile"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.tofile.html#numpy.ma.MaskedArray.tofile">[docs]</a>    <span class="k">def</span> <span class="nf">tofile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save a masked array to a file in binary format.</span>

<span class="sd">        .. warning::</span>
<span class="sd">          This function is not implemented yet.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            When `tofile` is called.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;MaskedArray.tofile() not implemented yet.&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="MaskedArray.toflex"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.toflex.html#numpy.ma.MaskedArray.toflex">[docs]</a>    <span class="k">def</span> <span class="nf">toflex</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transforms a masked array into a flexible-type array.</span>

<span class="sd">        The flexible type array that is returned will have two fields:</span>

<span class="sd">        * the ``_data`` field stores the ``_data`` part of the array.</span>
<span class="sd">        * the ``_mask`` field stores the ``_mask`` part of the array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        record : ndarray</span>
<span class="sd">            A new flexible-type `ndarray` with two fields: the first element</span>
<span class="sd">            containing a value, the second element containing the corresponding</span>
<span class="sd">            mask boolean. The returned record shape matches self.shape.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        A side-effect of transforming a masked array into a flexible `ndarray` is</span>
<span class="sd">        that meta information (``fill_value``, ...) will be lost.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)</span>
<span class="sd">        &gt;&gt;&gt; print x</span>
<span class="sd">        [[1 -- 3]</span>
<span class="sd">         [-- 5 --]</span>
<span class="sd">         [7 -- 9]]</span>
<span class="sd">        &gt;&gt;&gt; print x.toflex()</span>
<span class="sd">        [[(1, False) (2, True) (3, False)]</span>
<span class="sd">         [(4, True) (5, False) (6, True)]</span>
<span class="sd">         [(7, False) (8, True) (9, False)]]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the basic dtype.</span>
        <span class="n">ddtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># Make sure we have a mask</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">ddtype</span><span class="p">)</span>
        <span class="c1"># And get its dtype</span>
        <span class="n">mdtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">record</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;_data&#39;</span><span class="p">,</span> <span class="n">ddtype</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;_mask&#39;</span><span class="p">,</span> <span class="n">mdtype</span><span class="p">)])</span>
        <span class="n">record</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">record</span><span class="p">[</span><span class="s1">&#39;_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">return</span> <span class="n">record</span></div>
    <span class="n">torecords</span> <span class="o">=</span> <span class="n">toflex</span>

    <span class="c1"># Pickling</span>
<div class="viewcode-block" id="MaskedArray.__getstate__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__getstate__.html#numpy.ma.MaskedArray.__getstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return the internal state of the masked array, for pickling</span>
<span class="sd">        purposes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cf</span> <span class="o">=</span> <span class="s1">&#39;CF&#39;</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span><span class="p">]</span>
        <span class="n">state</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">fnc</span><span class="p">,</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">cf</span><span class="p">),</span>
                 <span class="c1"># self._data.tolist(),</span>
                 <span class="n">getmaskarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">tobytes</span><span class="p">(</span><span class="n">cf</span><span class="p">),</span>
                 <span class="c1"># getmaskarray(self).tolist(),</span>
                 <span class="bp">self</span><span class="o">.</span><span class="n">_fill_value</span><span class="p">,</span>
                 <span class="p">)</span>
        <span class="k">return</span> <span class="n">state</span></div>

<div class="viewcode-block" id="MaskedArray.__setstate__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__setstate__.html#numpy.ma.MaskedArray.__setstate__">[docs]</a>    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Restore the internal state of the masked array, for</span>
<span class="sd">        pickling purposes.  ``state`` is typically the output of the</span>
<span class="sd">        ``__getstate__`` output, and is a 5-tuple:</span>

<span class="sd">        - class name</span>
<span class="sd">        - a tuple giving the shape of the data</span>
<span class="sd">        - a typecode for the data</span>
<span class="sd">        - a binary string for the data</span>
<span class="sd">        - a binary string for the mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">shp</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">isf</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">msk</span><span class="p">,</span> <span class="n">flv</span><span class="p">)</span> <span class="o">=</span> <span class="n">state</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">((</span><span class="n">shp</span><span class="p">,</span> <span class="n">typ</span><span class="p">,</span> <span class="n">isf</span><span class="p">,</span> <span class="n">raw</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">((</span><span class="n">shp</span><span class="p">,</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">typ</span><span class="p">),</span> <span class="n">isf</span><span class="p">,</span> <span class="n">msk</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">flv</span></div>

<div class="viewcode-block" id="MaskedArray.__reduce__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__reduce__.html#numpy.ma.MaskedArray.__reduce__">[docs]</a>    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return a 3-tuple for pickling a MaskedArray.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">_mareconstruct</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_baseclass</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,),</span> <span class="s1">&#39;b&#39;</span><span class="p">,),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">())</span></div>

<div class="viewcode-block" id="MaskedArray.__deepcopy__"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.MaskedArray.__deepcopy__.html#numpy.ma.MaskedArray.__deepcopy__">[docs]</a>    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
        <span class="n">copied</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">memo</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">memo</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">memo</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">)]</span> <span class="o">=</span> <span class="n">copied</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__dict__</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">copied</span><span class="o">.</span><span class="n">__dict__</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">memo</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copied</span></div></div>


<span class="k">def</span> <span class="nf">_mareconstruct</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">baseclass</span><span class="p">,</span> <span class="n">baseshape</span><span class="p">,</span> <span class="n">basetype</span><span class="p">,):</span>
    <span class="sd">&quot;&quot;&quot;Internal function that builds a new MaskedArray from the</span>
<span class="sd">    information stored in a pickle.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">baseclass</span><span class="p">,</span> <span class="n">baseshape</span><span class="p">,</span> <span class="n">basetype</span><span class="p">)</span>
    <span class="n">_mask</span> <span class="o">=</span> <span class="n">ndarray</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">baseshape</span><span class="p">,</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">basetype</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">subtype</span><span class="o">.</span><span class="n">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">_data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">_mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">basetype</span><span class="p">,)</span>


<span class="k">class</span> <span class="nc">mvoid</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fake a &#39;void&#39; object to use for masked array with structured dtypes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
                <span class="n">hardmask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">_data</span> <span class="o">=</span> <span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">_data</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="n">hardmask</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">):</span>
                <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Mask is already a 0D array</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">void</span><span class="p">(</span><span class="n">mask</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="c1"># Transform the mask to a void</span>
                    <span class="n">mdtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                    <span class="n">_data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)[()]</span>
        <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">_data</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">fill_value</span>
        <span class="k">return</span> <span class="n">_data</span>

    <span class="k">def</span> <span class="nf">_get_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Make sure that the _data part is a np.void</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)[()]</span>

    <span class="n">_data</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">fget</span><span class="o">=</span><span class="n">_get_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the index.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">m</span><span class="p">[</span><span class="n">indx</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indx</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">|=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;_mask&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s2">&quot;_mask&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">m</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__str__</span><span class="p">()</span>
        <span class="n">printopt</span> <span class="o">=</span> <span class="n">masked_print_option</span>
        <span class="n">rdtype</span> <span class="o">=</span> <span class="n">_recursive_make_descr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="s2">&quot;O&quot;</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">rdtype</span><span class="p">)</span>
        <span class="n">_recursive_printoption</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">printopt</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="n">__repr__</span> <span class="o">=</span> <span class="n">__str__</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Defines an iterator for mvoid&quot;</span>
        <span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">_data</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">_data</span><span class="p">,</span> <span class="n">_mask</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">masked</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">__len__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">filled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a copy with masked fields filled with a given value.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fill_value : scalar, optional</span>
<span class="sd">            The value to use for invalid entries (None by default).</span>
<span class="sd">            If None, the `fill_value` attribute is used instead.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        filled_void</span>
<span class="sd">            A `np.void` object</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        MaskedArray.filled</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">fill_value</span><span class="p">)[()]</span>

    <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transforms the mvoid object into a tuple.</span>

<span class="sd">    Masked fields are replaced by None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    returned_tuple</span>
<span class="sd">        Tuple of fields</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_mask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span>
        <span class="k">if</span> <span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mask</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># .item() makes sure we return a standard Python object</span>
                <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">item</span><span class="p">())</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>


<span class="c1">##############################################################################</span>
<span class="c1">#                                Shortcuts                                   #</span>
<span class="c1">##############################################################################</span>


<span class="k">def</span> <span class="nf">isMaskedArray</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Test whether input is an instance of MaskedArray.</span>

<span class="sd">    This function returns True if `x` is an instance of MaskedArray</span>
<span class="sd">    and returns False otherwise.  Any object is accepted as input.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : object</span>
<span class="sd">        Object to test.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : bool</span>
<span class="sd">        True if `x` is a MaskedArray.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    isMA : Alias to isMaskedArray.</span>
<span class="sd">    isarray : Alias to isMaskedArray.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.eye(3, 3)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 1.,  0.,  0.],</span>
<span class="sd">           [ 0.,  1.,  0.],</span>
<span class="sd">           [ 0.,  0.,  1.]])</span>
<span class="sd">    &gt;&gt;&gt; m = ma.masked_values(a, 0)</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1.0 -- --]</span>
<span class="sd">     [-- 1.0 --]</span>
<span class="sd">     [-- -- 1.0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True  True]</span>
<span class="sd">     [ True False  True]</span>
<span class="sd">     [ True  True False]],</span>
<span class="sd">          fill_value=0.0)</span>
<span class="sd">    &gt;&gt;&gt; ma.isMaskedArray(a)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.isMaskedArray(m)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ma.isMaskedArray([0, 1, 2])</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">)</span>


<span class="n">isarray</span> <span class="o">=</span> <span class="n">isMaskedArray</span>
<span class="n">isMA</span> <span class="o">=</span> <span class="n">isMaskedArray</span>  <span class="c1"># backward compatibility</span>


<span class="k">class</span> <span class="nc">MaskedConstant</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">):</span>
    <span class="c1"># We define the masked singleton as a float for higher precedence.</span>
    <span class="c1"># Note that it can be tricky sometimes w/ type comparison</span>
    <span class="n">_data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mf">0.</span><span class="p">)</span>
    <span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
    <span class="n">_baseclass</span> <span class="o">=</span> <span class="n">ndarray</span>

    <span class="k">def</span> <span class="nf">__new__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__array_finalize__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span>

    <span class="k">def</span> <span class="nf">__array_wrap__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">masked_print_option</span><span class="o">.</span><span class="n">_display</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;masked&#39;</span>

    <span class="k">def</span> <span class="nf">flatten</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="p">[</span><span class="bp">True</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">__reduce__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Override of MaskedArray&#39;s __reduce__.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__class__</span><span class="p">,</span> <span class="p">())</span>


<span class="n">masked</span> <span class="o">=</span> <span class="n">masked_singleton</span> <span class="o">=</span> <span class="n">MaskedConstant</span><span class="p">()</span>
<span class="n">masked_array</span> <span class="o">=</span> <span class="n">MaskedArray</span>


<div class="viewcode-block" id="array"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.array.html#numpy.ma.array">[docs]</a><span class="k">def</span> <span class="nf">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
          <span class="n">mask</span><span class="o">=</span><span class="n">nomask</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
          <span class="n">keep_mask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">hard_mask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
          <span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shortcut to MaskedArray.</span>

<span class="sd">    The options are in a different order for convenience and backwards</span>
<span class="sd">    compatibility.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># we should try to put &#39;order&#39; somewhere</span>
    <span class="k">return</span> <span class="n">MaskedArray</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="n">copy</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="n">subok</span><span class="p">,</span>
                       <span class="n">keep_mask</span><span class="o">=</span><span class="n">keep_mask</span><span class="p">,</span> <span class="n">hard_mask</span><span class="o">=</span><span class="n">hard_mask</span><span class="p">,</span>
                       <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">ndmin</span><span class="o">=</span><span class="n">ndmin</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="n">shrink</span><span class="p">)</span></div>
<span class="n">array</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">masked_array</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="is_masked"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.is_masked.html#numpy.ma.is_masked">[docs]</a><span class="k">def</span> <span class="nf">is_masked</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine whether input has masked values.</span>

<span class="sd">    Accepts any object as input, but always returns False unless the</span>
<span class="sd">    input is a MaskedArray containing masked values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : array_like</span>
<span class="sd">        Array to check for masked values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : bool</span>
<span class="sd">        True if `x` is a MaskedArray with masked values, False otherwise.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 0)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [-- 1 -- 2 3],</span>
<span class="sd">          mask = [ True False  True False False],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; x = ma.masked_equal([0, 1, 0, 2, 3], 42)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [0 1 0 2 3],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    False</span>

<span class="sd">    Always returns False if `x` isn&#39;t a MaskedArray.</span>

<span class="sd">    &gt;&gt;&gt; x = [False, True, False]</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; x = &#39;a string&#39;</span>
<span class="sd">    &gt;&gt;&gt; ma.is_masked(x)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="k">elif</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span></div>


<span class="c1">##############################################################################</span>
<span class="c1">#                             Extrema functions                              #</span>
<span class="c1">##############################################################################</span>


<span class="k">class</span> <span class="nc">_extrema_operation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic class for maximum/minimum functions.</span>

<span class="sd">    .. note::</span>
<span class="sd">      This is the base class for `_maximum_operation` and</span>
<span class="sd">      `_minimum_operation`.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s2">&quot;Executes the call behavior.&quot;</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compare</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="s2">&quot;Reduce target along the given axis.&quot;</span>
        <span class="n">target</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">kargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;axis&#39;</span><span class="p">:</span> <span class="n">axis</span><span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">):</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ufunc</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">target</span> <span class="o">=</span> <span class="n">target</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fill_value_func</span><span class="p">(</span><span class="n">target</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">))</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ufunc</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">):</span>
                <span class="n">t</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
            <span class="k">elif</span> <span class="n">m</span><span class="p">:</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">masked</span>
        <span class="k">return</span> <span class="n">t</span>

    <span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="s2">&quot;Return the function applied to the outer product of a and b.&quot;</span>
        <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">nomask</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ma</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">mb</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">logical_or</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ufunc</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">_minimum_operation</span><span class="p">(</span><span class="n">_extrema_operation</span><span class="p">):</span>

    <span class="s2">&quot;Object to calculate minima&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;minimum(a, b) or minimum(a)</span>
<span class="sd">In one argument case, returns the scalar minimum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ufunc</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">minimum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">afunc</span> <span class="o">=</span> <span class="n">amin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare</span> <span class="o">=</span> <span class="n">less</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value_func</span> <span class="o">=</span> <span class="n">minimum_fill_value</span>


<span class="k">class</span> <span class="nc">_maximum_operation</span><span class="p">(</span><span class="n">_extrema_operation</span><span class="p">):</span>

    <span class="s2">&quot;Object to calculate maxima&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;maximum(a, b) or maximum(a)</span>
<span class="sd">           In one argument case returns the scalar maximum.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ufunc</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">maximum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">afunc</span> <span class="o">=</span> <span class="n">amax</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare</span> <span class="o">=</span> <span class="n">greater</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill_value_func</span> <span class="o">=</span> <span class="n">maximum_fill_value</span>


<div class="viewcode-block" id="min"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.min.html#numpy.ma.min">[docs]</a><span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># If obj doesn&#39;t have a min method or if the method doesn&#39;t accept</span>
        <span class="c1"># a fill_value argument</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>
<span class="nb">min</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="max"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.max.html#numpy.ma.max">[docs]</a><span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># If obj doesn&#39;t have a max method, or if the method doesn&#39;t accept</span>
        <span class="c1"># a fill_value argument</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>
<span class="nb">max</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="ptp"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.ptp.html#numpy.ma.ptp">[docs]</a><span class="k">def</span> <span class="nf">ptp</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a.ptp(axis=None) =  a.max(axis) - a.min(axis)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="c1"># If obj doesn&#39;t have a ptp method or if the method doesn&#39;t accept</span>
        <span class="c1"># a fill_value argument</span>
        <span class="k">return</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">ptp</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span></div>
<span class="n">ptp</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">ptp</span><span class="o">.</span><span class="n">__doc__</span>


<span class="c1">##############################################################################</span>
<span class="c1">#           Definition of functions from the corresponding methods           #</span>
<span class="c1">##############################################################################</span>


<span class="k">class</span> <span class="nc">_frommethod</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Define functions from existing MaskedArray methods.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    methodname : str</span>
<span class="sd">        Name of the method to transform.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">methodname</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">methodname</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getdoc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reversed</span> <span class="o">=</span> <span class="nb">reversed</span>

    <span class="k">def</span> <span class="nf">getdoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the doc of the function (from the doc of the method).&quot;</span>
        <span class="n">meth</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">or</span>\
            <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">signature</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span> <span class="o">+</span> <span class="n">get_object_signature</span><span class="p">(</span><span class="n">meth</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">meth</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;    </span><span class="si">%s</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span> <span class="o">%</span> <span class="p">(</span>
                <span class="n">signature</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">meth</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">reversed</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
            <span class="n">arr</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">arr</span>
        <span class="c1"># Get the method from the array (if possible)</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__name__</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># Still here ? Then a is not a MaskedArray</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>
        <span class="c1"># Still here ? OK, let&#39;s call the corresponding np function</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">method_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span>


<span class="nb">all</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span>
<span class="n">anomalies</span> <span class="o">=</span> <span class="n">anom</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;anom&#39;</span><span class="p">)</span>
<span class="nb">any</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;any&#39;</span><span class="p">)</span>
<span class="n">compress</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;compress&#39;</span><span class="p">,</span> <span class="nb">reversed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="n">cumprod</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;cumprod&#39;</span><span class="p">)</span>
<span class="n">cumsum</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;cumsum&#39;</span><span class="p">)</span>
<span class="n">copy</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;copy&#39;</span><span class="p">)</span>
<span class="n">diagonal</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;diagonal&#39;</span><span class="p">)</span>
<span class="n">harden_mask</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;harden_mask&#39;</span><span class="p">)</span>
<span class="n">ids</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;ids&#39;</span><span class="p">)</span>
<span class="n">maximum</span> <span class="o">=</span> <span class="n">_maximum_operation</span><span class="p">()</span>
<span class="n">mean</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;mean&#39;</span><span class="p">)</span>
<span class="n">minimum</span> <span class="o">=</span> <span class="n">_minimum_operation</span><span class="p">()</span>
<span class="n">nonzero</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;nonzero&#39;</span><span class="p">)</span>
<span class="n">prod</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;prod&#39;</span><span class="p">)</span>
<span class="n">product</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;prod&#39;</span><span class="p">)</span>
<span class="n">ravel</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;ravel&#39;</span><span class="p">)</span>
<span class="n">repeat</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;repeat&#39;</span><span class="p">)</span>
<span class="n">shrink_mask</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;shrink_mask&#39;</span><span class="p">)</span>
<span class="n">soften_mask</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;soften_mask&#39;</span><span class="p">)</span>
<span class="n">std</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;std&#39;</span><span class="p">)</span>
<span class="nb">sum</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span>
<span class="n">swapaxes</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;swapaxes&#39;</span><span class="p">)</span>
<span class="c1">#take = _frommethod(&#39;take&#39;)</span>
<span class="n">trace</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;trace&#39;</span><span class="p">)</span>
<span class="n">var</span> <span class="o">=</span> <span class="n">_frommethod</span><span class="p">(</span><span class="s1">&#39;var&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">take</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<div class="viewcode-block" id="power"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.power.html#numpy.ma.power">[docs]</a><span class="k">def</span> <span class="nf">power</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">third</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns element-wise base array raised to power from second array.</span>

<span class="sd">    This is the masked array version of `numpy.power`. For details see</span>
<span class="sd">    `numpy.power`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.power</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The *out* argument to `numpy.power` is not supported, `third` has to be</span>
<span class="sd">    None.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">third</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">MaskError</span><span class="p">(</span><span class="s2">&quot;3-argument power not supported.&quot;</span><span class="p">)</span>
    <span class="c1"># Get the masks</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">ma</span><span class="p">,</span> <span class="n">mb</span><span class="p">)</span>
    <span class="c1"># Get the rawdata</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="c1"># Get the type of the result (so that we preserve subclasses)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">basetype</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">basetype</span> <span class="o">=</span> <span class="n">MaskedArray</span>
    <span class="c1"># Get the result and view it as a (subclass of) MaskedArray</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">fa</span><span class="p">,</span> <span class="n">umath</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">basetype</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">_update_from</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># Find where we&#39;re in trouble w/ NaNs and Infs</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)))</span>
    <span class="c1"># Add the initial mask</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">invalid</span><span class="p">)</span>
    <span class="c1"># Fix the invalid parts</span>
    <span class="k">if</span> <span class="n">invalid</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">masked</span>
        <span class="k">elif</span> <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">invalid</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">invalid</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span>
    <span class="k">return</span> <span class="n">result</span></div>


<div class="viewcode-block" id="argsort"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.argsort.html#numpy.ma.argsort">[docs]</a><span class="k">def</span> <span class="nf">argsort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s2">&quot;Function version of the eponymous method.&quot;</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span></div>
<span class="n">argsort</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">argsort</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="argmin"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.argmin.html#numpy.ma.argmin">[docs]</a><span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s2">&quot;Function version of the eponymous method.&quot;</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>
<span class="n">argmin</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">argmin</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="argmax"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.argmax.html#numpy.ma.argmax">[docs]</a><span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s2">&quot;Function version of the eponymous method.&quot;</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">fill_value</span> <span class="o">=</span> <span class="n">default_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fill_value</span> <span class="o">=</span> <span class="o">-</span><span class="n">fill_value</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">fill_value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>
<span class="n">argmax</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">argmax</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="sort"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.sort.html#numpy.ma.sort">[docs]</a><span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;quicksort&#39;</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">endwith</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s2">&quot;Function version of the eponymous method.&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">fill_value</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">endwith</span><span class="p">:</span>
            <span class="c1"># nan &gt; inf</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
                <span class="n">filler</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">filler</span> <span class="o">=</span> <span class="n">minimum_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filler</span> <span class="o">=</span> <span class="n">maximum_fill_value</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filler</span> <span class="o">=</span> <span class="n">fill_value</span>

    <span class="n">sindx</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">filler</span><span class="p">)</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>

    <span class="c1"># save meshgrid memory for 1d arrays</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">sindx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                           <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">indx</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">sindx</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">indx</span><span class="p">]</span></div>
<span class="n">sort</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">sort</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="compressed"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.compressed.html#numpy.ma.compressed">[docs]</a><span class="k">def</span> <span class="nf">compressed</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return all the non-masked data as a 1-D array.</span>

<span class="sd">    This function is equivalent to calling the &quot;compressed&quot; method of a</span>
<span class="sd">    `MaskedArray`, see `MaskedArray.compressed` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.compressed</span>
<span class="sd">        Equivalent method.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">asanyarray</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">compressed</span><span class="p">()</span></div>


<div class="viewcode-block" id="concatenate"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.concatenate.html#numpy.ma.concatenate">[docs]</a><span class="k">def</span> <span class="nf">concatenate</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Concatenate a sequence of arrays along the given axis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    arrays : sequence of array_like</span>
<span class="sd">        The arrays must have the same shape, except in the dimension</span>
<span class="sd">        corresponding to `axis` (the first, by default).</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which the arrays will be joined. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The concatenated array with any masked entries preserved.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.concatenate : Equivalent function in the top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.arange(3)</span>
<span class="sd">    &gt;&gt;&gt; a[1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; b = ma.arange(2, 5)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [0 -- 2],</span>
<span class="sd">                 mask = [False  True False],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    masked_array(data = [2 3 4],</span>
<span class="sd">                 mask = False,</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.concatenate([a, b])</span>
<span class="sd">    masked_array(data = [0 -- 2 2 3 4],</span>
<span class="sd">                 mask = [False  True False False False False],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
    <span class="n">rcls</span> <span class="o">=</span> <span class="n">get_masked_subclass</span><span class="p">(</span><span class="o">*</span><span class="n">arrays</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">rcls</span><span class="p">)</span>
    <span class="c1"># Check whether one of the arrays has a non-empty mask.</span>
    <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">data</span>
    <span class="c1"># OK, so we have to concatenate the masks</span>
    <span class="n">dm</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span>
    <span class="c1"># If we decide to keep a &#39;_shrinkmask&#39; option, we want to check that</span>
    <span class="c1"># all of them are True, and then check for dm.any()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">dm</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">fields</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dm</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">nomask</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">data</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">data</span></div>


<div class="viewcode-block" id="count"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.count.html#numpy.ma.count">[docs]</a><span class="k">def</span> <span class="nf">count</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span></div>
<span class="n">count</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">MaskedArray</span><span class="o">.</span><span class="n">count</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="diag"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.diag.html#numpy.ma.diag">[docs]</a><span class="k">def</span> <span class="nf">diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract a diagonal or construct a diagonal array.</span>

<span class="sd">    This function is the equivalent of `numpy.diag` that takes masked</span>
<span class="sd">    values into account, see `numpy.diag` for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.diag : Equivalent function for ndarrays.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="expand_dims"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.expand_dims.html#numpy.ma.expand_dims">[docs]</a><span class="k">def</span> <span class="nf">expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expand the shape of an array.</span>

<span class="sd">    Expands the shape of the array by including a new axis before the one</span>
<span class="sd">    specified by the `axis` parameter. This function behaves the same as</span>
<span class="sd">    `numpy.expand_dims` but preserves masked elements.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.expand_dims : Equivalent function in top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = ma.array([1, 2, 4])</span>
<span class="sd">    &gt;&gt;&gt; x[1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data = [1 -- 4],</span>
<span class="sd">                 mask = [False  True False],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; np.expand_dims(x, axis=0)</span>
<span class="sd">    array([[1, 2, 4]])</span>
<span class="sd">    &gt;&gt;&gt; ma.expand_dims(x, axis=0)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 -- 4]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    The same result can be achieved using slicing syntax with `np.newaxis`.</span>

<span class="sd">    &gt;&gt;&gt; x[np.newaxis, :]</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 -- 4]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">n_expand_dims</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">new_shape</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">()</span>
        <span class="n">result</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">new_shape</span>
        <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">new_shape</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">left_shift</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift the bits of an integer to the left.</span>

<span class="sd">    This is the masked array version of `numpy.left_shift`, for details</span>
<span class="sd">    see that function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.left_shift</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">left_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">right_shift</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Shift the bits of an integer to the right.</span>

<span class="sd">    This is the masked array version of `numpy.right_shift`, for details</span>
<span class="sd">    see that function.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.right_shift</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">right_shift</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">put</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set storage-indexed locations to corresponding values.</span>

<span class="sd">    This function is equivalent to `MaskedArray.put`, see that method</span>
<span class="sd">    for details.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.put</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, the order of arguments is different</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">narray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">putmask</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>  <span class="c1"># , mode=&#39;raise&#39;):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Changes elements of an array based on conditional and input values.</span>

<span class="sd">    This is the masked array version of `numpy.putmask`, for details see</span>
<span class="sd">    `numpy.putmask`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.putmask</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Using a masked array as `values` will **not** transform a `ndarray` into</span>
<span class="sd">    a `MaskedArray`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, the order of arguments is different</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="p">(</span><span class="n">valdata</span><span class="p">,</span> <span class="n">valmask</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">values</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">a</span><span class="o">.</span><span class="n">_sharedmask</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="n">a</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">make_mask_none</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">valmask</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">a</span><span class="o">.</span><span class="n">_hardmask</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valmask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">valmask</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
            <span class="n">a</span><span class="o">.</span><span class="n">mask</span> <span class="o">|=</span> <span class="n">m</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">valmask</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
            <span class="n">valmask</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">valmask</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">valdata</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span>


<div class="viewcode-block" id="transpose"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.transpose.html#numpy.ma.transpose">[docs]</a><span class="k">def</span> <span class="nf">transpose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Permute the dimensions of an array.</span>

<span class="sd">    This function is exactly equivalent to `numpy.transpose`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.transpose : Equivalent function in top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; x = ma.arange(4).reshape((2,2))</span>
<span class="sd">    &gt;&gt;&gt; x[1, 1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt;&gt; x</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 1]</span>
<span class="sd">     [2 --]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False  True]],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.transpose(x)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 2]</span>
<span class="sd">     [1 --]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False  True]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, as &#39;transpose&#39; doesn&#39;t take keywords</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">narray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span></div>


<div class="viewcode-block" id="reshape"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.reshape.html#numpy.ma.reshape">[docs]</a><span class="k">def</span> <span class="nf">reshape</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an array containing the same data with a new shape.</span>

<span class="sd">    Refer to `MaskedArray.reshape` for full documentation.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.reshape : equivalent function</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use &#39;frommethod&#39;, it whine about some parameters. Dmmit.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">_tmp</span> <span class="o">=</span> <span class="n">narray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">new_shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_tmp</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span></div>


<div class="viewcode-block" id="resize"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.resize.html#numpy.ma.resize">[docs]</a><span class="k">def</span> <span class="nf">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new masked array with the specified size and shape.</span>

<span class="sd">    This is the masked equivalent of the `numpy.resize` function. The new</span>
<span class="sd">    array is filled with repeated copies of `x` (in the order that the</span>
<span class="sd">    data are stored in memory). If `x` is masked, the new array will be</span>
<span class="sd">    masked, and the new mask will be a repetition of the old one.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.resize : Equivalent function in the top level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([[1, 2] ,[3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; a[0, 1] = ma.masked</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 --]</span>
<span class="sd">     [3 4]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True]</span>
<span class="sd">     [False False]],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; np.resize(a, (3, 3))</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 1, 2],</span>
<span class="sd">           [3, 4, 1]])</span>
<span class="sd">    &gt;&gt;&gt; ma.resize(a, (3, 3))</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 -- 3]</span>
<span class="sd">     [4 1 --]</span>
<span class="sd">     [3 4 1]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]</span>
<span class="sd">     [False False  True]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    A MaskedArray is always returned, regardless of the input type.</span>

<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2] ,[3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; ma.resize(a, (3, 3))</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[1 2 3]</span>
<span class="sd">     [4 1 2]</span>
<span class="sd">     [3 4 1]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     False,</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We can&#39;t use _frommethods here, as N.resize is notoriously whiny.</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">resize</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">new_shape</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
        <span class="n">result</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">result</span></div>


<span class="k">def</span> <span class="nf">rank</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    maskedarray version of the numpy function.</span>

<span class="sd">    .. note::</span>
<span class="sd">        Deprecated since 1.10.0</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># 2015-04-12, 1.10.0</span>
    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
        <span class="s2">&quot;`rank` is deprecated; use the `ndim` function instead. &quot;</span><span class="p">,</span>
        <span class="n">np</span><span class="o">.</span><span class="n">VisibleDeprecationWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

<span class="n">rank</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rank</span><span class="o">.</span><span class="n">__doc__</span>


<span class="k">def</span> <span class="nf">ndim</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span> 
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    maskedarray version of the numpy function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

<span class="n">ndim</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndim</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="shape"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.shape.html#numpy.ma.shape">[docs]</a><span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="s2">&quot;maskedarray version of the numpy function.&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span></div>
<span class="n">shape</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">__doc__</span>


<div class="viewcode-block" id="size"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.size.html#numpy.ma.size">[docs]</a><span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="s2">&quot;maskedarray version of the numpy function.&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span></div>
<span class="n">size</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">__doc__</span>


<span class="c1">##############################################################################</span>
<span class="c1">#                            Extra functions                                 #</span>
<span class="c1">##############################################################################</span>


<div class="viewcode-block" id="where"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.where.html#numpy.ma.where">[docs]</a><span class="k">def</span> <span class="nf">where</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">_NoValue</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">_NoValue</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a masked array with elements from x or y, depending on condition.</span>

<span class="sd">    Returns a masked array, shaped like condition, where the elements</span>
<span class="sd">    are from `x` when `condition` is True, and from `y` otherwise.</span>
<span class="sd">    If neither `x` nor `y` are given, the function returns a tuple of</span>
<span class="sd">    indices where `condition` is True (the result of</span>
<span class="sd">    ``condition.nonzero()``).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    condition : array_like, bool</span>
<span class="sd">        The condition to meet. For each True element, yield the corresponding</span>
<span class="sd">        element from `x`, otherwise from `y`.</span>
<span class="sd">    x, y : array_like, optional</span>
<span class="sd">        Values from which to choose. `x` and `y` need to have the same shape</span>
<span class="sd">        as condition, or be broadcast-able to that shape.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray or tuple of ndarrays</span>
<span class="sd">        The resulting masked array if `x` and `y` were given, otherwise</span>
<span class="sd">        the result of ``condition.nonzero()``.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.where : Equivalent function in the top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],</span>
<span class="sd">    ...                                                    [1, 0, 1],</span>
<span class="sd">    ...                                                    [0, 1, 0]])</span>
<span class="sd">    &gt;&gt;&gt; print x</span>
<span class="sd">    [[0.0 -- 2.0]</span>
<span class="sd">     [-- 4.0 --]</span>
<span class="sd">     [6.0 -- 8.0]]</span>
<span class="sd">    &gt;&gt;&gt; np.ma.where(x &gt; 5)    # return the indices where x &gt; 5</span>
<span class="sd">    (array([2, 2]), array([0, 2]))</span>

<span class="sd">    &gt;&gt;&gt; print np.ma.where(x &gt; 5, x, -3.1416)</span>
<span class="sd">    [[-3.1416 -- -3.1416]</span>
<span class="sd">     [-- -3.1416 --]</span>
<span class="sd">     [6.0 -- 8.0]]</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">missing</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="ow">is</span> <span class="n">_NoValue</span><span class="p">,</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">_NoValue</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide both &#39;x&#39; and &#39;y&#39; or neither.&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">missing</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">filled</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

    <span class="c1"># Both x and y are provided</span>

    <span class="c1"># Get the condition</span>
    <span class="n">fc</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">MaskType</span><span class="p">)</span>
    <span class="n">notfc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">fc</span><span class="p">)</span>

    <span class="c1"># Get the data</span>
    <span class="n">xv</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">yv</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
        <span class="n">ndtype</span> <span class="o">=</span> <span class="n">yv</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">elif</span> <span class="n">y</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
        <span class="n">ndtype</span> <span class="o">=</span> <span class="n">xv</span><span class="o">.</span><span class="n">dtype</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ndtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">find_common_type</span><span class="p">([</span><span class="n">xv</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">yv</span><span class="o">.</span><span class="n">dtype</span><span class="p">],</span> <span class="p">[])</span>

    <span class="c1"># Construct an empty array and fill it</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">fc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ndtype</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">xv</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ndtype</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">fc</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">yv</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">ndtype</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">notfc</span><span class="p">)</span>

    <span class="c1"># Create an empty mask and fill it</span>
    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">fc</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">MaskType</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">fc</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">getmask</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">where</span><span class="o">=</span><span class="n">notfc</span><span class="p">)</span>
    <span class="n">mask</span> <span class="o">|=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">condition</span><span class="p">)</span>

    <span class="c1"># Use d._mask instead of d.mask to avoid copies</span>
    <span class="n">d</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">mask</span> <span class="k">if</span> <span class="n">mask</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="k">else</span> <span class="n">nomask</span>

    <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="choose"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.choose.html#numpy.ma.choose">[docs]</a><span class="k">def</span> <span class="nf">choose</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">choices</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;raise&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Use an index array to construct a new array from a set of choices.</span>

<span class="sd">    Given an array of integers and a set of n choice arrays, this method</span>
<span class="sd">    will create a new array that merges each of the choice arrays.  Where a</span>
<span class="sd">    value in `a` is i, the new array will have the value that choices[i]</span>
<span class="sd">    contains in the same place.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray of ints</span>
<span class="sd">        This array must contain integers in ``[0, n-1]``, where n is the</span>
<span class="sd">        number of choices.</span>
<span class="sd">    choices : sequence of arrays</span>
<span class="sd">        Choice arrays. The index array and all of the choices should be</span>
<span class="sd">        broadcastable to the same shape.</span>
<span class="sd">    out : array, optional</span>
<span class="sd">        If provided, the result will be inserted into this array. It should</span>
<span class="sd">        be of the appropriate shape and `dtype`.</span>
<span class="sd">    mode : {&#39;raise&#39;, &#39;wrap&#39;, &#39;clip&#39;}, optional</span>
<span class="sd">        Specifies how out-of-bounds indices will behave.</span>

<span class="sd">        * &#39;raise&#39; : raise an error</span>
<span class="sd">        * &#39;wrap&#39; : wrap around</span>
<span class="sd">        * &#39;clip&#39; : clip to the range</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    merged_array : array</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    choose : equivalent function</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; choice = np.array([[1,1,1], [2,2,2], [3,3,3]])</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([2, 1, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.choose(a, choice)</span>
<span class="sd">    masked_array(data = [3 2 1],</span>
<span class="sd">          mask = False,</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">fmask</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Returns the filled array, or True if masked.&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nmask</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="s2">&quot;Returns the mask, True if ``masked``, False if ``nomask``.&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="n">masked</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="c1"># Get the indices.</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Get the masks.</span>
    <span class="n">masks</span> <span class="o">=</span> <span class="p">[</span><span class="n">nmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>
    <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">fmask</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">choices</span><span class="p">]</span>
    <span class="c1"># Construct the mask</span>
    <span class="n">outputmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">masks</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">)</span>
    <span class="n">outputmask</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="n">mask_or</span><span class="p">(</span><span class="n">outputmask</span><span class="p">,</span> <span class="n">getmask</span><span class="p">(</span><span class="n">indices</span><span class="p">)),</span>
                           <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">shrink</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
    <span class="c1"># Get the choices.</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">choose</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">MaskedArray</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">outputmask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="n">d</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">outputmask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">d</span></div>


<span class="k">def</span> <span class="nf">round_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a copy of a, rounded to &#39;decimals&#39; places.</span>

<span class="sd">    When &#39;decimals&#39; is negative, it specifies the number of positions</span>
<span class="sd">    to the left of the decimal point.  The real and imaginary parts of</span>
<span class="sd">    complex numbers are rounded separately. Nothing is done if the</span>
<span class="sd">    array is not of float type and &#39;decimals&#39; is greater than or equal</span>
<span class="sd">    to 0.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    decimals : int</span>
<span class="sd">        Number of decimals to round to. May be negative.</span>
<span class="sd">    out : array_like</span>
<span class="sd">        Existing array to use for output.</span>
<span class="sd">        If not given, returns a default copy of a.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If out is given and does not have a mask attribute, the mask of a</span>
<span class="sd">    is lost!</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">round_</span><span class="p">(</span><span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">decimals</span><span class="p">,</span> <span class="n">out</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;_mask&#39;</span><span class="p">):</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
<span class="nb">round</span> <span class="o">=</span> <span class="n">round_</span>


<span class="c1"># Needed by dot, so move here from extras.py. It will still be exported</span>
<span class="c1"># from extras.py for compatibility.</span>
<div class="viewcode-block" id="mask_rowcols"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.mask_rowcols.html#numpy.ma.mask_rowcols">[docs]</a><span class="k">def</span> <span class="nf">mask_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mask rows and/or columns of a 2D array that contain masked values.</span>

<span class="sd">    Mask whole rows and/or columns of a 2D array that contain</span>
<span class="sd">    masked values.  The masking behavior is selected using the</span>
<span class="sd">    `axis` parameter.</span>

<span class="sd">      - If `axis` is None, rows *and* columns are masked.</span>
<span class="sd">      - If `axis` is 0, only rows are masked.</span>
<span class="sd">      - If `axis` is 1 or -1, only columns are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like, MaskedArray</span>
<span class="sd">        The array to mask.  If not a MaskedArray instance (or if no array</span>
<span class="sd">        elements are masked).  The result is a MaskedArray with `mask` set</span>
<span class="sd">        to `nomask` (False). Must be a 2D array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to perform the operation. If None, applies to a</span>
<span class="sd">        flattened version of the array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        A modified version of the input array, masked depending on the value</span>
<span class="sd">        of the `axis` parameter.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    NotImplementedError</span>
<span class="sd">        If input array `a` is not 2D.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mask_rows : Mask rows of a 2D array that contain masked values.</span>
<span class="sd">    mask_cols : Mask cols of a 2D array that contain masked values.</span>
<span class="sd">    masked_where : Mask where a condition is met.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The input array&#39;s mask is modified by this function.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = np.zeros((3, 3), dtype=np.int)</span>
<span class="sd">    &gt;&gt;&gt; a[1, 1] = 1</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[0, 0, 0],</span>
<span class="sd">           [0, 1, 0],</span>
<span class="sd">           [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_equal(a, 1)</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 0 0]</span>
<span class="sd">     [0 -- 0]</span>
<span class="sd">     [0 0 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False False False]</span>
<span class="sd">     [False  True False]</span>
<span class="sd">     [False False False]],</span>
<span class="sd">          fill_value=999999)</span>
<span class="sd">    &gt;&gt;&gt; ma.mask_rowcols(a)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 -- 0]</span>
<span class="sd">     [-- -- --]</span>
<span class="sd">     [0 -- 0]],</span>
<span class="sd">          mask =</span>
<span class="sd">     [[False  True False]</span>
<span class="sd">     [ True  True  True]</span>
<span class="sd">     [False  True False]],</span>
<span class="sd">          fill_value=999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s2">&quot;mask_rowcols works for 2D arrays only.&quot;</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># Nothing is masked: return a</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">m</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="k">return</span> <span class="n">a</span>
    <span class="n">maskedval</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
    <span class="n">a</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">_mask</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span><span class="p">:</span>
        <span class="n">a</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">maskedval</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">masked</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">a</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">maskedval</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">masked</span>
    <span class="k">return</span> <span class="n">a</span></div>


<span class="c1"># Include masked dot here to avoid import problems in getting it from</span>
<span class="c1"># extras.py. Note that it is not included in __all__, but rather exported</span>
<span class="c1"># from extras in order to avoid backward compatibility problems.</span>
<div class="viewcode-block" id="dot"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.dot.html#numpy.ma.dot">[docs]</a><span class="k">def</span> <span class="nf">dot</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the dot product of two arrays.</span>

<span class="sd">    This function is the equivalent of `numpy.dot` that takes masked values</span>
<span class="sd">    into account. Note that `strict` and `out` are in different position</span>
<span class="sd">    than in the method version. In order to maintain compatibility with the</span>
<span class="sd">    corresponding method, it is recommended that the optional arguments be</span>
<span class="sd">    treated as keyword only.  At some point that may be mandatory.</span>

<span class="sd">    .. note::</span>
<span class="sd">      Works only with 2-D arrays at the moment.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : masked_array_like</span>
<span class="sd">        Inputs arrays.</span>
<span class="sd">    strict : bool, optional</span>
<span class="sd">        Whether masked data are propagated (True) or set to 0 (False) for</span>
<span class="sd">        the computation. Default is False.  Propagating the mask means that</span>
<span class="sd">        if a masked value appears in a row or column, the whole row or</span>
<span class="sd">        column is considered masked.</span>
<span class="sd">    out : masked_array, optional</span>
<span class="sd">        Output argument. This must have the exact kind that would be returned</span>
<span class="sd">        if it was not used. In particular, it must have the right type, must be</span>
<span class="sd">        C-contiguous, and its dtype must be the dtype that would be returned</span>
<span class="sd">        for `dot(a,b)`. This is a performance feature. Therefore, if these</span>
<span class="sd">        conditions are not met, an exception is raised, instead of attempting</span>
<span class="sd">        to be flexible.</span>

<span class="sd">        .. versionadded:: 1.10.2</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.dot : Equivalent function for ndarrays.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.dot(a, b)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[21 26]</span>
<span class="sd">     [45 64]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False False]],</span>
<span class="sd">           fill_value = 999999)</span>
<span class="sd">    &gt;&gt;&gt; np.ma.dot(a, b, strict=True)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[-- --]</span>
<span class="sd">     [-- 64]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[ True  True]</span>
<span class="sd">     [ True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># !!!: Works only with 2D arrays. There should be a way to get it to run</span>
    <span class="c1"># with higher dimension</span>
    <span class="k">if</span> <span class="n">strict</span> <span class="ow">and</span> <span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">b</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">):</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">mask_rowcols</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">mask_rowcols</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">am</span> <span class="o">=</span> <span class="o">~</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">bm</span> <span class="o">=</span> <span class="o">~</span><span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">m</span> <span class="o">=</span> <span class="o">~</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">am</span><span class="p">,</span> <span class="n">bm</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">d</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">get_masked_subclass</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
        <span class="n">r</span><span class="o">.</span><span class="n">__setmask__</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">out</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">MaskType</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">am</span><span class="p">,</span> <span class="n">bm</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">_mask</span><span class="p">,</span> <span class="n">out</span><span class="o">.</span><span class="n">_mask</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="inner"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.inner.html#numpy.ma.inner">[docs]</a><span class="k">def</span> <span class="nf">inner</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the inner product of a and b for arrays of floating point types.</span>

<span class="sd">    Like the generic NumPy equivalent the product sum is over the last dimension</span>
<span class="sd">    of a and b.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The first argument is not conjugated.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fa</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fa</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fb</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">fb</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span></div>
<span class="n">inner</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doc_note</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">inner</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span>
                         <span class="s2">&quot;Masked values are replaced by 0.&quot;</span><span class="p">)</span>
<span class="n">innerproduct</span> <span class="o">=</span> <span class="n">inner</span>


<div class="viewcode-block" id="outer"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.outer.html#numpy.ma.outer">[docs]</a><span class="k">def</span> <span class="nf">outer</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="s2">&quot;maskedarray version of the numpy function.&quot;</span>
    <span class="n">fa</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">fb</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">fa</span><span class="p">,</span> <span class="n">fb</span><span class="p">)</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ma</span> <span class="ow">is</span> <span class="n">nomask</span> <span class="ow">and</span> <span class="n">mb</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
    <span class="n">ma</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">mb</span> <span class="o">=</span> <span class="n">getmaskarray</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">make_mask</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">ma</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">mb</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">)</span></div>
<span class="n">outer</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="n">doc_note</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="o">.</span><span class="n">__doc__</span><span class="p">,</span>
                         <span class="s2">&quot;Masked values are replaced by 0.&quot;</span><span class="p">)</span>
<span class="n">outerproduct</span> <span class="o">=</span> <span class="n">outer</span>


<div class="viewcode-block" id="allequal"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.allequal.html#numpy.ma.allequal">[docs]</a><span class="k">def</span> <span class="nf">allequal</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return True if all entries of a and b are equal, using</span>
<span class="sd">    fill_value as a truth value where either or both are masked.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        Input arrays to compare.</span>
<span class="sd">    fill_value : bool, optional</span>
<span class="sd">        Whether masked values in a or b are considered equal (True) or not</span>
<span class="sd">        (False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : bool</span>
<span class="sd">        Returns True if the two arrays are equal within the given</span>
<span class="sd">        tolerance, False otherwise. If either array contains NaN,</span>
<span class="sd">        then False is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    all, any</span>
<span class="sd">    numpy.ma.allclose</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [10000000000.0 1e-07 --],</span>
<span class="sd">          mask = [False False  True],</span>
<span class="sd">          fill_value=1e+20)</span>

<span class="sd">    &gt;&gt;&gt; b = array([1e10, 1e-7, -42.0])</span>
<span class="sd">    &gt;&gt;&gt; b</span>
<span class="sd">    array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])</span>
<span class="sd">    &gt;&gt;&gt; ma.allequal(a, b, fill_value=False)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; ma.allequal(a, b)</span>
<span class="sd">    True</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">getmask</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="n">nomask</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">d</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">fill_value</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">getdata</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">umath</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="n">array</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dm</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">None</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="allclose"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.allclose.html#numpy.ma.allclose">[docs]</a><span class="k">def</span> <span class="nf">allclose</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">masked_equal</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns True if two arrays are element-wise equal within a tolerance.</span>

<span class="sd">    This function is equivalent to `allclose` except that masked values</span>
<span class="sd">    are treated as equal (default) or unequal, depending on the `masked_equal`</span>
<span class="sd">    argument.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a, b : array_like</span>
<span class="sd">        Input arrays to compare.</span>
<span class="sd">    masked_equal : bool, optional</span>
<span class="sd">        Whether masked values in `a` and `b` are considered equal (True) or not</span>
<span class="sd">        (False). They are considered equal by default.</span>
<span class="sd">    rtol : float, optional</span>
<span class="sd">        Relative tolerance. The relative difference is equal to ``rtol * b``.</span>
<span class="sd">        Default is 1e-5.</span>
<span class="sd">    atol : float, optional</span>
<span class="sd">        Absolute tolerance. The absolute difference is equal to `atol`.</span>
<span class="sd">        Default is 1e-8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : bool</span>
<span class="sd">        Returns True if the two arrays are equal within the given</span>
<span class="sd">        tolerance, False otherwise. If either array contains NaN, then</span>
<span class="sd">        False is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    all, any</span>
<span class="sd">    numpy.allclose : the non-masked `allclose`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If the following equation is element-wise True, then `allclose` returns</span>
<span class="sd">    True::</span>

<span class="sd">      absolute(`a` - `b`) &lt;= (`atol` + `rtol` * absolute(`b`))</span>

<span class="sd">    Return True if all elements of `a` and `b` are equal subject to</span>
<span class="sd">    given tolerances.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    masked_array(data = [10000000000.0 1e-07 --],</span>
<span class="sd">                 mask = [False False  True],</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b)</span>
<span class="sd">    False</span>

<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b, masked_equal=False)</span>
<span class="sd">    False</span>

<span class="sd">    Masked values are not compared directly.</span>

<span class="sd">    &gt;&gt;&gt; a = ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; b = ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; ma.allclose(a, b, masked_equal=False)</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="c1"># make sure y is an inexact type to avoid abs(MIN_INT); will cause</span>
    <span class="c1"># casting of x later.</span>
    <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">result_type</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">:</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">m</span> <span class="o">=</span> <span class="n">mask_or</span><span class="p">(</span><span class="n">getmask</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">getmask</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
    <span class="n">xinf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">masked_array</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">m</span><span class="p">))</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
    <span class="c1"># If we have some infs, they should fall at the same place.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">xinf</span> <span class="o">==</span> <span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="bp">False</span><span class="p">)):</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="c1"># No infs at all</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">xinf</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span>
                                    <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
                   <span class="n">masked_equal</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">filled</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">xinf</span><span class="p">]</span> <span class="o">==</span> <span class="n">y</span><span class="p">[</span><span class="n">xinf</span><span class="p">],</span> <span class="n">masked_equal</span><span class="p">)):</span>
        <span class="k">return</span> <span class="bp">False</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">~</span><span class="n">xinf</span><span class="p">]</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">~</span><span class="n">xinf</span><span class="p">]</span>

    <span class="n">d</span> <span class="o">=</span> <span class="n">filled</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">),</span>
                                <span class="n">atol</span> <span class="o">+</span> <span class="n">rtol</span> <span class="o">*</span> <span class="n">umath</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">y</span><span class="p">)),</span>
               <span class="n">masked_equal</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">d</span><span class="p">)</span></div>


<div class="viewcode-block" id="asarray"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.asarray.html#numpy.ma.asarray">[docs]</a><span class="k">def</span> <span class="nf">asarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input to a masked array of the given data-type.</span>

<span class="sd">    No copy is performed if the input is already an `ndarray`. If `a` is</span>
<span class="sd">    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to a masked array. This</span>
<span class="sd">        includes lists, lists of tuples, tuples, tuples of tuples, tuples</span>
<span class="sd">        of lists, ndarrays and masked arrays.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to use row-major (&#39;C&#39;) or column-major (&#39;FORTRAN&#39;) memory</span>
<span class="sd">        representation.  Default is &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray</span>
<span class="sd">        Masked array interpretation of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asanyarray : Similar to `asarray`, but conserves subclasses.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.,  4.],</span>
<span class="sd">           [ 5.,  6.,  7.,  8.,  9.]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.asarray(x)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[ 0.  1.  2.  3.  4.]</span>
<span class="sd">     [ 5.  6.  7.  8.  9.]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     False,</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; type(np.ma.asarray(x))</span>
<span class="sd">    &lt;class &#39;numpy.ma.core.MaskedArray&#39;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="asanyarray"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.asanyarray.html#numpy.ma.asanyarray">[docs]</a><span class="k">def</span> <span class="nf">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert the input to a masked array, conserving subclasses.</span>

<span class="sd">    If `a` is a subclass of `MaskedArray`, its class is conserved.</span>
<span class="sd">    No copy is performed if the input is already an `ndarray`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data, in any form that can be converted to an array.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        By default, the data-type is inferred from the input data.</span>
<span class="sd">    order : {&#39;C&#39;, &#39;F&#39;}, optional</span>
<span class="sd">        Whether to use row-major (&#39;C&#39;) or column-major (&#39;FORTRAN&#39;) memory</span>
<span class="sd">        representation.  Default is &#39;C&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : MaskedArray</span>
<span class="sd">        MaskedArray interpretation of `a`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    asarray : Similar to `asanyarray`, but does not conserve subclass.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10.).reshape(2, 5)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([[ 0.,  1.,  2.,  3.,  4.],</span>
<span class="sd">           [ 5.,  6.,  7.,  8.,  9.]])</span>
<span class="sd">    &gt;&gt;&gt; np.ma.asanyarray(x)</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[ 0.  1.  2.  3.  4.]</span>
<span class="sd">     [ 5.  6.  7.  8.  9.]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     False,</span>
<span class="sd">           fill_value = 1e+20)</span>
<span class="sd">    &gt;&gt;&gt; type(np.ma.asanyarray(x))</span>
<span class="sd">    &lt;class &#39;numpy.ma.core.MaskedArray&#39;&gt;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">keep_mask</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>


<span class="c1">##############################################################################</span>
<span class="c1">#                               Pickling                                     #</span>
<span class="c1">##############################################################################</span>
<div class="viewcode-block" id="dump"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.dump.html#numpy.ma.dump">[docs]</a><span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pickle a masked array to a file.</span>

<span class="sd">    This is a wrapper around ``cPickle.dump``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        The array to be pickled.</span>
<span class="sd">    F : str or file-like object</span>
<span class="sd">        The file to pickle `a` to. If a string, the full path to the file.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;readline&#39;</span><span class="p">):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">F</span><span class="p">)</span></div>


<div class="viewcode-block" id="dumps"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.dumps.html#numpy.ma.dumps">[docs]</a><span class="k">def</span> <span class="nf">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a string corresponding to the pickling of a masked array.</span>

<span class="sd">    This is a wrapper around ``cPickle.dumps``.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : MaskedArray</span>
<span class="sd">        The array for which the string representation of the pickle is</span>
<span class="sd">        returned.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">a</span><span class="p">)</span></div>


<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.load.html#numpy.ma.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="n">F</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrapper around ``cPickle.load`` which accepts either a file-like object</span>
<span class="sd">    or a filename.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    F : str or file</span>
<span class="sd">        The file or file name to load.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dump : Pickle an array</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This is different from `numpy.load`, which does not use cPickle but loads</span>
<span class="sd">    the NumPy binary .npy format.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;readline&#39;</span><span class="p">):</span>
        <span class="n">F</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">F</span><span class="p">)</span></div>


<div class="viewcode-block" id="loads"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.loads.html#numpy.ma.loads">[docs]</a><span class="k">def</span> <span class="nf">loads</span><span class="p">(</span><span class="n">strg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a pickle from the current string.</span>

<span class="sd">    The result of ``cPickle.loads(strg)`` is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    strg : str</span>
<span class="sd">        The string to load.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dumps : Return a string corresponding to the pickling of a masked array.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">strg</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">fromfile</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">count</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
        <span class="s2">&quot;fromfile() not yet implemented for a MaskedArray.&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">fromflex</span><span class="p">(</span><span class="n">fxarray</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a masked array from a suitable flexible-type array.</span>

<span class="sd">    The input array has to have a data-type with ``_data`` and ``_mask``</span>
<span class="sd">    fields. This type of array is output by `MaskedArray.toflex`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fxarray : ndarray</span>
<span class="sd">        The structured input array, containing ``_data`` and ``_mask``</span>
<span class="sd">        fields. If present, other fields are discarded.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : MaskedArray</span>
<span class="sd">        The constructed masked array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    MaskedArray.toflex : Build a flexible-type array from a masked array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)</span>
<span class="sd">    &gt;&gt;&gt; rec = x.toflex()</span>
<span class="sd">    &gt;&gt;&gt; rec</span>
<span class="sd">    array([[(0, False), (1, True), (2, False)],</span>
<span class="sd">           [(3, True), (4, False), (5, True)],</span>
<span class="sd">           [(6, False), (7, True), (8, False)]],</span>
<span class="sd">          dtype=[(&#39;_data&#39;, &#39;&lt;i4&#39;), (&#39;_mask&#39;, &#39;|b1&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; x2 = np.ma.fromflex(rec)</span>
<span class="sd">    &gt;&gt;&gt; x2</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 -- 2]</span>
<span class="sd">     [-- 4 --]</span>
<span class="sd">     [6 -- 8]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False  True False]</span>
<span class="sd">     [ True False  True]</span>
<span class="sd">     [False  True False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    Extra fields can be present in the structured array but are discarded:</span>

<span class="sd">    &gt;&gt;&gt; dt = [(&#39;_data&#39;, &#39;&lt;i4&#39;), (&#39;_mask&#39;, &#39;|b1&#39;), (&#39;field3&#39;, &#39;&lt;f4&#39;)]</span>
<span class="sd">    &gt;&gt;&gt; rec2 = np.zeros((2, 2), dtype=dt)</span>
<span class="sd">    &gt;&gt;&gt; rec2</span>
<span class="sd">    array([[(0, False, 0.0), (0, False, 0.0)],</span>
<span class="sd">           [(0, False, 0.0), (0, False, 0.0)]],</span>
<span class="sd">          dtype=[(&#39;_data&#39;, &#39;&lt;i4&#39;), (&#39;_mask&#39;, &#39;|b1&#39;), (&#39;field3&#39;, &#39;&lt;f4&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; y = np.ma.fromflex(rec2)</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    masked_array(data =</span>
<span class="sd">     [[0 0]</span>
<span class="sd">     [0 0]],</span>
<span class="sd">                 mask =</span>
<span class="sd">     [[False False]</span>
<span class="sd">     [False False]],</span>
<span class="sd">           fill_value = 999999)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">masked_array</span><span class="p">(</span><span class="n">fxarray</span><span class="p">[</span><span class="s1">&#39;_data&#39;</span><span class="p">],</span> <span class="n">mask</span><span class="o">=</span><span class="n">fxarray</span><span class="p">[</span><span class="s1">&#39;_mask&#39;</span><span class="p">])</span>


<span class="k">class</span> <span class="nc">_convert2ma</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert functions from numpy to numpy.ma.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        _methodname : string</span>
<span class="sd">            Name of the method to transform.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">__doc__</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">funcname</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">funcname</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__doc__</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">getdoc</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_extras</span> <span class="o">=</span> <span class="n">params</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">getdoc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;Return the doc of the function (from the doc of the method).&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">,</span> <span class="s1">&#39;__doc__&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="n">sig</span> <span class="o">=</span> <span class="n">get_object_signature</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">doc</span><span class="p">:</span>
            <span class="c1"># Add the signature of the function at the beginning of the doc</span>
            <span class="k">if</span> <span class="n">sig</span><span class="p">:</span>
                <span class="n">sig</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="o">.</span><span class="n">__name__</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">+</span> <span class="n">doc</span>
        <span class="k">return</span> <span class="n">doc</span>

    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">):</span>
        <span class="c1"># Find the common parameters to the call and the definition</span>
        <span class="n">_extras</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extras</span>
        <span class="n">common_params</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">_extras</span><span class="p">)</span>
        <span class="c1"># Drop the common parameters from the call</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">common_params</span><span class="p">:</span>
            <span class="n">_extras</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="c1"># Get the result</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_func</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">params</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;fill_value&quot;</span> <span class="ow">in</span> <span class="n">common_params</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">fill_value</span> <span class="o">=</span> <span class="n">_extras</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;fill_value&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;hardmask&quot;</span> <span class="ow">in</span> <span class="n">common_params</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">_hardmask</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">_extras</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;hard_mask&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="n">arange</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;arange&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="n">clip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">clip</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span>
<span class="n">empty</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;empty&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="n">empty_like</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;empty_like&#39;</span><span class="p">)</span>
<span class="n">frombuffer</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;frombuffer&#39;</span><span class="p">)</span>
<span class="n">fromfunction</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;fromfunction&#39;</span><span class="p">)</span>
<span class="n">identity</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span>
    <span class="s1">&#39;identity&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">indices</span>
<span class="n">ones</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;ones&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="n">ones_like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span>
<span class="n">squeeze</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span>
<span class="n">zeros</span> <span class="o">=</span> <span class="n">_convert2ma</span><span class="p">(</span><span class="s1">&#39;zeros&#39;</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">fill_value</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">hardmask</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>
<span class="n">zeros_like</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span>


<div class="viewcode-block" id="append"><a class="viewcode-back" href="../../../reference/generated/numpy.ma.append.html#numpy.ma.append">[docs]</a><span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Append values to the end of an array.</span>

<span class="sd">    .. versionadded:: 1.9.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Values are appended to a copy of this array.</span>
<span class="sd">    b : array_like</span>
<span class="sd">        These values are appended to a copy of `a`.  It must be of the</span>
<span class="sd">        correct shape (the same shape as `a`, excluding `axis`).  If `axis`</span>
<span class="sd">        is not specified, `b` can be any shape and will be flattened</span>
<span class="sd">        before use.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        The axis along which `v` are appended.  If `axis` is not given,</span>
<span class="sd">        both `a` and `b` are flattened before use.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    append : MaskedArray</span>
<span class="sd">        A copy of `a` with `b` appended to `axis`.  Note that `append`</span>
<span class="sd">        does not occur in-place: a new array is allocated and filled.  If</span>
<span class="sd">        `axis` is None, the result is a flattened array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.append : Equivalent function in the top-level NumPy module.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy.ma as ma</span>
<span class="sd">    &gt;&gt;&gt; a = ma.masked_values([1, 2, 3], 2)</span>
<span class="sd">    &gt;&gt;&gt; b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)</span>
<span class="sd">    &gt;&gt;&gt; print(ma.append(a, b))</span>
<span class="sd">    [1 -- 3 4 5 6 -- 8 9]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">],</span> <span class="n">axis</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>