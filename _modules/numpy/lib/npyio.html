

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>numpy.lib.npyio &mdash; Numpy API</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Numpy API" href="../../../index.html"/>
        <link rel="up" title="numpy" href="../../numpy.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Numpy API
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.html">1. NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.doc.html">2. <code class="docutils literal"><span class="pre">numpy.doc</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.lib.html">3. <code class="docutils literal"><span class="pre">numpy.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.random.html">4. <code class="docutils literal"><span class="pre">numpy.random</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.linalg.html">5. <code class="docutils literal"><span class="pre">numpy.linalg</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.fft.html">6. Discrete Fourier Transform (<code class="docutils literal"><span class="pre">numpy.fft</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.polynomial.html">7. <code class="docutils literal"><span class="pre">numpy.polynomial</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.testing.html">8. <code class="docutils literal"><span class="pre">numpy.testing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.f2py.html">9. <code class="docutils literal"><span class="pre">numpy.f2py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.distutils.html">10. <code class="docutils literal"><span class="pre">numpy.distutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">11. NumPy Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">12. Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Numpy API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../numpy.html">numpy</a> &raquo;</li>
        
      <li>numpy.lib.npyio</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for numpy.lib.npyio</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">weakref</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="kn">import</span> <span class="n">itemgetter</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">format</span>
<span class="kn">from</span> <span class="nn">._datasource</span> <span class="kn">import</span> <span class="n">DataSource</span>
<span class="kn">from</span> <span class="nn">numpy.core.multiarray</span> <span class="kn">import</span> <span class="n">packbits</span><span class="p">,</span> <span class="n">unpackbits</span>
<span class="kn">from</span> <span class="nn">._iotools</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">LineSplitter</span><span class="p">,</span> <span class="n">NameValidator</span><span class="p">,</span> <span class="n">StringConverter</span><span class="p">,</span> <span class="n">ConverterError</span><span class="p">,</span>
    <span class="n">ConverterLockError</span><span class="p">,</span> <span class="n">ConversionWarning</span><span class="p">,</span> <span class="n">_is_string_like</span><span class="p">,</span> <span class="n">has_nested_fields</span><span class="p">,</span>
    <span class="n">flatten_dtype</span><span class="p">,</span> <span class="n">easy_dtype</span><span class="p">,</span> <span class="n">_bytes_to_name</span>
    <span class="p">)</span>

<span class="kn">from</span> <span class="nn">numpy.compat</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">asbytes</span><span class="p">,</span> <span class="n">asstr</span><span class="p">,</span> <span class="n">asbytes_nested</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">,</span> <span class="nb">unicode</span>
    <span class="p">)</span>

<span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pickle</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">cPickle</span> <span class="kn">as</span> <span class="nn">pickle</span>
    <span class="kn">from</span> <span class="nn">future_builtins</span> <span class="kn">import</span> <span class="nb">map</span>

<span class="n">loads</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;savetxt&#39;</span><span class="p">,</span> <span class="s1">&#39;loadtxt&#39;</span><span class="p">,</span> <span class="s1">&#39;genfromtxt&#39;</span><span class="p">,</span> <span class="s1">&#39;ndfromtxt&#39;</span><span class="p">,</span> <span class="s1">&#39;mafromtxt&#39;</span><span class="p">,</span>
    <span class="s1">&#39;recfromtxt&#39;</span><span class="p">,</span> <span class="s1">&#39;recfromcsv&#39;</span><span class="p">,</span> <span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="s1">&#39;loads&#39;</span><span class="p">,</span> <span class="s1">&#39;save&#39;</span><span class="p">,</span> <span class="s1">&#39;savez&#39;</span><span class="p">,</span>
    <span class="s1">&#39;savez_compressed&#39;</span><span class="p">,</span> <span class="s1">&#39;packbits&#39;</span><span class="p">,</span> <span class="s1">&#39;unpackbits&#39;</span><span class="p">,</span> <span class="s1">&#39;fromregex&#39;</span><span class="p">,</span> <span class="s1">&#39;DataSource&#39;</span>
    <span class="p">]</span>


<span class="k">class</span> <span class="nc">BagObj</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BagObj(obj)</span>

<span class="sd">    Convert attribute look-ups to getitems on the object passed in.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    obj : class instance</span>
<span class="sd">        Object on which attribute look-up is performed.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from numpy.lib.npyio import BagObj as BO</span>
<span class="sd">    &gt;&gt;&gt; class BagDemo(object):</span>
<span class="sd">    ...     def __getitem__(self, key): # An instance of BagObj(BagDemo)</span>
<span class="sd">    ...                                 # will call this method when any</span>
<span class="sd">    ...                                 # attribute look-up is required</span>
<span class="sd">    ...         result = &quot;Doesn&#39;t matter what you want, &quot;</span>
<span class="sd">    ...         return result + &quot;you&#39;re gonna get this&quot;</span>
<span class="sd">    ...</span>
<span class="sd">    &gt;&gt;&gt; demo_obj = BagDemo()</span>
<span class="sd">    &gt;&gt;&gt; bagobj = BO(demo_obj)</span>
<span class="sd">    &gt;&gt;&gt; bagobj.hello_there</span>
<span class="sd">    &quot;Doesn&#39;t matter what you want, you&#39;re gonna get this&quot;</span>
<span class="sd">    &gt;&gt;&gt; bagobj.I_can_be_anything</span>
<span class="sd">    &quot;Doesn&#39;t matter what you want, you&#39;re gonna get this&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># Use weakref to make NpzFile objects collectable by refcount</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span> <span class="o">=</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_obj&#39;</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__dir__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enables dir(bagobj) to list the files in an NpzFile.</span>

<span class="sd">        This also enables tab-completion in an interpreter or IPython.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">object</span><span class="o">.</span><span class="n">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;_obj&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">zipfile_factory</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="kn">import</span> <span class="nn">zipfile</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;allowZip64&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipFile</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NpzFile</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NpzFile(fid)</span>

<span class="sd">    A dictionary-like object with lazy-loading of files in the zipped</span>
<span class="sd">    archive provided on construction.</span>

<span class="sd">    `NpzFile` is used to load files in the NumPy ``.npz`` data archive</span>
<span class="sd">    format. It assumes that files in the archive have a ``.npy`` extension,</span>
<span class="sd">    other files are ignored.</span>

<span class="sd">    The arrays and file strings are lazily loaded on either</span>
<span class="sd">    getitem access using ``obj[&#39;key&#39;]`` or attribute lookup using</span>
<span class="sd">    ``obj.f.key``. A list of all files (without ``.npy`` extensions) can</span>
<span class="sd">    be obtained with ``obj.files`` and the ZipFile object itself using</span>
<span class="sd">    ``obj.zip``.</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    files : list of str</span>
<span class="sd">        List of all files in the archive with a ``.npy`` extension.</span>
<span class="sd">    zip : ZipFile instance</span>
<span class="sd">        The ZipFile object initialized with the zipped archive.</span>
<span class="sd">    f : BagObj instance</span>
<span class="sd">        An object on which attribute can be performed as an alternative</span>
<span class="sd">        to getitem access on the `NpzFile` instance itself.</span>
<span class="sd">    allow_pickle : bool, optional</span>
<span class="sd">        Allow loading pickled data. Default: True</span>
<span class="sd">    pickle_kwargs : dict, optional</span>
<span class="sd">        Additional keyword arguments to pass on to pickle.load.</span>
<span class="sd">        These are only useful when loading object arrays saved on</span>
<span class="sd">        Python 2 when using Python 3.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fid : file or str</span>
<span class="sd">        The zipped archive to open. This is either a file-like object</span>
<span class="sd">        or a string containing the path to the archive.</span>
<span class="sd">    own_fid : bool, optional</span>
<span class="sd">        Whether NpzFile should close the file handle.</span>
<span class="sd">        Requires that `fid` is a file-like object.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from tempfile import TemporaryFile</span>
<span class="sd">    &gt;&gt;&gt; outfile = TemporaryFile()</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.sin(x)</span>
<span class="sd">    &gt;&gt;&gt; np.savez(outfile, x=x, y=y)</span>
<span class="sd">    &gt;&gt;&gt; outfile.seek(0)</span>

<span class="sd">    &gt;&gt;&gt; npz = np.load(outfile)</span>
<span class="sd">    &gt;&gt;&gt; isinstance(npz, np.lib.io.NpzFile)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; npz.files</span>
<span class="sd">    [&#39;y&#39;, &#39;x&#39;]</span>
<span class="sd">    &gt;&gt;&gt; npz[&#39;x&#39;]  # getitem access</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>
<span class="sd">    &gt;&gt;&gt; npz.f.x  # attribute lookup</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">own_fid</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                 <span class="n">pickle_kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="c1"># Import is postponed to here since zipfile depends on gzip, an</span>
        <span class="c1"># optional component of the so-called standard library.</span>
        <span class="n">_zip</span> <span class="o">=</span> <span class="n">zipfile_factory</span><span class="p">(</span><span class="n">fid</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_files</span> <span class="o">=</span> <span class="n">_zip</span><span class="o">.</span><span class="n">namelist</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">files</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_pickle</span> <span class="o">=</span> <span class="n">allow_pickle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pickle_kwargs</span> <span class="o">=</span> <span class="n">pickle_kwargs</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zip</span> <span class="o">=</span> <span class="n">_zip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="n">BagObj</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">own_fid</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fid</span> <span class="o">=</span> <span class="n">fid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fid</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">def</span> <span class="nf">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exc_type</span><span class="p">,</span> <span class="n">exc_value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Close the file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zip</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">zip</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">fid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fid</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">f</span> <span class="o">=</span> <span class="bp">None</span>  <span class="c1"># break reference cycle</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="c1"># FIXME: This seems like it will copy strings around</span>
        <span class="c1">#   more than is strictly necessary.  The zipfile</span>
        <span class="c1">#   will read the string and then</span>
        <span class="c1">#   the format.read_array will copy the string</span>
        <span class="c1">#   to another place in memory.</span>
        <span class="c1">#   It would be better if the zipfile could read</span>
        <span class="c1">#   (or at least uncompress) the data</span>
        <span class="c1">#   directly into the array memory.</span>
        <span class="n">member</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_files</span><span class="p">:</span>
            <span class="n">member</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">:</span>
            <span class="n">member</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">key</span> <span class="o">+=</span> <span class="s1">&#39;.npy&#39;</span>
        <span class="k">if</span> <span class="n">member</span><span class="p">:</span>
            <span class="nb">bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="n">magic</span> <span class="o">=</span> <span class="nb">bytes</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">MAGIC_PREFIX</span><span class="p">))</span>
            <span class="nb">bytes</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">magic</span> <span class="o">==</span> <span class="n">format</span><span class="o">.</span><span class="n">MAGIC_PREFIX</span><span class="p">:</span>
                <span class="nb">bytes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">format</span><span class="o">.</span><span class="n">read_array</span><span class="p">(</span><span class="nb">bytes</span><span class="p">,</span>
                                         <span class="n">allow_pickle</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">allow_pickle</span><span class="p">,</span>
                                         <span class="n">pickle_kwargs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pickle_kwargs</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">zip</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a file in the archive&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of tuples, with each tuple (filename, array in file).</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="p">])</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">iteritems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generator that returns tuples (filename, array in file).&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="bp">self</span><span class="p">[</span><span class="n">f</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return files in the archive with a ``.npy`` extension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span>

    <span class="k">def</span> <span class="nf">iterkeys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return an iterator over the files in the archive.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__iter__</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">files</span><span class="o">.</span><span class="n">__contains__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>


<div class="viewcode-block" id="load"><a class="viewcode-back" href="../../../reference/generated/numpy.load.html#numpy.load">[docs]</a><span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fix_imports</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
         <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ASCII&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load arrays or pickled objects from ``.npy``, ``.npz`` or pickled files.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : file-like object or string</span>
<span class="sd">        The file to read. File-like objects must support the</span>
<span class="sd">        ``seek()`` and ``read()`` methods. Pickled files require that the</span>
<span class="sd">        file-like object support the ``readline()`` method as well.</span>
<span class="sd">    mmap_mode : {None, &#39;r+&#39;, &#39;r&#39;, &#39;w+&#39;, &#39;c&#39;}, optional</span>
<span class="sd">        If not None, then memory-map the file, using the given mode (see</span>
<span class="sd">        `numpy.memmap` for a detailed description of the modes).  A</span>
<span class="sd">        memory-mapped array is kept on disk. However, it can be accessed</span>
<span class="sd">        and sliced like any ndarray.  Memory mapping is especially useful</span>
<span class="sd">        for accessing small fragments of large files without reading the</span>
<span class="sd">        entire file into memory.</span>
<span class="sd">    allow_pickle : bool, optional</span>
<span class="sd">        Allow loading pickled object arrays stored in npy files. Reasons for</span>
<span class="sd">        disallowing pickles include security, as loading pickled data can</span>
<span class="sd">        execute arbitrary code. If pickles are disallowed, loading object</span>
<span class="sd">        arrays will fail.</span>
<span class="sd">        Default: True</span>
<span class="sd">    fix_imports : bool, optional</span>
<span class="sd">        Only useful when loading Python 2 generated pickled files on Python 3,</span>
<span class="sd">        which includes npy/npz files containing object arrays. If `fix_imports`</span>
<span class="sd">        is True, pickle will try to map the old Python 2 names to the new names</span>
<span class="sd">        used in Python 3.</span>
<span class="sd">    encoding : str, optional</span>
<span class="sd">        What encoding to use when reading Python 2 strings. Only useful when</span>
<span class="sd">        loading Python 2 generated pickled files on Python 3, which includes</span>
<span class="sd">        npy/npz files containing object arrays. Values other than &#39;latin1&#39;,</span>
<span class="sd">        &#39;ASCII&#39;, and &#39;bytes&#39; are not allowed, as they can corrupt numerical</span>
<span class="sd">        data. Default: &#39;ASCII&#39;</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    result : array, tuple, dict, etc.</span>
<span class="sd">        Data stored in the file. For ``.npz`` files, the returned instance</span>
<span class="sd">        of NpzFile class must be closed to avoid leaking file descriptors.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    IOError</span>
<span class="sd">        If the input file does not exist or cannot be read.</span>
<span class="sd">    ValueError</span>
<span class="sd">        The file contains an object array, but allow_pickle=False given.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    save, savez, savez_compressed, loadtxt</span>
<span class="sd">    memmap : Create a memory-map to an array stored in a file on disk.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If the file contains pickle data, then whatever object is stored</span>
<span class="sd">      in the pickle is returned.</span>
<span class="sd">    - If the file is a ``.npy`` file, then a single array is returned.</span>
<span class="sd">    - If the file is a ``.npz`` file, then a dictionary-like object is</span>
<span class="sd">      returned, containing ``{filename: array}`` key-value pairs, one for</span>
<span class="sd">      each file in the archive.</span>
<span class="sd">    - If the file is a ``.npz`` file, the returned value supports the</span>
<span class="sd">      context manager protocol in a similar fashion to the open function::</span>

<span class="sd">        with load(&#39;foo.npz&#39;) as data:</span>
<span class="sd">            a = data[&#39;a&#39;]</span>

<span class="sd">      The underlying file descriptor is closed when exiting the &#39;with&#39;</span>
<span class="sd">      block.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Store data to disk, and load it again:</span>

<span class="sd">    &gt;&gt;&gt; np.save(&#39;/tmp/123&#39;, np.array([[1, 2, 3], [4, 5, 6]]))</span>
<span class="sd">    &gt;&gt;&gt; np.load(&#39;/tmp/123.npy&#39;)</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>

<span class="sd">    Store compressed data to disk, and load it again:</span>

<span class="sd">    &gt;&gt;&gt; a=np.array([[1, 2, 3], [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; b=np.array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; np.savez(&#39;/tmp/123.npz&#39;, a=a, b=b)</span>
<span class="sd">    &gt;&gt;&gt; data = np.load(&#39;/tmp/123.npz&#39;)</span>
<span class="sd">    &gt;&gt;&gt; data[&#39;a&#39;]</span>
<span class="sd">    array([[1, 2, 3],</span>
<span class="sd">           [4, 5, 6]])</span>
<span class="sd">    &gt;&gt;&gt; data[&#39;b&#39;]</span>
<span class="sd">    array([1, 2])</span>
<span class="sd">    &gt;&gt;&gt; data.close()</span>

<span class="sd">    Mem-map the stored array, and then access the second row</span>
<span class="sd">    directly from disk:</span>

<span class="sd">    &gt;&gt;&gt; X = np.load(&#39;/tmp/123.npy&#39;, mmap_mode=&#39;r&#39;)</span>
<span class="sd">    &gt;&gt;&gt; X[1, :]</span>
<span class="sd">    memmap([4, 5, 6])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">gzip</span>

    <span class="n">own_fid</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span>
        <span class="n">own_fid</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fid</span> <span class="o">=</span> <span class="nb">file</span>

    <span class="k">if</span> <span class="n">encoding</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;ASCII&#39;</span><span class="p">,</span> <span class="s1">&#39;latin1&#39;</span><span class="p">,</span> <span class="s1">&#39;bytes&#39;</span><span class="p">):</span>
        <span class="c1"># The &#39;encoding&#39; value for pickle also affects what encoding</span>
        <span class="c1"># the serialized binary data of Numpy arrays is loaded</span>
        <span class="c1"># in. Pickle does not pass on the encoding information to</span>
        <span class="c1"># Numpy. The unpickling code in numpy.core.multiarray is</span>
        <span class="c1"># written to assume that unicode data appearing where binary</span>
        <span class="c1"># should be is in &#39;latin1&#39;. &#39;bytes&#39; is also safe, as is &#39;ASCII&#39;.</span>
        <span class="c1">#</span>
        <span class="c1"># Other encoding values can corrupt binary data, and we</span>
        <span class="c1"># purposefully disallow them. For the same reason, the errors=</span>
        <span class="c1"># argument is not exposed, as values other than &#39;strict&#39;</span>
        <span class="c1"># result can similarly silently corrupt numerical data.</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;encoding must be &#39;ASCII&#39;, &#39;latin1&#39;, or &#39;bytes&#39;&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">pickle_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">,</span> <span class="n">fix_imports</span><span class="o">=</span><span class="n">fix_imports</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Nothing to do on Python 2</span>
        <span class="n">pickle_kwargs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Code to distinguish from NumPy binary files and pickles.</span>
        <span class="n">_ZIP_PREFIX</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;PK</span><span class="se">\x03\x04</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">format</span><span class="o">.</span><span class="n">MAGIC_PREFIX</span><span class="p">)</span>
        <span class="n">magic</span> <span class="o">=</span> <span class="n">fid</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
        <span class="n">fid</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># back-up</span>
        <span class="k">if</span> <span class="n">magic</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">_ZIP_PREFIX</span><span class="p">):</span>
            <span class="c1"># zip-file (assume .npz)</span>
            <span class="c1"># Transfer file ownership to NpzFile</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">own_fid</span>
            <span class="n">own_fid</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">return</span> <span class="n">NpzFile</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">own_fid</span><span class="o">=</span><span class="n">tmp</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="n">allow_pickle</span><span class="p">,</span>
                           <span class="n">pickle_kwargs</span><span class="o">=</span><span class="n">pickle_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">magic</span> <span class="o">==</span> <span class="n">format</span><span class="o">.</span><span class="n">MAGIC_PREFIX</span><span class="p">:</span>
            <span class="c1"># .npy file</span>
            <span class="k">if</span> <span class="n">mmap_mode</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">format</span><span class="o">.</span><span class="n">open_memmap</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mmap_mode</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">format</span><span class="o">.</span><span class="n">read_array</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="n">allow_pickle</span><span class="p">,</span>
                                         <span class="n">pickle_kwargs</span><span class="o">=</span><span class="n">pickle_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Try a pickle</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_pickle</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;allow_pickle=False, but file does not contain &quot;</span>
                                 <span class="s2">&quot;non-pickled data&quot;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="o">**</span><span class="n">pickle_kwargs</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span>
                    <span class="s2">&quot;Failed to interpret file </span><span class="si">%s</span><span class="s2"> as a pickle&quot;</span> <span class="o">%</span> <span class="nb">repr</span><span class="p">(</span><span class="nb">file</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">own_fid</span><span class="p">:</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="save"><a class="viewcode-back" href="../../../reference/generated/numpy.save.html#numpy.save">[docs]</a><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">fix_imports</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save an array to a binary file in NumPy ``.npy`` format.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : file or str</span>
<span class="sd">        File or filename to which the data is saved.  If file is a file-object,</span>
<span class="sd">        then the filename is unchanged.  If file is a string, a ``.npy``</span>
<span class="sd">        extension will be appended to the file name if it does not already</span>
<span class="sd">        have one.</span>
<span class="sd">    allow_pickle : bool, optional</span>
<span class="sd">        Allow saving object arrays using Python pickles. Reasons for disallowing</span>
<span class="sd">        pickles include security (loading pickled data can execute arbitrary</span>
<span class="sd">        code) and portability (pickled objects may not be loadable on different</span>
<span class="sd">        Python installations, for example if the stored objects require libraries</span>
<span class="sd">        that are not available, and not all pickled data is compatible between</span>
<span class="sd">        Python 2 and Python 3).</span>
<span class="sd">        Default: True</span>
<span class="sd">    fix_imports : bool, optional</span>
<span class="sd">        Only useful in forcing objects in object arrays on Python 3 to be</span>
<span class="sd">        pickled in a Python 2 compatible way. If `fix_imports` is True, pickle</span>
<span class="sd">        will try to map the new Python 3 names to the old module names used in</span>
<span class="sd">        Python 2, so that the pickle data stream is readable with Python 2.</span>
<span class="sd">    arr : array_like</span>
<span class="sd">        Array data to be saved.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    savez : Save several arrays into a ``.npz`` archive</span>
<span class="sd">    savetxt, load</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    For a description of the ``.npy`` format, see the module docstring</span>
<span class="sd">    of `numpy.lib.format` or the Numpy Enhancement Proposal</span>
<span class="sd">    http://docs.scipy.org/doc/numpy/neps/npy-format.html</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from tempfile import TemporaryFile</span>
<span class="sd">    &gt;&gt;&gt; outfile = TemporaryFile()</span>

<span class="sd">    &gt;&gt;&gt; x = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; np.save(outfile, x)</span>

<span class="sd">    &gt;&gt;&gt; outfile.seek(0) # Only needed here to simulate closing &amp; reopening file</span>
<span class="sd">    &gt;&gt;&gt; np.load(outfile)</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">own_fid</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npy&#39;</span><span class="p">):</span>
            <span class="nb">file</span> <span class="o">=</span> <span class="nb">file</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span>
        <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span>
        <span class="n">own_fid</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fid</span> <span class="o">=</span> <span class="nb">file</span>

    <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">pickle_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">fix_imports</span><span class="o">=</span><span class="n">fix_imports</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Nothing to do on Python 2</span>
        <span class="n">pickle_kwargs</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
        <span class="n">format</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="n">allow_pickle</span><span class="p">,</span>
                           <span class="n">pickle_kwargs</span><span class="o">=</span><span class="n">pickle_kwargs</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">own_fid</span><span class="p">:</span>
            <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="savez"><a class="viewcode-back" href="../../../reference/generated/numpy.savez.html#numpy.savez">[docs]</a><span class="k">def</span> <span class="nf">savez</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save several arrays into a single file in uncompressed ``.npz`` format.</span>

<span class="sd">    If arguments are passed in with no keywords, the corresponding variable</span>
<span class="sd">    names, in the ``.npz`` file, are &#39;arr_0&#39;, &#39;arr_1&#39;, etc. If keyword</span>
<span class="sd">    arguments are given, the corresponding variable names, in the ``.npz``</span>
<span class="sd">    file will match the keyword names.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : str or file</span>
<span class="sd">        Either the file name (string) or an open file (file-like object)</span>
<span class="sd">        where the data will be saved. If file is a string, the ``.npz``</span>
<span class="sd">        extension will be appended to the file name if it is not already there.</span>
<span class="sd">    args : Arguments, optional</span>
<span class="sd">        Arrays to save to the file. Since it is not possible for Python to</span>
<span class="sd">        know the names of the arrays outside `savez`, the arrays will be saved</span>
<span class="sd">        with names &quot;arr_0&quot;, &quot;arr_1&quot;, and so on. These arguments can be any</span>
<span class="sd">        expression.</span>
<span class="sd">    kwds : Keyword arguments, optional</span>
<span class="sd">        Arrays to save to the file. Arrays will be saved in the file with the</span>
<span class="sd">        keyword names.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    save : Save a single array to a binary file in NumPy format.</span>
<span class="sd">    savetxt : Save an array to a file as plain text.</span>
<span class="sd">    savez_compressed : Save several arrays into a compressed ``.npz`` archive</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The ``.npz`` file format is a zipped archive of files named after the</span>
<span class="sd">    variables they contain.  The archive is not compressed and each file</span>
<span class="sd">    in the archive contains one variable in ``.npy`` format. For a</span>
<span class="sd">    description of the ``.npy`` format, see `numpy.lib.format` or the</span>
<span class="sd">    Numpy Enhancement Proposal</span>
<span class="sd">    http://docs.scipy.org/doc/numpy/neps/npy-format.html</span>

<span class="sd">    When opening the saved ``.npz`` file with `load` a `NpzFile` object is</span>
<span class="sd">    returned. This is a dictionary-like object which can be queried for</span>
<span class="sd">    its list of arrays (with the ``.files`` attribute), and for the arrays</span>
<span class="sd">    themselves.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from tempfile import TemporaryFile</span>
<span class="sd">    &gt;&gt;&gt; outfile = TemporaryFile()</span>
<span class="sd">    &gt;&gt;&gt; x = np.arange(10)</span>
<span class="sd">    &gt;&gt;&gt; y = np.sin(x)</span>

<span class="sd">    Using `savez` with \\*args, the arrays are saved with default names.</span>

<span class="sd">    &gt;&gt;&gt; np.savez(outfile, x, y)</span>
<span class="sd">    &gt;&gt;&gt; outfile.seek(0) # Only needed here to simulate closing &amp; reopening file</span>
<span class="sd">    &gt;&gt;&gt; npzfile = np.load(outfile)</span>
<span class="sd">    &gt;&gt;&gt; npzfile.files</span>
<span class="sd">    [&#39;arr_1&#39;, &#39;arr_0&#39;]</span>
<span class="sd">    &gt;&gt;&gt; npzfile[&#39;arr_0&#39;]</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    Using `savez` with \\**kwds, the arrays are saved with the keyword names.</span>

<span class="sd">    &gt;&gt;&gt; outfile = TemporaryFile()</span>
<span class="sd">    &gt;&gt;&gt; np.savez(outfile, x=x, y=y)</span>
<span class="sd">    &gt;&gt;&gt; outfile.seek(0)</span>
<span class="sd">    &gt;&gt;&gt; npzfile = np.load(outfile)</span>
<span class="sd">    &gt;&gt;&gt; npzfile.files</span>
<span class="sd">    [&#39;y&#39;, &#39;x&#39;]</span>
<span class="sd">    &gt;&gt;&gt; npzfile[&#39;x&#39;]</span>
<span class="sd">    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_savez</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="savez_compressed"><a class="viewcode-back" href="../../../reference/generated/numpy.savez_compressed.html#numpy.savez_compressed">[docs]</a><span class="k">def</span> <span class="nf">savez_compressed</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwds</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save several arrays into a single file in compressed ``.npz`` format.</span>

<span class="sd">    If keyword arguments are given, then filenames are taken from the keywords.</span>
<span class="sd">    If arguments are passed in with no keywords, then stored file names are</span>
<span class="sd">    arr_0, arr_1, etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : str</span>
<span class="sd">        File name of ``.npz`` file.</span>
<span class="sd">    args : Arguments</span>
<span class="sd">        Function arguments.</span>
<span class="sd">    kwds : Keyword arguments</span>
<span class="sd">        Keywords.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.savez : Save several arrays into an uncompressed ``.npz`` file format</span>
<span class="sd">    numpy.load : Load the files created by savez_compressed.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_savez</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span></div>


<span class="k">def</span> <span class="nf">_savez</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwds</span><span class="p">,</span> <span class="n">compress</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">pickle_kwargs</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="c1"># Import is postponed to here since zipfile depends on gzip, an optional</span>
    <span class="c1"># component of the so-called standard library.</span>
    <span class="kn">import</span> <span class="nn">zipfile</span>
    <span class="c1"># Import deferred for startup time improvement</span>
    <span class="kn">import</span> <span class="nn">tempfile</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">file</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.npz&#39;</span><span class="p">):</span>
            <span class="nb">file</span> <span class="o">=</span> <span class="nb">file</span> <span class="o">+</span> <span class="s1">&#39;.npz&#39;</span>

    <span class="n">namedict</span> <span class="o">=</span> <span class="n">kwds</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39;arr_</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">namedict</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Cannot use un-named variables and keyword </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">key</span><span class="p">)</span>
        <span class="n">namedict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">if</span> <span class="n">compress</span><span class="p">:</span>
        <span class="n">compression</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_DEFLATED</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">compression</span> <span class="o">=</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZIP_STORED</span>

    <span class="n">zipf</span> <span class="o">=</span> <span class="n">zipfile_factory</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">compression</span><span class="o">=</span><span class="n">compression</span><span class="p">)</span>

    <span class="c1"># Stage arrays in a temporary file on disk, before writing to zip.</span>
    <span class="n">fd</span><span class="p">,</span> <span class="n">tmpfile</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">mkstemp</span><span class="p">(</span><span class="n">suffix</span><span class="o">=</span><span class="s1">&#39;-numpy.npy&#39;</span><span class="p">)</span>
    <span class="n">os</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">namedict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="n">key</span> <span class="o">+</span> <span class="s1">&#39;.npy&#39;</span>
            <span class="n">fid</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">format</span><span class="o">.</span><span class="n">write_array</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">val</span><span class="p">),</span>
                                   <span class="n">allow_pickle</span><span class="o">=</span><span class="n">allow_pickle</span><span class="p">,</span>
                                   <span class="n">pickle_kwargs</span><span class="o">=</span><span class="n">pickle_kwargs</span><span class="p">)</span>
                <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
                <span class="n">fid</span> <span class="o">=</span> <span class="bp">None</span>
                <span class="n">zipf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">,</span> <span class="n">arcname</span><span class="o">=</span><span class="n">fname</span><span class="p">)</span>
            <span class="k">finally</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fid</span><span class="p">:</span>
                    <span class="n">fid</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="n">os</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">tmpfile</span><span class="p">)</span>

    <span class="n">zipf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_getconv</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Find the correct dtype converter. Adapted from matplotlib &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">floatconv</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="n">x</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">b</span><span class="s1">&#39;0x&#39;</span> <span class="ow">in</span> <span class="n">x</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="o">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">asstr</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="n">typ</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">bool</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">uint64</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span>
    <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">floating</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">floatconv</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex</span><span class="p">):</span>
        <span class="k">return</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">complex</span><span class="p">(</span><span class="n">asstr</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">typ</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bytes_</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bytes</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span>


<div class="viewcode-block" id="loadtxt"><a class="viewcode-back" href="../../../reference/generated/numpy.loadtxt.html#numpy.loadtxt">[docs]</a><span class="k">def</span> <span class="nf">loadtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
            <span class="n">converters</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
            <span class="n">ndmin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load data from a text file.</span>

<span class="sd">    Each row in the text file must have the same number of values.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : file or str</span>
<span class="sd">        File, filename, or generator to read.  If the filename extension is</span>
<span class="sd">        ``.gz`` or ``.bz2``, the file is first decompressed. Note that</span>
<span class="sd">        generators should return byte strings for Python 3k.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Data-type of the resulting array; default: float.  If this is a</span>
<span class="sd">        structured data-type, the resulting array will be 1-dimensional, and</span>
<span class="sd">        each row will be interpreted as an element of the array.  In this</span>
<span class="sd">        case, the number of columns used must match the number of fields in</span>
<span class="sd">        the data-type.</span>
<span class="sd">    comments : str or sequence, optional</span>
<span class="sd">        The characters or list of characters used to indicate the start of a</span>
<span class="sd">        comment;</span>
<span class="sd">        default: &#39;#&#39;.</span>
<span class="sd">    delimiter : str, optional</span>
<span class="sd">        The string used to separate values.  By default, this is any</span>
<span class="sd">        whitespace.</span>
<span class="sd">    converters : dict, optional</span>
<span class="sd">        A dictionary mapping column number to a function that will convert</span>
<span class="sd">        that column to a float.  E.g., if column 0 is a date string:</span>
<span class="sd">        ``converters = {0: datestr2num}``.  Converters can also be used to</span>
<span class="sd">        provide a default value for missing data (but see also `genfromtxt`):</span>
<span class="sd">        ``converters = {3: lambda s: float(s.strip() or 0)}``.  Default: None.</span>
<span class="sd">    skiprows : int, optional</span>
<span class="sd">        Skip the first `skiprows` lines; default: 0.</span>
<span class="sd">    usecols : sequence, optional</span>
<span class="sd">        Which columns to read, with 0 being the first.  For example,</span>
<span class="sd">        ``usecols = (1,4,5)`` will extract the 2nd, 5th and 6th columns.</span>
<span class="sd">        The default, None, results in all columns being read.</span>
<span class="sd">    unpack : bool, optional</span>
<span class="sd">        If True, the returned array is transposed, so that arguments may be</span>
<span class="sd">        unpacked using ``x, y, z = loadtxt(...)``.  When used with a structured</span>
<span class="sd">        data-type, arrays are returned for each field.  Default is False.</span>
<span class="sd">    ndmin : int, optional</span>
<span class="sd">        The returned array will have at least `ndmin` dimensions.</span>
<span class="sd">        Otherwise mono-dimensional axes will be squeezed.</span>
<span class="sd">        Legal values: 0 (default), 1 or 2.</span>

<span class="sd">        .. versionadded:: 1.6.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Data read from the text file.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    load, fromstring, fromregex</span>
<span class="sd">    genfromtxt : Load data with missing values handled as specified.</span>
<span class="sd">    scipy.io.loadmat : reads MATLAB data files</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function aims to be a fast reader for simply formatted files.  The</span>
<span class="sd">    `genfromtxt` function provides more sophisticated handling of, e.g.,</span>
<span class="sd">    lines with missing values.</span>

<span class="sd">    .. versionadded:: 1.10.0</span>

<span class="sd">    The strings produced by the Python float.hex method can be used as</span>
<span class="sd">    input for floats.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from io import StringIO   # StringIO behaves like a file object</span>
<span class="sd">    &gt;&gt;&gt; c = StringIO(&quot;0 1\\n2 3&quot;)</span>
<span class="sd">    &gt;&gt;&gt; np.loadtxt(c)</span>
<span class="sd">    array([[ 0.,  1.],</span>
<span class="sd">           [ 2.,  3.]])</span>

<span class="sd">    &gt;&gt;&gt; d = StringIO(&quot;M 21 72\\nF 35 58&quot;)</span>
<span class="sd">    &gt;&gt;&gt; np.loadtxt(d, dtype={&#39;names&#39;: (&#39;gender&#39;, &#39;age&#39;, &#39;weight&#39;),</span>
<span class="sd">    ...                      &#39;formats&#39;: (&#39;S1&#39;, &#39;i4&#39;, &#39;f4&#39;)})</span>
<span class="sd">    array([(&#39;M&#39;, 21, 72.0), (&#39;F&#39;, 35, 58.0)],</span>
<span class="sd">          dtype=[(&#39;gender&#39;, &#39;|S1&#39;), (&#39;age&#39;, &#39;&lt;i4&#39;), (&#39;weight&#39;, &#39;&lt;f4&#39;)])</span>

<span class="sd">    &gt;&gt;&gt; c = StringIO(&quot;1,0,2\\n3,0,4&quot;)</span>
<span class="sd">    &gt;&gt;&gt; x, y = np.loadtxt(c, delimiter=&#39;,&#39;, usecols=(0, 2), unpack=True)</span>
<span class="sd">    &gt;&gt;&gt; x</span>
<span class="sd">    array([ 1.,  3.])</span>
<span class="sd">    &gt;&gt;&gt; y</span>
<span class="sd">    array([ 2.,  4.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Type conversions for Py3 convenience</span>
    <span class="k">if</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comments</span><span class="p">,</span> <span class="p">(</span><span class="nb">basestring</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)):</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span><span class="n">asbytes</span><span class="p">(</span><span class="n">comments</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">comments</span> <span class="o">=</span> <span class="p">[</span><span class="n">asbytes</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span> <span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">comments</span><span class="p">]</span>

        <span class="c1"># Compile regex for comments beforehand</span>
        <span class="n">comments</span> <span class="o">=</span> <span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span> <span class="k">for</span> <span class="n">comment</span> <span class="ow">in</span> <span class="n">comments</span><span class="p">)</span>
        <span class="n">regex_comments</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">comments</span><span class="p">))</span>
    <span class="n">user_converters</span> <span class="o">=</span> <span class="n">converters</span>
    <span class="k">if</span> <span class="n">delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">delimiter</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">usecols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">usecols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">usecols</span><span class="p">)</span>

    <span class="n">fown</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">_is_string_like</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
            <span class="n">fown</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.gz&#39;</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">gzip</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">gzip</span><span class="o">.</span><span class="n">GzipFile</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">fname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.bz2&#39;</span><span class="p">):</span>
                <span class="kn">import</span> <span class="nn">bz2</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">bz2</span><span class="o">.</span><span class="n">BZ2File</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fname must be a string, file handle, or generator&#39;</span><span class="p">)</span>
    <span class="n">X</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">flatten_dtype</span><span class="p">(</span><span class="n">dt</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Unpack a structured data-type, and produce re-packing info.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dt</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># If the dtype is flattened, return.</span>
            <span class="c1"># If the dtype has a shape, the dtype occurs</span>
            <span class="c1"># in the list more than once.</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">([</span><span class="n">dt</span><span class="o">.</span><span class="n">base</span><span class="p">],</span> <span class="bp">None</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">packing</span> <span class="o">=</span> <span class="p">[(</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">list</span><span class="p">)]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">packing</span> <span class="o">=</span> <span class="p">[(</span><span class="n">dim</span><span class="o">*</span><span class="n">packing</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">packing</span><span class="o">*</span><span class="n">dim</span><span class="p">)]</span>
                <span class="k">return</span> <span class="p">([</span><span class="n">dt</span><span class="o">.</span><span class="n">base</span><span class="p">]</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">dt</span><span class="o">.</span><span class="n">shape</span><span class="p">)),</span> <span class="n">packing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">packing</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dt</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                <span class="n">tp</span><span class="p">,</span> <span class="nb">bytes</span> <span class="o">=</span> <span class="n">dt</span><span class="o">.</span><span class="n">fields</span><span class="p">[</span><span class="n">field</span><span class="p">]</span>
                <span class="n">flat_dt</span><span class="p">,</span> <span class="n">flat_packing</span> <span class="o">=</span> <span class="n">flatten_dtype</span><span class="p">(</span><span class="n">tp</span><span class="p">)</span>
                <span class="n">types</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flat_dt</span><span class="p">)</span>
                <span class="c1"># Avoid extra nesting for subarrays</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tp</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">packing</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">flat_packing</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">packing</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">flat_dt</span><span class="p">),</span> <span class="n">flat_packing</span><span class="p">))</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">types</span><span class="p">,</span> <span class="n">packing</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">pack_items</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">packing</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Pack items into nested lists based on re-packing info.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">packing</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">packing</span> <span class="ow">is</span> <span class="nb">tuple</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">packing</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">length</span><span class="p">,</span> <span class="n">subpacking</span> <span class="ow">in</span> <span class="n">packing</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pack_items</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">length</span><span class="p">],</span> <span class="n">subpacking</span><span class="p">))</span>
                <span class="n">start</span> <span class="o">+=</span> <span class="n">length</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">split_line</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Chop off comments, strip, and split at delimiter.</span>

<span class="sd">        Note that although the file is opened as text, this function</span>
<span class="sd">        returns bytes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">regex_comments</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="n">line</span><span class="p">),</span> <span class="n">maxsplit</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Make sure we&#39;re dealing with a proper dtype</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">defconv</span> <span class="o">=</span> <span class="n">_getconv</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Skip the first `skiprows` lines</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">skiprows</span><span class="p">):</span>
            <span class="nb">next</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>

        <span class="c1"># Read until we find a line with some values, and use</span>
        <span class="c1"># it to estimate the number of columns, N.</span>
        <span class="n">first_vals</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">first_vals</span><span class="p">:</span>
                <span class="n">first_line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">fh</span><span class="p">)</span>
                <span class="n">first_vals</span> <span class="o">=</span> <span class="n">split_line</span><span class="p">(</span><span class="n">first_line</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="c1"># End of lines reached</span>
            <span class="n">first_line</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">first_vals</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;loadtxt: Empty input file: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">usecols</span> <span class="ow">or</span> <span class="n">first_vals</span><span class="p">)</span>

        <span class="n">dtype_types</span><span class="p">,</span> <span class="n">packing</span> <span class="o">=</span> <span class="n">flatten_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We&#39;re dealing with a structured array, each field of</span>
            <span class="c1"># the dtype matches a column</span>
            <span class="n">converters</span> <span class="o">=</span> <span class="p">[</span><span class="n">_getconv</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span> <span class="k">for</span> <span class="n">dt</span> <span class="ow">in</span> <span class="n">dtype_types</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># All fields have the same dtype</span>
            <span class="n">converters</span> <span class="o">=</span> <span class="p">[</span><span class="n">defconv</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">packing</span> <span class="o">=</span> <span class="p">[(</span><span class="n">N</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)]</span>

        <span class="c1"># By preference, use the converters specified by the user</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">conv</span> <span class="ow">in</span> <span class="p">(</span><span class="n">user_converters</span> <span class="ow">or</span> <span class="p">{})</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">usecols</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">usecols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># Unused converter specified</span>
                    <span class="k">continue</span>
            <span class="n">converters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">conv</span>

        <span class="c1"># Parse each line, including the first</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">first_line</span><span class="p">],</span> <span class="n">fh</span><span class="p">)):</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">split_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">usecols</span><span class="p">:</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">usecols</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span> <span class="o">!=</span> <span class="n">N</span><span class="p">:</span>
                <span class="n">line_num</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">skiprows</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong number of columns at line </span><span class="si">%d</span><span class="s2">&quot;</span>
                                 <span class="o">%</span> <span class="n">line_num</span><span class="p">)</span>

            <span class="c1"># Convert each value according to its column and store</span>
            <span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="n">conv</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">converters</span><span class="p">,</span> <span class="n">vals</span><span class="p">)]</span>
            <span class="c1"># Then pack it according to the dtype&#39;s nesting</span>
            <span class="n">items</span> <span class="o">=</span> <span class="n">pack_items</span><span class="p">(</span><span class="n">items</span><span class="p">,</span> <span class="n">packing</span><span class="p">)</span>
            <span class="n">X</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fown</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
    <span class="c1"># Multicolumn data are returned with shape (1, N, M), i.e.</span>
    <span class="c1"># (1, 1, M) for a single row - remove the singleton dimension there</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">3</span> <span class="ow">and</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">X</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Verify that the array has at least dimensions `ndmin`.</span>
    <span class="c1"># Check correctness of the values of `ndmin`</span>
    <span class="k">if</span> <span class="n">ndmin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Illegal value of ndmin keyword: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">ndmin</span><span class="p">)</span>
    <span class="c1"># Tweak the size and shape of the arrays - remove extraneous dimensions</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="n">ndmin</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="c1"># and ensure we have the minimum number of dimensions asked for</span>
    <span class="c1"># - has to be in this order for the odd case ndmin=1, X.squeeze().ndim=0</span>
    <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">ndmin</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndmin</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ndmin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

    <span class="k">if</span> <span class="n">unpack</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype_types</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># For structured arrays, return an array for each field.</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">X</span><span class="p">[</span><span class="n">field</span><span class="p">]</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">X</span><span class="o">.</span><span class="n">T</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">X</span></div>


<div class="viewcode-block" id="savetxt"><a class="viewcode-back" href="../../../reference/generated/numpy.savetxt.html#numpy.savetxt">[docs]</a><span class="k">def</span> <span class="nf">savetxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">fmt</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">%.18e</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">newline</span><span class="o">=</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
            <span class="n">footer</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;# &#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Save an array to a text file.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : filename or file handle</span>
<span class="sd">        If the filename ends in ``.gz``, the file is automatically saved in</span>
<span class="sd">        compressed gzip format.  `loadtxt` understands gzipped files</span>
<span class="sd">        transparently.</span>
<span class="sd">    X : array_like</span>
<span class="sd">        Data to be saved to a text file.</span>
<span class="sd">    fmt : str or sequence of strs, optional</span>
<span class="sd">        A single format (%10.5f), a sequence of formats, or a</span>
<span class="sd">        multi-format string, e.g. &#39;Iteration %d -- %10.5f&#39;, in which</span>
<span class="sd">        case `delimiter` is ignored. For complex `X`, the legal options</span>
<span class="sd">        for `fmt` are:</span>
<span class="sd">            a) a single specifier, `fmt=&#39;%.4e&#39;`, resulting in numbers formatted</span>
<span class="sd">                like `&#39; (%s+%sj)&#39; % (fmt, fmt)`</span>
<span class="sd">            b) a full string specifying every real and imaginary part, e.g.</span>
<span class="sd">                `&#39; %.4e %+.4j %.4e %+.4j %.4e %+.4j&#39;` for 3 columns</span>
<span class="sd">            c) a list of specifiers, one per column - in this case, the real</span>
<span class="sd">                and imaginary part must have separate specifiers,</span>
<span class="sd">                e.g. `[&#39;%.3e + %.3ej&#39;, &#39;(%.15e%+.15ej)&#39;]` for 2 columns</span>
<span class="sd">    delimiter : str, optional</span>
<span class="sd">        String or character separating columns.</span>
<span class="sd">    newline : str, optional</span>
<span class="sd">        String or character separating lines.</span>

<span class="sd">        .. versionadded:: 1.5.0</span>
<span class="sd">    header : str, optional</span>
<span class="sd">        String that will be written at the beginning of the file.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    footer : str, optional</span>
<span class="sd">        String that will be written at the end of the file.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>
<span class="sd">    comments : str, optional</span>
<span class="sd">        String that will be prepended to the ``header`` and ``footer`` strings,</span>
<span class="sd">        to mark them as comments. Default: &#39;# &#39;,  as expected by e.g.</span>
<span class="sd">        ``numpy.loadtxt``.</span>

<span class="sd">        .. versionadded:: 1.7.0</span>


<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    save : Save an array to a binary file in NumPy ``.npy`` format</span>
<span class="sd">    savez : Save several arrays into an uncompressed ``.npz`` archive</span>
<span class="sd">    savez_compressed : Save several arrays into a compressed ``.npz`` archive</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Further explanation of the `fmt` parameter</span>
<span class="sd">    (``%[flag]width[.precision]specifier``):</span>

<span class="sd">    flags:</span>
<span class="sd">        ``-`` : left justify</span>

<span class="sd">        ``+`` : Forces to precede result with + or -.</span>

<span class="sd">        ``0`` : Left pad the number with zeros instead of space (see width).</span>

<span class="sd">    width:</span>
<span class="sd">        Minimum number of characters to be printed. The value is not truncated</span>
<span class="sd">        if it has more characters.</span>

<span class="sd">    precision:</span>
<span class="sd">        - For integer specifiers (eg. ``d,i,o,x``), the minimum number of</span>
<span class="sd">          digits.</span>
<span class="sd">        - For ``e, E`` and ``f`` specifiers, the number of digits to print</span>
<span class="sd">          after the decimal point.</span>
<span class="sd">        - For ``g`` and ``G``, the maximum number of significant digits.</span>
<span class="sd">        - For ``s``, the maximum number of characters.</span>

<span class="sd">    specifiers:</span>
<span class="sd">        ``c`` : character</span>

<span class="sd">        ``d`` or ``i`` : signed decimal integer</span>

<span class="sd">        ``e`` or ``E`` : scientific notation with ``e`` or ``E``.</span>

<span class="sd">        ``f`` : decimal floating point</span>

<span class="sd">        ``g,G`` : use the shorter of ``e,E`` or ``f``</span>

<span class="sd">        ``o`` : signed octal</span>

<span class="sd">        ``s`` : string of characters</span>

<span class="sd">        ``u`` : unsigned decimal integer</span>

<span class="sd">        ``x,X`` : unsigned hexadecimal integer</span>

<span class="sd">    This explanation of ``fmt`` is not complete, for an exhaustive</span>
<span class="sd">    specification see [1]_.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] `Format Specification Mini-Language</span>
<span class="sd">           &lt;http://docs.python.org/library/string.html#</span>
<span class="sd">           format-specification-mini-language&gt;`_, Python Documentation.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; x = y = z = np.arange(0.0,5.0,1.0)</span>
<span class="sd">    &gt;&gt;&gt; np.savetxt(&#39;test.out&#39;, x, delimiter=&#39;,&#39;)   # X is an array</span>
<span class="sd">    &gt;&gt;&gt; np.savetxt(&#39;test.out&#39;, (x,y,z))   # x,y,z equal sized 1D arrays</span>
<span class="sd">    &gt;&gt;&gt; np.savetxt(&#39;test.out&#39;, x, fmt=&#39;%1.4e&#39;)   # use exponential notation</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Py3 conversions first</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">fmt</span> <span class="o">=</span> <span class="n">asstr</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
    <span class="n">delimiter</span> <span class="o">=</span> <span class="n">asstr</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>

    <span class="n">own_fh</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="n">_is_string_like</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
        <span class="n">own_fh</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="n">fname</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;.gz&#39;</span><span class="p">):</span>
            <span class="kn">import</span> <span class="nn">gzip</span>
            <span class="n">fh</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fh</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;write&#39;</span><span class="p">):</span>
        <span class="n">fh</span> <span class="o">=</span> <span class="n">fname</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fname must be a string or file handle&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>

        <span class="c1"># Handle 1-dimensional arrays</span>
        <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Common case -- 1d array of numbers</span>
            <span class="k">if</span> <span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                <span class="n">ncol</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Complex dtype -- each field indicates a separate column</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ncol</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">descr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">iscomplex_X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="c1"># `fmt` can be a string with multiple insertion points or a</span>
        <span class="c1"># list of formats.  E.g. &#39;%10.5f\t%10d&#39; or (&#39;%10.5f&#39;, &#39;$10d&#39;)</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ncol</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;fmt has wrong shape.  </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">fmt</span><span class="p">))</span>
            <span class="n">format</span> <span class="o">=</span> <span class="n">asstr</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">asstr</span><span class="p">,</span> <span class="n">fmt</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">n_fmt_chars</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;%&#39;</span><span class="p">)</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;fmt has wrong number of </span><span class="si">%%</span><span class="s1"> formats:  </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">fmt</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_fmt_chars</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iscomplex_X</span><span class="p">:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; (</span><span class="si">%s</span><span class="s1">+</span><span class="si">%s</span><span class="s1">j)&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fmt</span><span class="p">,</span> <span class="n">fmt</span><span class="p">),</span> <span class="p">]</span> <span class="o">*</span> <span class="n">ncol</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fmt</span> <span class="o">=</span> <span class="p">[</span><span class="n">fmt</span><span class="p">,</span> <span class="p">]</span> <span class="o">*</span> <span class="n">ncol</span>
                <span class="n">format</span> <span class="o">=</span> <span class="n">delimiter</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">fmt</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">iscomplex_X</span> <span class="ow">and</span> <span class="n">n_fmt_chars</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">ncol</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">error</span>
            <span class="k">elif</span> <span class="p">((</span><span class="ow">not</span> <span class="n">iscomplex_X</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n_fmt_chars</span> <span class="o">!=</span> <span class="n">ncol</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">error</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">format</span> <span class="o">=</span> <span class="n">fmt</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;invalid fmt: </span><span class="si">%r</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fmt</span><span class="p">,))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">comments</span><span class="p">)</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="n">comments</span> <span class="o">+</span> <span class="n">header</span> <span class="o">+</span> <span class="n">newline</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">iscomplex_X</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
                <span class="n">row2</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">number</span> <span class="ow">in</span> <span class="n">row</span><span class="p">:</span>
                    <span class="n">row2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
                    <span class="n">row2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">number</span><span class="o">.</span><span class="n">imag</span><span class="p">)</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="n">format</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">row2</span><span class="p">)</span> <span class="o">+</span> <span class="n">newline</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">X</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="n">format</span> <span class="o">%</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="o">+</span> <span class="n">newline</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Mismatch between array dtype (&#39;</span><span class="si">%s</span><span class="s2">&#39;) and &quot;</span>
                                    <span class="s2">&quot;format specifier (&#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span>
                                    <span class="o">%</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">X</span><span class="o">.</span><span class="n">dtype</span><span class="p">),</span> <span class="n">format</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">footer</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">footer</span> <span class="o">=</span> <span class="n">footer</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">comments</span><span class="p">)</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="n">comments</span> <span class="o">+</span> <span class="n">footer</span> <span class="o">+</span> <span class="n">newline</span><span class="p">))</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">own_fh</span><span class="p">:</span>
            <span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="fromregex"><a class="viewcode-back" href="../../../reference/generated/numpy.fromregex.html#numpy.fromregex">[docs]</a><span class="k">def</span> <span class="nf">fromregex</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="n">regexp</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Construct an array from a text file, using regular expression parsing.</span>

<span class="sd">    The returned array is always a structured array, and is constructed from</span>
<span class="sd">    all matches of the regular expression in the file. Groups in the regular</span>
<span class="sd">    expression are converted to fields of the structured array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : str or file</span>
<span class="sd">        File name or file object to read.</span>
<span class="sd">    regexp : str or regexp</span>
<span class="sd">        Regular expression used to parse the file.</span>
<span class="sd">        Groups in the regular expression correspond to fields in the dtype.</span>
<span class="sd">    dtype : dtype or list of dtypes</span>
<span class="sd">        Dtype for the structured array.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    output : ndarray</span>
<span class="sd">        The output array, containing the part of the content of `file` that</span>
<span class="sd">        was matched by `regexp`. `output` is always a structured array.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    TypeError</span>
<span class="sd">        When `dtype` is not a valid dtype for a structured array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fromstring, loadtxt</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Dtypes for structured arrays can be specified in several forms, but all</span>
<span class="sd">    forms specify at least the data type and field name. For details see</span>
<span class="sd">    `doc.structured_arrays`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; f = open(&#39;test.dat&#39;, &#39;w&#39;)</span>
<span class="sd">    &gt;&gt;&gt; f.write(&quot;1312 foo\\n1534  bar\\n444   qux&quot;)</span>
<span class="sd">    &gt;&gt;&gt; f.close()</span>

<span class="sd">    &gt;&gt;&gt; regexp = r&quot;(\\d+)\\s+(...)&quot;  # match [digits, whitespace, anything]</span>
<span class="sd">    &gt;&gt;&gt; output = np.fromregex(&#39;test.dat&#39;, regexp,</span>
<span class="sd">    ...                       [(&#39;num&#39;, np.int64), (&#39;key&#39;, &#39;S3&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; output</span>
<span class="sd">    array([(1312L, &#39;foo&#39;), (1534L, &#39;bar&#39;), (444L, &#39;qux&#39;)],</span>
<span class="sd">          dtype=[(&#39;num&#39;, &#39;&lt;i8&#39;), (&#39;key&#39;, &#39;|S3&#39;)])</span>
<span class="sd">    &gt;&gt;&gt; output[&#39;num&#39;]</span>
<span class="sd">    array([1312, 1534,  444], dtype=int64)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">own_fh</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s2">&quot;read&quot;</span><span class="p">):</span>
        <span class="nb">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="nb">file</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">own_fh</span> <span class="o">=</span> <span class="bp">True</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">regexp</span><span class="p">,</span> <span class="s1">&#39;match&#39;</span><span class="p">):</span>
            <span class="n">regexp</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="n">regexp</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">):</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="n">regexp</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="nb">file</span><span class="o">.</span><span class="n">read</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">seq</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="c1"># Only one group is in the regexp.</span>
            <span class="c1"># Create the new array as a single data-type and then</span>
            <span class="c1">#   re-interpret as a single-field structured array.</span>
            <span class="n">newdtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">[</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">newdtype</span><span class="p">)</span>
            <span class="n">output</span><span class="o">.</span><span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output</span>
    <span class="k">finally</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">own_fh</span><span class="p">:</span>
            <span class="nb">file</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<span class="c1">#####--------------------------------------------------------------------------</span>
<span class="c1">#---- --- ASCII functions ---</span>
<span class="c1">#####--------------------------------------------------------------------------</span>


<div class="viewcode-block" id="genfromtxt"><a class="viewcode-back" href="../../../reference/generated/numpy.genfromtxt.html#numpy.genfromtxt">[docs]</a><span class="k">def</span> <span class="nf">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="s1">&#39;#&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">skip_header</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">skip_footer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">converters</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">missing_values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">filling_values</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">names</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">excludelist</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">deletechars</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span>
               <span class="n">replace_space</span><span class="o">=</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="n">autostrip</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">case_sensitive</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">defaultfmt</span><span class="o">=</span><span class="s2">&quot;f</span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">usemask</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">loose</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
               <span class="n">invalid_raise</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">max_rows</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load data from a text file, with missing values handled as specified.</span>

<span class="sd">    Each line past the first `skip_header` lines is split at the `delimiter`</span>
<span class="sd">    character, and characters following the `comments` character are discarded.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : file or str</span>
<span class="sd">        File, filename, or generator to read.  If the filename extension is</span>
<span class="sd">        `.gz` or `.bz2`, the file is first decompressed. Note that</span>
<span class="sd">        generators must return byte strings in Python 3k.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Data type of the resulting array.</span>
<span class="sd">        If None, the dtypes will be determined by the contents of each</span>
<span class="sd">        column, individually.</span>
<span class="sd">    comments : str, optional</span>
<span class="sd">        The character used to indicate the start of a comment.</span>
<span class="sd">        All the characters occurring on a line after a comment are discarded</span>
<span class="sd">    delimiter : str, int, or sequence, optional</span>
<span class="sd">        The string used to separate values.  By default, any consecutive</span>
<span class="sd">        whitespaces act as delimiter.  An integer or sequence of integers</span>
<span class="sd">        can also be provided as width(s) of each field.</span>
<span class="sd">    skiprows : int, optional</span>
<span class="sd">        `skiprows` was removed in numpy 1.10. Please use `skip_header` instead.</span>
<span class="sd">    skip_header : int, optional</span>
<span class="sd">        The number of lines to skip at the beginning of the file.</span>
<span class="sd">    skip_footer : int, optional</span>
<span class="sd">        The number of lines to skip at the end of the file.</span>
<span class="sd">    converters : variable, optional</span>
<span class="sd">        The set of functions that convert the data of a column to a value.</span>
<span class="sd">        The converters can also be used to provide a default value</span>
<span class="sd">        for missing data: ``converters = {3: lambda s: float(s or 0)}``.</span>
<span class="sd">    missing : variable, optional</span>
<span class="sd">        `missing` was removed in numpy 1.10. Please use `missing_values`</span>
<span class="sd">        instead.</span>
<span class="sd">    missing_values : variable, optional</span>
<span class="sd">        The set of strings corresponding to missing data.</span>
<span class="sd">    filling_values : variable, optional</span>
<span class="sd">        The set of values to be used as default when the data are missing.</span>
<span class="sd">    usecols : sequence, optional</span>
<span class="sd">        Which columns to read, with 0 being the first.  For example,</span>
<span class="sd">        ``usecols = (1, 4, 5)`` will extract the 2nd, 5th and 6th columns.</span>
<span class="sd">    names : {None, True, str, sequence}, optional</span>
<span class="sd">        If `names` is True, the field names are read from the first valid line</span>
<span class="sd">        after the first `skip_header` lines.</span>
<span class="sd">        If `names` is a sequence or a single-string of comma-separated names,</span>
<span class="sd">        the names will be used to define the field names in a structured dtype.</span>
<span class="sd">        If `names` is None, the names of the dtype fields will be used, if any.</span>
<span class="sd">    excludelist : sequence, optional</span>
<span class="sd">        A list of names to exclude. This list is appended to the default list</span>
<span class="sd">        [&#39;return&#39;,&#39;file&#39;,&#39;print&#39;]. Excluded names are appended an underscore:</span>
<span class="sd">        for example, `file` would become `file_`.</span>
<span class="sd">    deletechars : str, optional</span>
<span class="sd">        A string combining invalid characters that must be deleted from the</span>
<span class="sd">        names.</span>
<span class="sd">    defaultfmt : str, optional</span>
<span class="sd">        A format used to define default field names, such as &quot;f%i&quot; or &quot;f_%02i&quot;.</span>
<span class="sd">    autostrip : bool, optional</span>
<span class="sd">        Whether to automatically strip white spaces from the variables.</span>
<span class="sd">    replace_space : char, optional</span>
<span class="sd">        Character(s) used in replacement of white spaces in the variables</span>
<span class="sd">        names. By default, use a &#39;_&#39;.</span>
<span class="sd">    case_sensitive : {True, False, &#39;upper&#39;, &#39;lower&#39;}, optional</span>
<span class="sd">        If True, field names are case sensitive.</span>
<span class="sd">        If False or &#39;upper&#39;, field names are converted to upper case.</span>
<span class="sd">        If &#39;lower&#39;, field names are converted to lower case.</span>
<span class="sd">    unpack : bool, optional</span>
<span class="sd">        If True, the returned array is transposed, so that arguments may be</span>
<span class="sd">        unpacked using ``x, y, z = loadtxt(...)``</span>
<span class="sd">    usemask : bool, optional</span>
<span class="sd">        If True, return a masked array.</span>
<span class="sd">        If False, return a regular array.</span>
<span class="sd">    loose : bool, optional</span>
<span class="sd">        If True, do not raise errors for invalid values.</span>
<span class="sd">    invalid_raise : bool, optional</span>
<span class="sd">        If True, an exception is raised if an inconsistency is detected in the</span>
<span class="sd">        number of columns.</span>
<span class="sd">        If False, a warning is emitted and the offending lines are skipped.</span>
<span class="sd">    max_rows : int,  optional</span>
<span class="sd">        The maximum number of rows to read. Must not be used with skip_footer</span>
<span class="sd">        at the same time.  If given, the value must be at least 1. Default is</span>
<span class="sd">        to read the entire file.</span>

<span class="sd">        .. versionadded:: 1.10.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    out : ndarray</span>
<span class="sd">        Data read from the text file. If `usemask` is True, this is a</span>
<span class="sd">        masked array.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.loadtxt : equivalent function when no data is missing.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    * When spaces are used as delimiters, or when no delimiter has been given</span>
<span class="sd">      as input, there should not be any missing data between two fields.</span>
<span class="sd">    * When the variables are named (either by a flexible dtype or with `names`,</span>
<span class="sd">      there must not be any header in the file (else a ValueError</span>
<span class="sd">      exception is raised).</span>
<span class="sd">    * Individual values are not stripped of spaces by default.</span>
<span class="sd">      When using a custom converter, make sure the function does remove spaces.</span>

<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [1] Numpy User Guide, section `I/O with Numpy</span>
<span class="sd">           &lt;http://docs.scipy.org/doc/numpy/user/basics.io.genfromtxt.html&gt;`_.</span>

<span class="sd">    Examples</span>
<span class="sd">    ---------</span>
<span class="sd">    &gt;&gt;&gt; from io import StringIO</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>

<span class="sd">    Comma delimited file with mixed dtype</span>

<span class="sd">    &gt;&gt;&gt; s = StringIO(&quot;1,1.3,abcde&quot;)</span>
<span class="sd">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=[(&#39;myint&#39;,&#39;i8&#39;),(&#39;myfloat&#39;,&#39;f8&#39;),</span>
<span class="sd">    ... (&#39;mystring&#39;,&#39;S5&#39;)], delimiter=&quot;,&quot;)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array((1, 1.3, &#39;abcde&#39;),</span>
<span class="sd">          dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;|S5&#39;)])</span>

<span class="sd">    Using dtype = None</span>

<span class="sd">    &gt;&gt;&gt; s.seek(0) # needed for StringIO example only</span>
<span class="sd">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=None,</span>
<span class="sd">    ... names = [&#39;myint&#39;,&#39;myfloat&#39;,&#39;mystring&#39;], delimiter=&quot;,&quot;)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array((1, 1.3, &#39;abcde&#39;),</span>
<span class="sd">          dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;|S5&#39;)])</span>

<span class="sd">    Specifying dtype and names</span>

<span class="sd">    &gt;&gt;&gt; s.seek(0)</span>
<span class="sd">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=&quot;i8,f8,S5&quot;,</span>
<span class="sd">    ... names=[&#39;myint&#39;,&#39;myfloat&#39;,&#39;mystring&#39;], delimiter=&quot;,&quot;)</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array((1, 1.3, &#39;abcde&#39;),</span>
<span class="sd">          dtype=[(&#39;myint&#39;, &#39;&lt;i8&#39;), (&#39;myfloat&#39;, &#39;&lt;f8&#39;), (&#39;mystring&#39;, &#39;|S5&#39;)])</span>

<span class="sd">    An example with fixed-width columns</span>

<span class="sd">    &gt;&gt;&gt; s = StringIO(&quot;11.3abcde&quot;)</span>
<span class="sd">    &gt;&gt;&gt; data = np.genfromtxt(s, dtype=None, names=[&#39;intvar&#39;,&#39;fltvar&#39;,&#39;strvar&#39;],</span>
<span class="sd">    ...     delimiter=[1,3,5])</span>
<span class="sd">    &gt;&gt;&gt; data</span>
<span class="sd">    array((1, 1.3, &#39;abcde&#39;),</span>
<span class="sd">          dtype=[(&#39;intvar&#39;, &#39;&lt;i8&#39;), (&#39;fltvar&#39;, &#39;&lt;f8&#39;), (&#39;strvar&#39;, &#39;|S5&#39;)])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">max_rows</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">skip_footer</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;The keywords &#39;skip_footer&#39; and &#39;max_rows&#39; can not be &quot;</span>
                    <span class="s2">&quot;specified at the same time.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_rows</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;max_rows&#39; must be at least 1.&quot;</span><span class="p">)</span>

    <span class="c1"># Py3 data conversions to bytes, for convenience</span>
    <span class="k">if</span> <span class="n">comments</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">comments</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="n">comments</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">delimiter</span><span class="p">,</span> <span class="nb">unicode</span><span class="p">):</span>
        <span class="n">delimiter</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="n">delimiter</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">missing_values</span><span class="p">,</span> <span class="p">(</span><span class="nb">unicode</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">missing_values</span> <span class="o">=</span> <span class="n">asbytes_nested</span><span class="p">(</span><span class="n">missing_values</span><span class="p">)</span>

    <span class="c1">#</span>
    <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy.ma</span> <span class="kn">import</span> <span class="n">MaskedArray</span><span class="p">,</span> <span class="n">make_mask_descr</span>
    <span class="c1"># Check the input dictionary of converters</span>
    <span class="n">user_converters</span> <span class="o">=</span> <span class="n">converters</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_converters</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;The input argument &#39;converter&#39; should be a valid dictionary &quot;</span>
            <span class="s2">&quot;(got &#39;</span><span class="si">%s</span><span class="s2">&#39; instead)&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">user_converters</span><span class="p">))</span>

    <span class="c1"># Initialize the filehandle, the LineSplitter and the NameValidator</span>
    <span class="n">own_fhd</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sys</span><span class="o">.</span><span class="n">version_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">fhd</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">_datasource</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;rbU&#39;</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fhd</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">lib</span><span class="o">.</span><span class="n">_datasource</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">))</span>
            <span class="n">own_fhd</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fhd</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
            <span class="s2">&quot;fname must be a string, filehandle, or generator. &quot;</span>
            <span class="s2">&quot;(got </span><span class="si">%s</span><span class="s2"> instead)&quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">fname</span><span class="p">))</span>

    <span class="n">split_line</span> <span class="o">=</span> <span class="n">LineSplitter</span><span class="p">(</span><span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">,</span> <span class="n">comments</span><span class="o">=</span><span class="n">comments</span><span class="p">,</span>
                              <span class="n">autostrip</span><span class="o">=</span><span class="n">autostrip</span><span class="p">)</span><span class="o">.</span><span class="n">_handyman</span>
    <span class="n">validate_names</span> <span class="o">=</span> <span class="n">NameValidator</span><span class="p">(</span><span class="n">excludelist</span><span class="o">=</span><span class="n">excludelist</span><span class="p">,</span>
                                   <span class="n">deletechars</span><span class="o">=</span><span class="n">deletechars</span><span class="p">,</span>
                                   <span class="n">case_sensitive</span><span class="o">=</span><span class="n">case_sensitive</span><span class="p">,</span>
                                   <span class="n">replace_space</span><span class="o">=</span><span class="n">replace_space</span><span class="p">)</span>

    <span class="c1"># Skip the first `skip_header` rows</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">skip_header</span><span class="p">):</span>
        <span class="nb">next</span><span class="p">(</span><span class="n">fhd</span><span class="p">)</span>

    <span class="c1"># Keep on until we find the first valid values</span>
    <span class="n">first_values</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">first_values</span><span class="p">:</span>
            <span class="n">first_line</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">fhd</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">comments</span> <span class="ow">in</span> <span class="n">first_line</span><span class="p">:</span>
                    <span class="n">first_line</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">first_line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">comments</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="n">first_values</span> <span class="o">=</span> <span class="n">split_line</span><span class="p">(</span><span class="n">first_line</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
        <span class="c1"># return an empty array if the datafile is empty</span>
        <span class="n">first_line</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="n">first_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;genfromtxt: Empty input file: &quot;</span><span class="si">%s</span><span class="s1">&quot;&#39;</span> <span class="o">%</span> <span class="n">fname</span><span class="p">)</span>

    <span class="c1"># Should we take the first values as names ?</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">fval</span> <span class="o">=</span> <span class="n">first_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">fval</span> <span class="ow">in</span> <span class="n">comments</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">first_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Check the columns to use: make sure `usecols` is a list</span>
    <span class="k">if</span> <span class="n">usecols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="n">_</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">usecols</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">usecols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">usecols</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="n">usecols</span> <span class="o">=</span> <span class="p">[</span><span class="n">usecols</span><span class="p">,</span> <span class="p">]</span>
    <span class="n">nbcols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">usecols</span> <span class="ow">or</span> <span class="n">first_values</span><span class="p">)</span>

    <span class="c1"># Check the names and overwrite the dtype.names if needed</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">validate_names</span><span class="p">([</span><span class="n">_bytes_to_name</span><span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
                                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">first_values</span><span class="p">])</span>
        <span class="n">first_line</span> <span class="o">=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">_is_string_like</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">validate_names</span><span class="p">([</span><span class="n">_</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">names</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)])</span>
    <span class="k">elif</span> <span class="n">names</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="n">validate_names</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
    <span class="c1"># Get the dtype</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">easy_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">defaultfmt</span><span class="o">=</span><span class="n">defaultfmt</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">,</span>
                           <span class="n">excludelist</span><span class="o">=</span><span class="n">excludelist</span><span class="p">,</span>
                           <span class="n">deletechars</span><span class="o">=</span><span class="n">deletechars</span><span class="p">,</span>
                           <span class="n">case_sensitive</span><span class="o">=</span><span class="n">case_sensitive</span><span class="p">,</span>
                           <span class="n">replace_space</span><span class="o">=</span><span class="n">replace_space</span><span class="p">)</span>
    <span class="c1"># Make sure the names is a list (for 2.5)</span>
    <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">usecols</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">usecols</span><span class="p">):</span>
            <span class="c1"># if usecols is a list of names, convert to a list of indices</span>
            <span class="k">if</span> <span class="n">_is_string_like</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">usecols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">current</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">usecols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">current</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_values</span><span class="p">)</span>
        <span class="c1"># If the dtype is not None, make sure we update it</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nbcols</span><span class="p">):</span>
            <span class="n">descr</span> <span class="o">=</span> <span class="n">dtype</span><span class="o">.</span><span class="n">descr</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([</span><span class="n">descr</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">usecols</span><span class="p">])</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="c1"># If `names` is not None, update the names</span>
        <span class="k">elif</span> <span class="p">(</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nbcols</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">usecols</span><span class="p">]</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">):</span>
        <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="c1"># Process the missing values ...............................</span>
    <span class="c1"># Rename missing_values for convenience</span>
    <span class="n">user_missing_values</span> <span class="o">=</span> <span class="n">missing_values</span> <span class="ow">or</span> <span class="p">()</span>

    <span class="c1"># Define the list of missing_values (one column: one list)</span>
    <span class="n">missing_values</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">([</span><span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nbcols</span><span class="p">)]</span>

    <span class="c1"># We have a dictionary: process it field by field</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_missing_values</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="c1"># Loop on the items</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">user_missing_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Is the key a string ?</span>
            <span class="k">if</span> <span class="n">_is_string_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Transform it into an integer</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># We couldn&#39;t find it: the name must have been dropped</span>
                    <span class="k">continue</span>
            <span class="c1"># Redefine the key as needed if it&#39;s a column number</span>
            <span class="k">if</span> <span class="n">usecols</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">usecols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="c1"># Transform the value as a list of string</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">val</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">),</span> <span class="p">]</span>
            <span class="c1"># Add the value(s) to the current list of missing</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># None acts as default</span>
                <span class="k">for</span> <span class="n">miss</span> <span class="ow">in</span> <span class="n">missing_values</span><span class="p">:</span>
                    <span class="n">miss</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">missing_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="c1"># We have a sequence : each item matches a column</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_missing_values</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">user_missing_values</span><span class="p">,</span> <span class="n">missing_values</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">entry</span><span class="p">:</span>
                <span class="n">entry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="c1"># We have a string : apply it to all entries</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_missing_values</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">user_value</span> <span class="o">=</span> <span class="n">user_missing_values</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">asbytes</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">missing_values</span><span class="p">:</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">user_value</span><span class="p">)</span>
    <span class="c1"># We have something else: apply it to all entries</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">missing_values</span><span class="p">:</span>
            <span class="n">entry</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">user_missing_values</span><span class="p">)])</span>

    <span class="c1"># Process the filling_values ...............................</span>
    <span class="c1"># Rename the input for convenience</span>
    <span class="n">user_filling_values</span> <span class="o">=</span> <span class="n">filling_values</span>
    <span class="k">if</span> <span class="n">user_filling_values</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">user_filling_values</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="c1"># Define the default</span>
    <span class="n">filling_values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbcols</span>
    <span class="c1"># We have a dictionary : update each entry individually</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_filling_values</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="n">user_filling_values</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">_is_string_like</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># Transform it into an integer</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># We couldn&#39;t find it: the name must have been dropped,</span>
                    <span class="k">continue</span>
            <span class="c1"># Redefine the key if it&#39;s a column number and usecols is defined</span>
            <span class="k">if</span> <span class="n">usecols</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="n">usecols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="c1"># Add the value to the list</span>
            <span class="n">filling_values</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
    <span class="c1"># We have a sequence : update on a one-to-one basis</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">user_filling_values</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">user_filling_values</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;=</span> <span class="n">nbcols</span><span class="p">):</span>
            <span class="n">filling_values</span><span class="p">[:</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">user_filling_values</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filling_values</span> <span class="o">=</span> <span class="n">user_filling_values</span><span class="p">[:</span><span class="n">nbcols</span><span class="p">]</span>
    <span class="c1"># We have something else : use it for all entries</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">filling_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">user_filling_values</span><span class="p">]</span> <span class="o">*</span> <span class="n">nbcols</span>

    <span class="c1"># Initialize the converters ................................</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Note: we can&#39;t use a [...]*nbcols, as we would have 3 times the same</span>
        <span class="c1"># ... converter, instead of 3 different converters.</span>
        <span class="n">converters</span> <span class="o">=</span> <span class="p">[</span><span class="n">StringConverter</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="n">missing_values</span><span class="o">=</span><span class="n">miss</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>
                      <span class="k">for</span> <span class="p">(</span><span class="n">miss</span><span class="p">,</span> <span class="n">fill</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">missing_values</span><span class="p">,</span> <span class="n">filling_values</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">dtype_flat</span> <span class="o">=</span> <span class="n">flatten_dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">flatten_base</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c1"># Initialize the converters</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype_flat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Flexible type : get a converter from each dtype</span>
            <span class="n">zipit</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">dtype_flat</span><span class="p">,</span> <span class="n">missing_values</span><span class="p">,</span> <span class="n">filling_values</span><span class="p">)</span>
            <span class="n">converters</span> <span class="o">=</span> <span class="p">[</span><span class="n">StringConverter</span><span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">locked</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                          <span class="n">missing_values</span><span class="o">=</span><span class="n">miss</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">miss</span><span class="p">,</span> <span class="n">fill</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zipit</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Set to a default converter (but w/ different missing values)</span>
            <span class="n">zipit</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">missing_values</span><span class="p">,</span> <span class="n">filling_values</span><span class="p">)</span>
            <span class="n">converters</span> <span class="o">=</span> <span class="p">[</span><span class="n">StringConverter</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">locked</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                                          <span class="n">missing_values</span><span class="o">=</span><span class="n">miss</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">fill</span><span class="p">)</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">miss</span><span class="p">,</span> <span class="n">fill</span><span class="p">)</span> <span class="ow">in</span> <span class="n">zipit</span><span class="p">]</span>
    <span class="c1"># Update the converters to use the user-defined ones</span>
    <span class="n">uc_update</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">conv</span><span class="p">)</span> <span class="ow">in</span> <span class="n">user_converters</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># If the converter is specified by column names, use the index instead</span>
        <span class="k">if</span> <span class="n">_is_string_like</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">usecols</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">usecols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Unused converter specified</span>
                <span class="k">continue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span>
        <span class="c1"># Find the value to test - first_line is not filtered by usecols:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_line</span><span class="p">):</span>
            <span class="n">testing_value</span> <span class="o">=</span> <span class="n">first_values</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">testing_value</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">converters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">locked</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                             <span class="n">testing_value</span><span class="o">=</span><span class="n">testing_value</span><span class="p">,</span>
                             <span class="n">default</span><span class="o">=</span><span class="n">filling_values</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                             <span class="n">missing_values</span><span class="o">=</span><span class="n">missing_values</span><span class="p">[</span><span class="n">i</span><span class="p">],)</span>
        <span class="n">uc_update</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">conv</span><span class="p">))</span>
    <span class="c1"># Make sure we have the corrected keys in user_converters...</span>
    <span class="n">user_converters</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">uc_update</span><span class="p">)</span>

    <span class="c1"># Fixme: possible error as following variable never used.</span>
    <span class="c1">#miss_chars = [_.missing_values for _ in converters]</span>

    <span class="c1"># Initialize the output lists ...</span>
    <span class="c1"># ... rows</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">append_to_rows</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="n">append</span>
    <span class="c1"># ... masks</span>
    <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
        <span class="n">masks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">append_to_masks</span> <span class="o">=</span> <span class="n">masks</span><span class="o">.</span><span class="n">append</span>
    <span class="c1"># ... invalid</span>
    <span class="n">invalid</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">append_to_invalid</span> <span class="o">=</span> <span class="n">invalid</span><span class="o">.</span><span class="n">append</span>

    <span class="c1"># Parse each line</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">([</span><span class="n">first_line</span><span class="p">,</span> <span class="p">],</span> <span class="n">fhd</span><span class="p">)):</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">split_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">nbvalues</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="c1"># Skip an empty line</span>
        <span class="k">if</span> <span class="n">nbvalues</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">usecols</span><span class="p">:</span>
            <span class="c1"># Select only the columns we need</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="n">_</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">usecols</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                <span class="n">append_to_invalid</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">skip_header</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nbvalues</span><span class="p">))</span>
                <span class="k">continue</span>
        <span class="k">elif</span> <span class="n">nbvalues</span> <span class="o">!=</span> <span class="n">nbcols</span><span class="p">:</span>
            <span class="n">append_to_invalid</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">skip_header</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nbvalues</span><span class="p">))</span>
            <span class="k">continue</span>
        <span class="c1"># Store the values</span>
        <span class="n">append_to_rows</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">values</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
            <span class="n">append_to_masks</span><span class="p">(</span><span class="nb">tuple</span><span class="p">([</span><span class="n">v</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">in</span> <span class="n">m</span>
                                   <span class="k">for</span> <span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">values</span><span class="p">,</span>
                                                     <span class="n">missing_values</span><span class="p">)]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">==</span> <span class="n">max_rows</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="k">if</span> <span class="n">own_fhd</span><span class="p">:</span>
        <span class="n">fhd</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># Upgrade the converters (if needed)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">converter</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">converters</span><span class="p">):</span>
            <span class="n">current_column</span> <span class="o">=</span> <span class="p">[</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">i</span><span class="p">)(</span><span class="n">_m</span><span class="p">)</span> <span class="k">for</span> <span class="n">_m</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">converter</span><span class="o">.</span><span class="n">iterupgrade</span><span class="p">(</span><span class="n">current_column</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">ConverterLockError</span><span class="p">:</span>
                <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;Converter #</span><span class="si">%i</span><span class="s2"> is locked and cannot be upgraded: &quot;</span> <span class="o">%</span> <span class="n">i</span>
                <span class="n">current_column</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">rows</span><span class="p">)</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current_column</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">converter</span><span class="o">.</span><span class="n">upgrade</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">except</span> <span class="p">(</span><span class="n">ConverterError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
                        <span class="n">errmsg</span> <span class="o">+=</span> <span class="s2">&quot;(occurred line #</span><span class="si">%i</span><span class="s2"> for value &#39;</span><span class="si">%s</span><span class="s2">&#39;)&quot;</span>
                        <span class="n">errmsg</span> <span class="o">%=</span> <span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">skip_header</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                        <span class="k">raise</span> <span class="n">ConverterError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>

    <span class="c1"># Check that we don&#39;t have invalid values</span>
    <span class="n">nbinvalid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">invalid</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nbinvalid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">nbrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span> <span class="o">+</span> <span class="n">nbinvalid</span> <span class="o">-</span> <span class="n">skip_footer</span>
        <span class="c1"># Construct the error message</span>
        <span class="n">template</span> <span class="o">=</span> <span class="s2">&quot;    Line #</span><span class="si">%%</span><span class="s2">i (got </span><span class="si">%%</span><span class="s2">i columns instead of </span><span class="si">%i</span><span class="s2">)&quot;</span> <span class="o">%</span> <span class="n">nbcols</span>
        <span class="k">if</span> <span class="n">skip_footer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">nbinvalid_skipped</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">invalid</span>
                                     <span class="k">if</span> <span class="n">_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nbrows</span> <span class="o">+</span> <span class="n">skip_header</span><span class="p">])</span>
            <span class="n">invalid</span> <span class="o">=</span> <span class="n">invalid</span><span class="p">[:</span><span class="n">nbinvalid</span> <span class="o">-</span> <span class="n">nbinvalid_skipped</span><span class="p">]</span>
            <span class="n">skip_footer</span> <span class="o">-=</span> <span class="n">nbinvalid_skipped</span>
<span class="c1">#</span>
<span class="c1">#            nbrows -= skip_footer</span>
<span class="c1">#            errmsg = [template % (i, nb)</span>
<span class="c1">#                      for (i, nb) in invalid if i &lt; nbrows]</span>
<span class="c1">#        else:</span>
        <span class="n">errmsg</span> <span class="o">=</span> <span class="p">[</span><span class="n">template</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">nb</span><span class="p">)</span> <span class="ow">in</span> <span class="n">invalid</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">errmsg</span><span class="p">):</span>
            <span class="n">errmsg</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;Some errors were detected !&quot;</span><span class="p">)</span>
            <span class="n">errmsg</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="c1"># Raise an exception ?</span>
            <span class="k">if</span> <span class="n">invalid_raise</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">errmsg</span><span class="p">)</span>
            <span class="c1"># Issue a warning ?</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="n">errmsg</span><span class="p">,</span> <span class="n">ConversionWarning</span><span class="p">)</span>

    <span class="c1"># Strip the last skip_footer data</span>
    <span class="k">if</span> <span class="n">skip_footer</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[:</span><span class="o">-</span><span class="n">skip_footer</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
            <span class="n">masks</span> <span class="o">=</span> <span class="n">masks</span><span class="p">[:</span><span class="o">-</span><span class="n">skip_footer</span><span class="p">]</span>

    <span class="c1"># Convert each value according to the converter:</span>
    <span class="c1"># We want to modify the list in place to avoid creating a new one...</span>
    <span class="k">if</span> <span class="n">loose</span><span class="p">:</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">conv</span><span class="o">.</span><span class="n">_loose_call</span><span class="p">(</span><span class="n">_r</span><span class="p">)</span> <span class="k">for</span> <span class="n">_r</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">rows</span><span class="p">)]</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">conv</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">converters</span><span class="p">)]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[[</span><span class="n">conv</span><span class="o">.</span><span class="n">_strict_call</span><span class="p">(</span><span class="n">_r</span><span class="p">)</span> <span class="k">for</span> <span class="n">_r</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">itemgetter</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">rows</span><span class="p">)]</span>
                  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">conv</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">converters</span><span class="p">)]))</span>

    <span class="c1"># Reset the dtype</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">rows</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="c1"># Get the dtypes from the types of the converters</span>
        <span class="n">column_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">conv</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">conv</span> <span class="ow">in</span> <span class="n">converters</span><span class="p">]</span>
        <span class="c1"># Find the columns with strings...</span>
        <span class="n">strcolidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_types</span><span class="p">)</span>
                     <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">)]</span>
        <span class="c1"># ... and take the largest number of chars.</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">strcolidx</span><span class="p">:</span>
            <span class="n">column_types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;|S</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span>
        <span class="c1">#</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># If the dtype is uniform, don&#39;t define names, else use &#39;&#39;</span>
            <span class="n">base</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">c</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">converters</span> <span class="k">if</span> <span class="n">c</span><span class="o">.</span><span class="n">_checked</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">base</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="p">(</span><span class="n">ddtype</span><span class="p">,</span> <span class="n">mdtype</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">base</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ddtype</span> <span class="o">=</span> <span class="p">[(</span><span class="n">defaultfmt</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
                          <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_types</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
                    <span class="n">mdtype</span> <span class="o">=</span> <span class="p">[(</span><span class="n">defaultfmt</span> <span class="o">%</span> <span class="n">i</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span>
                              <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">column_types</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ddtype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">column_types</span><span class="p">))</span>
            <span class="n">mdtype</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">column_types</span><span class="p">)))</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">ddtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
            <span class="n">outputmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Overwrite the initial dtype names if needed</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">and</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
            <span class="n">dtype</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="c1"># Case 1. We have a structured type</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dtype_flat</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Nested dtype, eg [(&#39;a&#39;, int), (&#39;b&#39;, [(&#39;b0&#39;, int), (&#39;b1&#39;, &#39;f4&#39;)])]</span>
            <span class="c1"># First, create the array using a flattened dtype:</span>
            <span class="c1"># [(&#39;a&#39;, int), (&#39;b1&#39;, int), (&#39;b2&#39;, float)]</span>
            <span class="c1"># Then, view the array using the specified dtype.</span>
            <span class="k">if</span> <span class="s1">&#39;O&#39;</span> <span class="ow">in</span> <span class="p">(</span><span class="n">_</span><span class="o">.</span><span class="n">char</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dtype_flat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">has_nested_fields</span><span class="p">(</span><span class="n">dtype</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                        <span class="s2">&quot;Nested fields involving objects are not supported...&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dtype_flat</span><span class="p">])</span>
                <span class="n">output</span> <span class="o">=</span> <span class="n">rows</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
            <span class="c1"># Now, process the rowmasks the same way</span>
            <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
                <span class="n">rowmasks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                    <span class="n">masks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">([(</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dtype_flat</span><span class="p">]))</span>
                <span class="c1"># Construct the new dtype</span>
                <span class="n">mdtype</span> <span class="o">=</span> <span class="n">make_mask_descr</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
                <span class="n">outputmask</span> <span class="o">=</span> <span class="n">rowmasks</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">mdtype</span><span class="p">)</span>
        <span class="c1"># Case #2. We have a basic dtype</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We used some user-defined converters</span>
            <span class="k">if</span> <span class="n">user_converters</span><span class="p">:</span>
                <span class="n">ishomogeneous</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="n">descr</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ttype</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">conv</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">conv</span> <span class="ow">in</span> <span class="n">converters</span><span class="p">]):</span>
                    <span class="c1"># Keep the dtype of the current converter</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">user_converters</span><span class="p">:</span>
                        <span class="n">ishomogeneous</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">ttype</span> <span class="o">==</span> <span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ttype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">string_</span><span class="p">:</span>
                            <span class="n">ttype</span> <span class="o">=</span> <span class="s2">&quot;|S</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">data</span><span class="p">)</span>
                        <span class="n">descr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">ttype</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">descr</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span>
                <span class="c1"># So we changed the dtype ?</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ishomogeneous</span><span class="p">:</span>
                    <span class="c1"># We have more than one field</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">descr</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">descr</span><span class="p">)</span>
                    <span class="c1"># We have only one field: drop the name if not needed.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">ttype</span><span class="p">)</span>
            <span class="c1">#</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">:</span>
                    <span class="n">mdtype</span> <span class="o">=</span> <span class="p">[(</span><span class="n">_</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">mdtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">bool</span>
                <span class="n">outputmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">masks</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">mdtype</span><span class="p">)</span>
    <span class="c1"># Try to take care of the missing data we missed</span>
    <span class="n">names</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">names</span>
    <span class="k">if</span> <span class="n">usemask</span> <span class="ow">and</span> <span class="n">names</span><span class="p">:</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">conv</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span> <span class="ow">or</span> <span class="p">(),</span> <span class="n">converters</span><span class="p">):</span>
            <span class="n">missing_values</span> <span class="o">=</span> <span class="p">[</span><span class="n">conv</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">conv</span><span class="o">.</span><span class="n">missing_values</span>
                              <span class="k">if</span> <span class="n">_</span> <span class="o">!=</span> <span class="n">asbytes</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)]</span>
            <span class="k">for</span> <span class="n">mval</span> <span class="ow">in</span> <span class="n">missing_values</span><span class="p">:</span>
                <span class="n">outputmask</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">|=</span> <span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">==</span> <span class="n">mval</span><span class="p">)</span>
    <span class="c1"># Construct the final array</span>
    <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedArray</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">_mask</span> <span class="o">=</span> <span class="n">outputmask</span>
    <span class="k">if</span> <span class="n">unpack</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span><span class="o">.</span><span class="n">T</span>
    <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span></div>


<div class="viewcode-block" id="ndfromtxt"><a class="viewcode-back" href="../../../generated/numpy.ndfromtxt.html#numpy.ndfromtxt">[docs]</a><span class="k">def</span> <span class="nf">ndfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load ASCII data stored in a file and return it as a single array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname, kwargs : For a description of input parameters, see `genfromtxt`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.genfromtxt : generic function.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;usemask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="mafromtxt"><a class="viewcode-back" href="../../../generated/numpy.mafromtxt.html#numpy.mafromtxt">[docs]</a><span class="k">def</span> <span class="nf">mafromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load ASCII data stored in a text file and return a masked array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname, kwargs : For a description of input parameters, see `genfromtxt`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.genfromtxt : generic function to load ASCII data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;usemask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="recfromtxt"><a class="viewcode-back" href="../../../generated/numpy.recfromtxt.html#numpy.recfromtxt">[docs]</a><span class="k">def</span> <span class="nf">recfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load ASCII data from a file and return it in a record array.</span>

<span class="sd">    If ``usemask=False`` a standard `recarray` is returned,</span>
<span class="sd">    if ``usemask=True`` a MaskedRecords array is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname, kwargs : For a description of input parameters, see `genfromtxt`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.genfromtxt : generic function</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, `dtype` is None, which means that the data-type of the output</span>
<span class="sd">    array will be determined from the data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">usemask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;usemask&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy.ma.mrecords</span> <span class="kn">import</span> <span class="n">MaskedRecords</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedRecords</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>


<div class="viewcode-block" id="recfromcsv"><a class="viewcode-back" href="../../../generated/numpy.recfromcsv.html#numpy.recfromcsv">[docs]</a><span class="k">def</span> <span class="nf">recfromcsv</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load ASCII data stored in a comma-separated file.</span>

<span class="sd">    The returned array is a record array (if ``usemask=False``, see</span>
<span class="sd">    `recarray`) or a masked record array (if ``usemask=True``,</span>
<span class="sd">    see `ma.mrecords.MaskedRecords`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname, kwargs : For a description of input parameters, see `genfromtxt`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.genfromtxt : generic function to load ASCII data.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    By default, `dtype` is None, which means that the data-type of the output</span>
<span class="sd">    array will be determined from the data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set default kwargs for genfromtxt as relevant to csv import.</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;case_sensitive&quot;</span><span class="p">,</span> <span class="s2">&quot;lower&quot;</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;names&quot;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;delimiter&quot;</span><span class="p">,</span> <span class="s2">&quot;,&quot;</span><span class="p">)</span>
    <span class="n">kwargs</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">genfromtxt</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="n">usemask</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;usemask&quot;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">usemask</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">numpy.ma.mrecords</span> <span class="kn">import</span> <span class="n">MaskedRecords</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">MaskedRecords</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">recarray</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>