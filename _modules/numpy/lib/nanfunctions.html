

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>numpy.lib.nanfunctions &mdash; Numpy API</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Numpy API" href="../../../index.html"/>
        <link rel="up" title="numpy" href="../../numpy.html"/> 

  
  <script src="../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../index.html" class="icon icon-home"> Numpy API
          

          
          </a>

          
            
            
              <div class="version">
                1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <p class="caption"><span class="caption-text">Table of Contents</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.html">1. NumPy</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.doc.html">2. <code class="docutils literal"><span class="pre">numpy.doc</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.lib.html">3. <code class="docutils literal"><span class="pre">numpy.lib</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.random.html">4. <code class="docutils literal"><span class="pre">numpy.random</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.linalg.html">5. <code class="docutils literal"><span class="pre">numpy.linalg</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.fft.html">6. Discrete Fourier Transform (<code class="docutils literal"><span class="pre">numpy.fft</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.polynomial.html">7. <code class="docutils literal"><span class="pre">numpy.polynomial</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.testing.html">8. <code class="docutils literal"><span class="pre">numpy.testing</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.f2py.html">9. <code class="docutils literal"><span class="pre">numpy.f2py</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../generated/numpy.distutils.html">10. <code class="docutils literal"><span class="pre">numpy.distutils</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../reference/index.html">11. NumPy Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../glossary.html">12. Glossary</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Numpy API</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          













<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../numpy.html">numpy</a> &raquo;</li>
        
      <li>numpy.lib.nanfunctions</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for numpy.lib.nanfunctions</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Functions that ignore NaN.</span>

<span class="sd">Functions</span>
<span class="sd">---------</span>

<span class="sd">- `nanmin` -- minimum non-NaN value</span>
<span class="sd">- `nanmax` -- maximum non-NaN value</span>
<span class="sd">- `nanargmin` -- index of minimum non-NaN value</span>
<span class="sd">- `nanargmax` -- index of maximum non-NaN value</span>
<span class="sd">- `nansum` -- sum of non-NaN values</span>
<span class="sd">- `nanprod` -- product of non-NaN values</span>
<span class="sd">- `nanmean` -- mean of non-NaN values</span>
<span class="sd">- `nanvar` -- variance of non-NaN values</span>
<span class="sd">- `nanstd` -- standard deviation of non-NaN values</span>
<span class="sd">- `nanmedian` -- median of non-NaN values</span>
<span class="sd">- `nanpercentile` -- qth percentile of non-NaN values</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">print_function</span>

<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy.lib.function_base</span> <span class="kn">import</span> <span class="n">_ureduce</span> <span class="k">as</span> <span class="n">_ureduce</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;nansum&#39;</span><span class="p">,</span> <span class="s1">&#39;nanmax&#39;</span><span class="p">,</span> <span class="s1">&#39;nanmin&#39;</span><span class="p">,</span> <span class="s1">&#39;nanargmax&#39;</span><span class="p">,</span> <span class="s1">&#39;nanargmin&#39;</span><span class="p">,</span> <span class="s1">&#39;nanmean&#39;</span><span class="p">,</span>
    <span class="s1">&#39;nanmedian&#39;</span><span class="p">,</span> <span class="s1">&#39;nanpercentile&#39;</span><span class="p">,</span> <span class="s1">&#39;nanvar&#39;</span><span class="p">,</span> <span class="s1">&#39;nanstd&#39;</span><span class="p">,</span> <span class="s1">&#39;nanprod&#39;</span><span class="p">,</span>
    <span class="p">]</span>


<span class="k">def</span> <span class="nf">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    If `a` is of inexact type, make a copy of `a`, replace NaNs with</span>
<span class="sd">    the `val` value, and return the copy together with a boolean mask</span>
<span class="sd">    marking the locations where NaNs were present. If `a` is not of</span>
<span class="sd">    inexact type, do nothing and return `a` together with a mask of None.</span>

<span class="sd">    Note that scalars will end up as array scalars, which is important</span>
<span class="sd">    for using the result as the value of the out argument in some</span>
<span class="sd">    operations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array-like</span>
<span class="sd">        Input array.</span>
<span class="sd">    val : float</span>
<span class="sd">        NaN values are set to val before doing the operation.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        If `a` is of inexact type, return a copy of `a` with the NaNs</span>
<span class="sd">        replaced by the fill value, otherwise return `a`.</span>
<span class="sd">    mask: {bool, None}</span>
<span class="sd">        If `a` is of inexact type, return a boolean mask marking locations of</span>
<span class="sd">        NaNs, otherwise return None.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_new</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_new</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="bp">None</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_new</span><span class="p">:</span>
        <span class="c1"># need copy</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">subok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

    <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">,</span> <span class="n">mask</span>


<span class="k">def</span> <span class="nf">_copyto</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">mask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Replace values in `a` with NaN where `mask` is True.  This differs from</span>
<span class="sd">    copyto in that it will deal with the case where `a` is a numpy scalar.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : ndarray or numpy scalar</span>
<span class="sd">        Array or numpy scalar some of whose values are to be replaced</span>
<span class="sd">        by val.</span>
<span class="sd">    val : numpy scalar</span>
<span class="sd">        Value used a replacement.</span>
<span class="sd">    mask : ndarray, scalar</span>
<span class="sd">        Boolean array. Where True the corresponding element of `a` is</span>
<span class="sd">        replaced by `val`. Broadcasts.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    res : ndarray, scalar</span>
<span class="sd">        Array with elements replaced or scalar `val`.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">np</span><span class="o">.</span><span class="n">copyto</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">where</span><span class="o">=</span><span class="n">mask</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">a</span>


<span class="k">def</span> <span class="nf">_divide_by_count</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a/b ignoring invalid results. If `a` is an array the division</span>
<span class="sd">    is done in place. If `a` is a scalar, then its type is preserved in the</span>
<span class="sd">    output. If out is None, then then a is used instead so that the</span>
<span class="sd">    division is in place. Note that this is only called with `a` an inexact</span>
<span class="sd">    type.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : {ndarray, numpy scalar}</span>
<span class="sd">        Numerator. Expected to be of inexact type but not checked.</span>
<span class="sd">    b : {ndarray, numpy scalar}</span>
<span class="sd">        Denominator.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ret : {ndarray, numpy scalar}</span>
<span class="sd">        The return value is a/b. If `a` was an ndarray the division is done</span>
<span class="sd">        in place. If `a` is a numpy scalar, the division preserves its type.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">np</span><span class="o">.</span><span class="n">errstate</span><span class="p">(</span><span class="n">invalid</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">a</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">a</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># This is questionable, but currently a numpy scalar can</span>
                <span class="c1"># be output to a zero dimensional array.</span>
                <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="nanmin"><a class="viewcode-back" href="../../../reference/generated/numpy.nanmin.html#numpy.lib.nanmin">[docs]</a><span class="k">def</span> <span class="nf">nanmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return minimum of an array or minimum along an axis, ignoring any NaNs.</span>
<span class="sd">    When all-NaN slices are encountered a ``RuntimeWarning`` is raised and</span>
<span class="sd">    Nan is returned for that slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose minimum is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the minimum is computed. The default is to compute</span>
<span class="sd">        the minimum of the flattened array.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.  See</span>
<span class="sd">        `doc.ufuncs` for details.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">        result as dimensions with size one. With this option, the result</span>
<span class="sd">        will broadcast correctly against the original `a`.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nanmin : ndarray</span>
<span class="sd">        An array with the same shape as `a`, with the specified axis</span>
<span class="sd">        removed.  If `a` is a 0-d array, or if axis is None, an ndarray</span>
<span class="sd">        scalar is returned.  The same dtype as `a` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    nanmax :</span>
<span class="sd">        The maximum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    amin :</span>
<span class="sd">        The minimum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    fmin :</span>
<span class="sd">        Element-wise minimum of two arrays, ignoring any NaNs.</span>
<span class="sd">    minimum :</span>
<span class="sd">        Element-wise minimum of two arrays, propagating any NaNs.</span>
<span class="sd">    isnan :</span>
<span class="sd">        Shows which elements are Not a Number (NaN).</span>
<span class="sd">    isfinite:</span>
<span class="sd">        Shows which elements are neither NaN nor infinity.</span>

<span class="sd">    amax, fmax, maximum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span>
<span class="sd">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span>
<span class="sd">    Positive infinity is treated as a very large number and negative</span>
<span class="sd">    infinity is treated as a very small (i.e. negative) number.</span>

<span class="sd">    If the input has a integer type the function is equivalent to np.min.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span>
<span class="sd">    &gt;&gt;&gt; np.nanmin(a)</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; np.nanmin(a, axis=0)</span>
<span class="sd">    array([ 1.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.nanmin(a, axis=1)</span>
<span class="sd">    array([ 1.,  3.])</span>

<span class="sd">    When positive infinity and negative infinity are present:</span>

<span class="sd">    &gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.inf])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; np.nanmin([1, 2, np.nan, np.NINF])</span>
<span class="sd">    -inf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Fast, but not safe for subclasses of ndarray</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fmin</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All-NaN axis encountered&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Slow, but safe for subclasses of ndarray</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># Check for all-NaN axis</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_copyto</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All-NaN axis encountered&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="nanmax"><a class="viewcode-back" href="../../../reference/generated/numpy.nanmax.html#numpy.lib.nanmax">[docs]</a><span class="k">def</span> <span class="nf">nanmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the maximum of an array or maximum along an axis, ignoring any</span>
<span class="sd">    NaNs.  When all-NaN slices are encountered a ``RuntimeWarning`` is</span>
<span class="sd">    raised and NaN is returned for that slice.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose maximum is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the maximum is computed. The default is to compute</span>
<span class="sd">        the maximum of the flattened array.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.  See</span>
<span class="sd">        `doc.ufuncs` for details.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">        result as dimensions with size one. With this option, the result</span>
<span class="sd">        will broadcast correctly against the original `a`.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nanmax : ndarray</span>
<span class="sd">        An array with the same shape as `a`, with the specified axis removed.</span>
<span class="sd">        If `a` is a 0-d array, or if axis is None, an ndarray scalar is</span>
<span class="sd">        returned.  The same dtype as `a` is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    nanmin :</span>
<span class="sd">        The minimum value of an array along a given axis, ignoring any NaNs.</span>
<span class="sd">    amax :</span>
<span class="sd">        The maximum value of an array along a given axis, propagating any NaNs.</span>
<span class="sd">    fmax :</span>
<span class="sd">        Element-wise maximum of two arrays, ignoring any NaNs.</span>
<span class="sd">    maximum :</span>
<span class="sd">        Element-wise maximum of two arrays, propagating any NaNs.</span>
<span class="sd">    isnan :</span>
<span class="sd">        Shows which elements are Not a Number (NaN).</span>
<span class="sd">    isfinite:</span>
<span class="sd">        Shows which elements are neither NaN nor infinity.</span>

<span class="sd">    amin, fmin, minimum</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Numpy uses the IEEE Standard for Binary Floating-Point for Arithmetic</span>
<span class="sd">    (IEEE 754). This means that Not a Number is not equivalent to infinity.</span>
<span class="sd">    Positive infinity is treated as a very large number and negative</span>
<span class="sd">    infinity is treated as a very small (i.e. negative) number.</span>

<span class="sd">    If the input has a integer type the function is equivalent to np.max.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span>
<span class="sd">    &gt;&gt;&gt; np.nanmax(a)</span>
<span class="sd">    3.0</span>
<span class="sd">    &gt;&gt;&gt; np.nanmax(a, axis=0)</span>
<span class="sd">    array([ 3.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; np.nanmax(a, axis=1)</span>
<span class="sd">    array([ 2.,  3.])</span>

<span class="sd">    When positive infinity and negative infinity are present:</span>

<span class="sd">    &gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.NINF])</span>
<span class="sd">    2.0</span>
<span class="sd">    &gt;&gt;&gt; np.nanmax([1, 2, np.nan, np.inf])</span>
<span class="sd">    inf</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># Fast, but not safe for subclasses of ndarray</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fmax</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">res</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Slow, but safe for subclasses of ndarray</span>
        <span class="n">a</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="c1"># Check for all-NaN axis</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">_copyto</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All-NaN axis encountered&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="nanargmin"><a class="viewcode-back" href="../../../reference/generated/numpy.nanargmin.html#numpy.lib.nanargmin">[docs]</a><span class="k">def</span> <span class="nf">nanargmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the minimum values in the specified axis ignoring</span>
<span class="sd">    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the results</span>
<span class="sd">    cannot be trusted if a slice contains only NaNs and Infs.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to operate.  By default flattened input is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray</span>
<span class="sd">        An array of indices or a single index value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    argmin, nanargmax</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.argmin(a)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; np.nanargmin(a)</span>
<span class="sd">    2</span>
<span class="sd">    &gt;&gt;&gt; np.nanargmin(a, axis=0)</span>
<span class="sd">    array([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; np.nanargmin(a, axis=1)</span>
<span class="sd">    array([1, 0])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="nanargmax"><a class="viewcode-back" href="../../../reference/generated/numpy.nanargmax.html#numpy.lib.nanargmax">[docs]</a><span class="k">def</span> <span class="nf">nanargmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the indices of the maximum values in the specified axis ignoring</span>
<span class="sd">    NaNs. For all-NaN slices ``ValueError`` is raised. Warning: the</span>
<span class="sd">    results cannot be trusted if a slice contains only NaNs and -Infs.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input data.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which to operate.  By default flattened input is used.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    index_array : ndarray</span>
<span class="sd">        An array of indices or a single index value.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    argmax, nanargmin</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[np.nan, 4], [2, 3]])</span>
<span class="sd">    &gt;&gt;&gt; np.argmax(a)</span>
<span class="sd">    0</span>
<span class="sd">    &gt;&gt;&gt; np.nanargmax(a)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.nanargmax(a, axis=0)</span>
<span class="sd">    array([1, 0])</span>
<span class="sd">    &gt;&gt;&gt; np.nanargmax(a, axis=1)</span>
<span class="sd">    array([1, 1])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mask</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">res</span></div>


<div class="viewcode-block" id="nansum"><a class="viewcode-back" href="../../../reference/generated/numpy.nansum.html#numpy.lib.nansum">[docs]</a><span class="k">def</span> <span class="nf">nansum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the sum of array elements over a given axis treating Not a</span>
<span class="sd">    Numbers (NaNs) as zero.</span>

<span class="sd">    In Numpy versions &lt;= 1.8 Nan is returned for slices that are all-NaN or</span>
<span class="sd">    empty. In later versions zero is returned.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose sum is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the sum is computed. The default is to compute the</span>
<span class="sd">        sum of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        The type of the returned array and of the accumulator in which the</span>
<span class="sd">        elements are summed.  By default, the dtype of `a` is used.  An</span>
<span class="sd">        exception is when `a` has an integer type with less precision than</span>
<span class="sd">        the platform (u)intp. In that case, the default will be either</span>
<span class="sd">        (u)int32 or (u)int64 depending on whether the platform is 32 or 64</span>
<span class="sd">        bits. For inexact inputs, dtype must be inexact.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``. If provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.  See</span>
<span class="sd">        `doc.ufuncs` for details. The casting of NaN to integer can yield</span>
<span class="sd">        unexpected results.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will</span>
<span class="sd">        broadcast correctly against the original `arr`.</span>

<span class="sd">        .. versionadded:: 1.8.0</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray or numpy scalar</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.sum : Sum across array propagating NaNs.</span>
<span class="sd">    isnan : Show which elements are NaN.</span>
<span class="sd">    isfinite: Show which elements are not NaN or +/-inf.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    If both positive and negative infinity are present, the sum will be Not</span>
<span class="sd">    A Number (NaN).</span>

<span class="sd">    Numpy integer arithmetic is modular. If the size of a sum exceeds the</span>
<span class="sd">    size of an integer accumulator, its value will wrap around and the</span>
<span class="sd">    result will be incorrect. Specifying ``dtype=double`` can alleviate</span>
<span class="sd">    that problem.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.nansum(1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.nansum([1])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.nansum([1, np.nan])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 1], [1, np.nan]])</span>
<span class="sd">    &gt;&gt;&gt; np.nansum(a)</span>
<span class="sd">    3.0</span>
<span class="sd">    &gt;&gt;&gt; np.nansum(a, axis=0)</span>
<span class="sd">    array([ 2.,  1.])</span>
<span class="sd">    &gt;&gt;&gt; np.nansum([1, np.nan, np.inf])</span>
<span class="sd">    inf</span>
<span class="sd">    &gt;&gt;&gt; np.nansum([1, np.nan, np.NINF])</span>
<span class="sd">    -inf</span>
<span class="sd">    &gt;&gt;&gt; np.nansum([1, np.nan, np.inf, -np.inf]) # both +/- infinity present</span>
<span class="sd">    nan</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanprod"><a class="viewcode-back" href="../../../reference/generated/numpy.nanprod.html#numpy.lib.nanprod">[docs]</a><span class="k">def</span> <span class="nf">nanprod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the product of array elements over a given axis treating Not a</span>
<span class="sd">    Numbers (NaNs) as zero.</span>

<span class="sd">    One is returned for slices that are all-NaN or empty.</span>

<span class="sd">    .. versionadded:: 1.10.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose sum is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the product is computed. The default is to compute</span>
<span class="sd">        the product of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        The type of the returned array and of the accumulator in which the</span>
<span class="sd">        elements are summed.  By default, the dtype of `a` is used.  An</span>
<span class="sd">        exception is when `a` has an integer type with less precision than</span>
<span class="sd">        the platform (u)intp. In that case, the default will be either</span>
<span class="sd">        (u)int32 or (u)int64 depending on whether the platform is 32 or 64</span>
<span class="sd">        bits. For inexact inputs, dtype must be inexact.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``. If provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.  See</span>
<span class="sd">        `doc.ufuncs` for details. The casting of NaN to integer can yield</span>
<span class="sd">        unexpected results.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If True, the axes which are reduced are left in the result as</span>
<span class="sd">        dimensions with size one. With this option, the result will</span>
<span class="sd">        broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray or numpy scalar</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    numpy.prod : Product across array propagating NaNs.</span>
<span class="sd">    isnan : Show which elements are NaN.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Numpy integer arithmetic is modular. If the size of a product exceeds</span>
<span class="sd">    the size of an integer accumulator, its value will wrap around and the</span>
<span class="sd">    result will be incorrect. Specifying ``dtype=double`` can alleviate</span>
<span class="sd">    that problem.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; np.nanprod(1)</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.nanprod([1])</span>
<span class="sd">    1</span>
<span class="sd">    &gt;&gt;&gt; np.nanprod([1, np.nan])</span>
<span class="sd">    1.0</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, 2], [3, np.nan]])</span>
<span class="sd">    &gt;&gt;&gt; np.nanprod(a)</span>
<span class="sd">    6.0</span>
<span class="sd">    &gt;&gt;&gt; np.nanprod(a, axis=0)</span>
<span class="sd">    array([ 3.,  2.])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span></div>


<div class="viewcode-block" id="nanmean"><a class="viewcode-back" href="../../../reference/generated/numpy.nanmean.html#numpy.lib.nanmean">[docs]</a><span class="k">def</span> <span class="nf">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the arithmetic mean along the specified axis, ignoring NaNs.</span>

<span class="sd">    Returns the average of the array elements.  The average is taken over</span>
<span class="sd">    the flattened array by default, otherwise over the specified axis.</span>
<span class="sd">    `float64` intermediate and return values are used for integer inputs.</span>

<span class="sd">    For all-NaN slices, NaN is returned and a `RuntimeWarning` is raised.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose mean is desired. If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the means are computed. The default is to compute</span>
<span class="sd">        the mean of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the mean.  For integer inputs, the default</span>
<span class="sd">        is `float64`; for inexact inputs, it is the same as the input</span>
<span class="sd">        dtype.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  The default</span>
<span class="sd">        is ``None``; if provided, it must have the same shape as the</span>
<span class="sd">        expected output, but the type will be cast if necessary.  See</span>
<span class="sd">        `doc.ufuncs` for details.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left in the</span>
<span class="sd">        result as dimensions with size one. With this option, the result</span>
<span class="sd">        will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    m : ndarray, see dtype parameter above</span>
<span class="sd">        If `out=None`, returns a new array containing the mean values,</span>
<span class="sd">        otherwise a reference to the output array is returned. Nan is</span>
<span class="sd">        returned for slices that contain only NaNs.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    average : Weighted average</span>
<span class="sd">    mean : Arithmetic mean taken while not ignoring NaNs</span>
<span class="sd">    var, nanvar</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The arithmetic mean is the sum of the non-NaN elements along the axis</span>
<span class="sd">    divided by the number of non-NaN elements.</span>

<span class="sd">    Note that for floating-point input, the mean is computed using the same</span>
<span class="sd">    precision the input has.  Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for `float32`.  Specifying a</span>
<span class="sd">    higher-precision accumulator using the `dtype` keyword can alleviate</span>
<span class="sd">    this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.nanmean(a)</span>
<span class="sd">    2.6666666666666665</span>
<span class="sd">    &gt;&gt;&gt; np.nanmean(a, axis=0)</span>
<span class="sd">    array([ 2.,  4.])</span>
<span class="sd">    &gt;&gt;&gt; np.nanmean(a, axis=1)</span>
<span class="sd">    array([ 1.,  3.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If a is inexact, then dtype must be inexact&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If a is inexact, then out must be inexact&quot;</span><span class="p">)</span>

    <span class="c1"># The warning context speeds things up.</span>
    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">_divide_by_count</span><span class="p">(</span><span class="n">tot</span><span class="p">,</span> <span class="n">cnt</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

    <span class="n">isbad</span> <span class="o">=</span> <span class="p">(</span><span class="n">cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">isbad</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Mean of empty slice&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="c1"># NaN is the only possible bad value, so no further</span>
        <span class="c1"># action is needed to handle bad results.</span>
    <span class="k">return</span> <span class="n">avg</span></div>


<span class="k">def</span> <span class="nf">_nanmedian1d</span><span class="p">(</span><span class="n">arr1d</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function for rank 1 arrays. Compute the median ignoring NaNs.</span>
<span class="sd">    See nanmedian for parameter usage</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr1d</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">arr1d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">arr1d</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">arr1d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">arr1d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># select non-nans at end of array</span>
        <span class="n">enonan</span> <span class="o">=</span> <span class="n">arr1d</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">:][</span><span class="o">~</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">:]]</span>
        <span class="c1"># fill nans in beginning of array with non-nans of end</span>
        <span class="n">x</span><span class="p">[</span><span class="n">s</span><span class="p">[:</span><span class="n">enonan</span><span class="o">.</span><span class="n">size</span><span class="p">]]</span> <span class="o">=</span> <span class="n">enonan</span>
        <span class="c1"># slice nans away</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">],</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function that doesn&#39;t support extended axis or keepdims.</span>
<span class="sd">    These methods are extended to this function using _ureduce</span>
<span class="sd">    See nanmedian for parameter usage</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">or</span> <span class="n">a</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_nanmedian1d</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">_nanmedian1d</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">out</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># for small medians use sort + indexing which is still faster than</span>
        <span class="c1"># apply_along_axis</span>
        <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">400</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_nanmedian_small</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">_nanmedian1d</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">_nanmedian_small</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    sort + indexing median, faster for small medians along multiple dimensions</span>
<span class="sd">    due to the high overhead of apply_along_axis</span>
<span class="sd">    see nanmedian for parameter usage</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_array</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">count_nonzero</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">mask</span><span class="o">.</span><span class="n">ravel</span><span class="p">())):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>
    <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">filled</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>

<div class="viewcode-block" id="nanmedian"><a class="viewcode-back" href="../../../reference/generated/numpy.nanmedian.html#numpy.lib.nanmedian">[docs]</a><span class="k">def</span> <span class="nf">nanmedian</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the median along the specified axis, while ignoring NaNs.</span>

<span class="sd">    Returns the median of the array elements.</span>

<span class="sd">    .. versionadded:: 1.9.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the medians are computed. The default (axis=None)</span>
<span class="sd">        is to compute the median along a flattened version of the array.</span>
<span class="sd">        A sequence of axes is supported since version 1.9.0.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape and buffer length as the expected output, but the</span>
<span class="sd">        type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">       If True, then allow use of memory of input array (a) for</span>
<span class="sd">       calculations. The input array will be modified by the call to</span>
<span class="sd">       median. This will save memory when you do not need to preserve</span>
<span class="sd">       the contents of the input array. Treat the input as undefined,</span>
<span class="sd">       but it will probably be fully or partially sorted. Default is</span>
<span class="sd">       False. Note that, if `overwrite_input` is True and the input</span>
<span class="sd">       is not already an ndarray, an error will be raised.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>



<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    median : ndarray</span>
<span class="sd">        A new array holding the result. If the input contains integers, or</span>
<span class="sd">        floats of smaller precision than 64, then the output data-type is</span>
<span class="sd">        float64.  Otherwise, the output data-type is the same as that of the</span>
<span class="sd">        input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    mean, median, percentile</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector V of length N, the median of V is the middle value of</span>
<span class="sd">    a sorted copy of V, ``V_sorted`` - i.e., ``V_sorted[(N-1)/2]``, when N is</span>
<span class="sd">    odd.  When N is even, it is the average of the two middle values of</span>
<span class="sd">    ``V_sorted``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10.0, 7, 4], [3, 2, 1]])</span>
<span class="sd">    &gt;&gt;&gt; a[0, 1] = np.nan</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 10.,  nan,   4.],</span>
<span class="sd">       [  3.,   2.,   1.]])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; np.nanmedian(a)</span>
<span class="sd">    3.0</span>
<span class="sd">    &gt;&gt;&gt; np.nanmedian(a, axis=0)</span>
<span class="sd">    array([ 6.5,  2.,  2.5])</span>
<span class="sd">    &gt;&gt;&gt; np.median(a, axis=1)</span>
<span class="sd">    array([ 7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.nanmedian(b, axis=1, overwrite_input=True)</span>
<span class="sd">    array([ 7.,  2.])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.nanmedian(b, axis=None, overwrite_input=True)</span>
<span class="sd">    3.0</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># apply_along_axis in _nanmedian doesn&#39;t handle empty arrays well,</span>
    <span class="c1"># so deal them upfront</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_nanmedian</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span></div>


<div class="viewcode-block" id="nanpercentile"><a class="viewcode-back" href="../../../reference/generated/numpy.nanpercentile.html#numpy.lib.nanpercentile">[docs]</a><span class="k">def</span> <span class="nf">nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                  <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the qth percentile of the data along the specified axis, while</span>
<span class="sd">    ignoring nan values.</span>

<span class="sd">    Returns the qth percentile of the array elements.</span>

<span class="sd">    .. versionadded:: 1.9.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Input array or object that can be converted to an array.</span>
<span class="sd">    q : float in range of [0,100] (or sequence of floats)</span>
<span class="sd">        Percentile to compute which must be between 0 and 100 inclusive.</span>
<span class="sd">    axis : int or sequence of int, optional</span>
<span class="sd">        Axis along which the percentiles are computed. The default (None)</span>
<span class="sd">        is to compute the percentiles along a flattened version of the array.</span>
<span class="sd">        A sequence of axes is supported since version 1.9.0.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must</span>
<span class="sd">        have the same shape and buffer length as the expected output,</span>
<span class="sd">        but the type (of the output) will be cast if necessary.</span>
<span class="sd">    overwrite_input : bool, optional</span>
<span class="sd">        If True, then allow use of memory of input array `a` for</span>
<span class="sd">        calculations. The input array will be modified by the call to</span>
<span class="sd">        percentile. This will save memory when you do not need to preserve</span>
<span class="sd">        the contents of the input array. In this case you should not make</span>
<span class="sd">        any assumptions about the content of the passed in array `a` after</span>
<span class="sd">        this function completes -- treat it as undefined. Default is False.</span>
<span class="sd">        Note that, if the `a` input is not already an array this parameter</span>
<span class="sd">        will have no effect, `a` will be converted to an array internally</span>
<span class="sd">        regardless of the value of this parameter.</span>
<span class="sd">    interpolation : {&#39;linear&#39;, &#39;lower&#39;, &#39;higher&#39;, &#39;midpoint&#39;, &#39;nearest&#39;}</span>
<span class="sd">        This optional parameter specifies the interpolation method to use,</span>
<span class="sd">        when the desired quantile lies between two data points `i` and `j`:</span>
<span class="sd">            * linear: `i + (j - i) * fraction`, where `fraction` is the</span>
<span class="sd">              fractional part of the index surrounded by `i` and `j`.</span>
<span class="sd">            * lower: `i`.</span>
<span class="sd">            * higher: `j`.</span>
<span class="sd">            * nearest: `i` or `j` whichever is nearest.</span>
<span class="sd">            * midpoint: (`i` + `j`) / 2.</span>

<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>


<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nanpercentile : scalar or ndarray</span>
<span class="sd">        If a single percentile `q` is given and axis=None a scalar is</span>
<span class="sd">        returned.  If multiple percentiles `q` are given an array holding</span>
<span class="sd">        the result is returned. The results are listed in the first axis.</span>
<span class="sd">        (If `out` is specified, in which case that array is returned</span>
<span class="sd">        instead).  If the input contains integers, or floats of smaller</span>
<span class="sd">        precision than 64, then the output data-type is float64. Otherwise,</span>
<span class="sd">        the output data-type is the same as that of the input.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    nanmean, nanmedian, percentile, median, mean</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Given a vector V of length N, the q-th percentile of V is the q-th ranked</span>
<span class="sd">    value in a sorted copy of V.  The values and distances of the two</span>
<span class="sd">    nearest neighbors as well as the `interpolation` parameter will</span>
<span class="sd">    determine the percentile if the normalized ranking does not match q</span>
<span class="sd">    exactly. This function is the same as the median if ``q=50``, the same</span>
<span class="sd">    as the minimum if ``q=0``and the same as the maximum if ``q=100``.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[10., 7., 4.], [3., 2., 1.]])</span>
<span class="sd">    &gt;&gt;&gt; a[0][1] = np.nan</span>
<span class="sd">    &gt;&gt;&gt; a</span>
<span class="sd">    array([[ 10.,  nan,   4.],</span>
<span class="sd">       [  3.,   2.,   1.]])</span>
<span class="sd">    &gt;&gt;&gt; np.percentile(a, 50)</span>
<span class="sd">    nan</span>
<span class="sd">    &gt;&gt;&gt; np.nanpercentile(a, 50)</span>
<span class="sd">    3.5</span>
<span class="sd">    &gt;&gt;&gt; np.nanpercentile(a, 50, axis=0)</span>
<span class="sd">    array([[ 6.5,  4.5,  2.5]])</span>
<span class="sd">    &gt;&gt;&gt; np.nanpercentile(a, 50, axis=1)</span>
<span class="sd">    array([[ 7.],</span>
<span class="sd">           [ 2.]])</span>
<span class="sd">    &gt;&gt;&gt; m = np.nanpercentile(a, 50, axis=0)</span>
<span class="sd">    &gt;&gt;&gt; out = np.zeros_like(m)</span>
<span class="sd">    &gt;&gt;&gt; np.nanpercentile(a, 50, axis=0, out=m)</span>
<span class="sd">    array([[ 6.5,  4.5,  2.5]])</span>
<span class="sd">    &gt;&gt;&gt; m</span>
<span class="sd">    array([[ 6.5,  4.5,  2.5]])</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.nanpercentile(b, 50, axis=1, overwrite_input=True)</span>
<span class="sd">    array([[ 7.],</span>
<span class="sd">           [ 2.]])</span>
<span class="sd">    &gt;&gt;&gt; assert not np.all(a==b)</span>
<span class="sd">    &gt;&gt;&gt; b = a.copy()</span>
<span class="sd">    &gt;&gt;&gt; np.nanpercentile(b, 50, axis=None, overwrite_input=True)</span>
<span class="sd">    array([ 3.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asanyarray</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="c1"># apply_along_axis in _nanpercentile doesn&#39;t handle empty arrays well,</span>
    <span class="c1"># so deal them upfront</span>
    <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="n">r</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">_ureduce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">func</span><span class="o">=</span><span class="n">_nanpercentile</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span>
                    <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                    <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">keepdims</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">q</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">r</span><span class="o">.</span><span class="n">reshape</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">q</span><span class="p">)]</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">r</span></div>


<span class="k">def</span> <span class="nf">_nanpercentile</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                   <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function that doesn&#39;t support extended axis or keepdims.</span>
<span class="sd">    These methods are extended to this function using _ureduce</span>
<span class="sd">    See nanpercentile for parameter usage</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">part</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">_nanpercentile1d</span><span class="p">(</span><span class="n">part</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">apply_along_axis</span><span class="p">(</span><span class="n">_nanpercentile1d</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span>
                                     <span class="n">overwrite_input</span><span class="p">,</span> <span class="n">interpolation</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">out</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">result</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">_nanpercentile1d</span><span class="p">(</span><span class="n">arr1d</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Private function for rank 1 arrays. Compute percentile ignoring NaNs.</span>
<span class="sd">    See nanpercentile for parameter usage</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">arr1d</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">arr1d</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;All-NaN slice encountered&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
    <span class="k">elif</span> <span class="n">s</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">arr1d</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="n">overwrite_input</span><span class="p">,</span>
                             <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">overwrite_input</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">arr1d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">arr1d</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># select non-nans at end of array</span>
        <span class="n">enonan</span> <span class="o">=</span> <span class="n">arr1d</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">:][</span><span class="o">~</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">:]]</span>
        <span class="c1"># fill nans in beginning of array with non-nans of end</span>
        <span class="n">x</span><span class="p">[</span><span class="n">s</span><span class="p">[:</span><span class="n">enonan</span><span class="o">.</span><span class="n">size</span><span class="p">]]</span> <span class="o">=</span> <span class="n">enonan</span>
        <span class="c1"># slice nans away</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="n">s</span><span class="o">.</span><span class="n">size</span><span class="p">],</span> <span class="n">q</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span>
                             <span class="n">interpolation</span><span class="o">=</span><span class="n">interpolation</span><span class="p">)</span>


<div class="viewcode-block" id="nanvar"><a class="viewcode-back" href="../../../reference/generated/numpy.nanvar.html#numpy.lib.nanvar">[docs]</a><span class="k">def</span> <span class="nf">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the variance along the specified axis, while ignoring NaNs.</span>

<span class="sd">    Returns the variance of the array elements, a measure of the spread of</span>
<span class="sd">    a distribution.  The variance is computed for the flattened array by</span>
<span class="sd">    default, otherwise over the specified axis.</span>

<span class="sd">    For all-NaN slices or slices with zero degrees of freedom, NaN is</span>
<span class="sd">    returned and a `RuntimeWarning` is raised.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Array containing numbers whose variance is desired.  If `a` is not an</span>
<span class="sd">        array, a conversion is attempted.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the variance is computed.  The default is to compute</span>
<span class="sd">        the variance of the flattened array.</span>
<span class="sd">    dtype : data-type, optional</span>
<span class="sd">        Type to use in computing the variance.  For arrays of integer type</span>
<span class="sd">        the default is `float32`; for arrays of float types it is the same as</span>
<span class="sd">        the array type.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternate output array in which to place the result.  It must have</span>
<span class="sd">        the same shape as the expected output, but the type is cast if</span>
<span class="sd">        necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        &quot;Delta Degrees of Freedom&quot;: the divisor used in the calculation is</span>
<span class="sd">        ``N - ddof``, where ``N`` represents the number of non-NaN</span>
<span class="sd">        elements. By default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    variance : ndarray, see dtype parameter above</span>
<span class="sd">        If `out` is None, return a new array containing the variance,</span>
<span class="sd">        otherwise return a reference to the output array. If ddof is &gt;= the</span>
<span class="sd">        number of non-NaN elements in a slice or the slice contains only</span>
<span class="sd">        NaNs, then the result for that slice is NaN.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    std : Standard deviation</span>
<span class="sd">    mean : Average</span>
<span class="sd">    var : Variance while not ignoring NaNs</span>
<span class="sd">    nanstd, nanmean</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The variance is the average of the squared deviations from the mean,</span>
<span class="sd">    i.e.,  ``var = mean(abs(x - x.mean())**2)``.</span>

<span class="sd">    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.</span>
<span class="sd">    If, however, `ddof` is specified, the divisor ``N - ddof`` is used</span>
<span class="sd">    instead.  In standard statistical practice, ``ddof=1`` provides an</span>
<span class="sd">    unbiased estimator of the variance of a hypothetical infinite</span>
<span class="sd">    population.  ``ddof=0`` provides a maximum likelihood estimate of the</span>
<span class="sd">    variance for normally distributed variables.</span>

<span class="sd">    Note that for complex numbers, the absolute value is taken before</span>
<span class="sd">    squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the variance is computed using the same</span>
<span class="sd">    precision the input has.  Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for `float32` (see example</span>
<span class="sd">    below).  Specifying a higher-accuracy accumulator using the ``dtype``</span>
<span class="sd">    keyword can alleviate this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.var(a)</span>
<span class="sd">    1.5555555555555554</span>
<span class="sd">    &gt;&gt;&gt; np.nanvar(a, axis=0)</span>
<span class="sd">    array([ 1.,  0.])</span>
<span class="sd">    &gt;&gt;&gt; np.nanvar(a, axis=1)</span>
<span class="sd">    array([ 0.,  0.25])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">arr</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">_replace_nan</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">var</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
                      <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If a is inexact, then dtype must be inexact&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inexact</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If a is inexact, then out must be inexact&quot;</span><span class="p">)</span>

    <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>

        <span class="c1"># Compute mean</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intp</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="n">_divide_by_count</span><span class="p">(</span><span class="n">avg</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span>

        <span class="c1"># Compute squared deviation from mean.</span>
        <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">avg</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">arr</span><span class="p">,</span> <span class="n">casting</span><span class="o">=</span><span class="s1">&#39;unsafe&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_copyto</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mask</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complexfloating</span><span class="p">):</span>
            <span class="n">sqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="n">out</span><span class="o">=</span><span class="n">arr</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sqr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">arr</span><span class="p">)</span>

        <span class="c1"># Compute variance.</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">sqr</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&lt;</span> <span class="n">cnt</span><span class="o">.</span><span class="n">ndim</span><span class="p">:</span>
            <span class="c1"># Subclasses of ndarray may ignore keepdims, so check here.</span>
            <span class="n">cnt</span> <span class="o">=</span> <span class="n">cnt</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">dof</span> <span class="o">=</span> <span class="n">cnt</span> <span class="o">-</span> <span class="n">ddof</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">_divide_by_count</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">dof</span><span class="p">)</span>

    <span class="n">isbad</span> <span class="o">=</span> <span class="p">(</span><span class="n">dof</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">isbad</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Degrees of freedom &lt;= 0 for slice.&quot;</span><span class="p">,</span> <span class="ne">RuntimeWarning</span><span class="p">)</span>
        <span class="c1"># NaN, inf, or negative numbers are all possible bad</span>
        <span class="c1"># values, so explicitly replace them with NaN.</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">_copyto</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="n">isbad</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">var</span></div>


<div class="viewcode-block" id="nanstd"><a class="viewcode-back" href="../../../reference/generated/numpy.nanstd.html#numpy.lib.nanstd">[docs]</a><span class="k">def</span> <span class="nf">nanstd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the standard deviation along the specified axis, while</span>
<span class="sd">    ignoring NaNs.</span>

<span class="sd">    Returns the standard deviation, a measure of the spread of a</span>
<span class="sd">    distribution, of the non-NaN array elements. The standard deviation is</span>
<span class="sd">    computed for the flattened array by default, otherwise over the</span>
<span class="sd">    specified axis.</span>

<span class="sd">    For all-NaN slices or slices with zero degrees of freedom, NaN is</span>
<span class="sd">    returned and a `RuntimeWarning` is raised.</span>

<span class="sd">    .. versionadded:: 1.8.0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    a : array_like</span>
<span class="sd">        Calculate the standard deviation of the non-NaN values.</span>
<span class="sd">    axis : int, optional</span>
<span class="sd">        Axis along which the standard deviation is computed. The default is</span>
<span class="sd">        to compute the standard deviation of the flattened array.</span>
<span class="sd">    dtype : dtype, optional</span>
<span class="sd">        Type to use in computing the standard deviation. For arrays of</span>
<span class="sd">        integer type the default is float64, for arrays of float types it</span>
<span class="sd">        is the same as the array type.</span>
<span class="sd">    out : ndarray, optional</span>
<span class="sd">        Alternative output array in which to place the result. It must have</span>
<span class="sd">        the same shape as the expected output but the type (of the</span>
<span class="sd">        calculated values) will be cast if necessary.</span>
<span class="sd">    ddof : int, optional</span>
<span class="sd">        Means Delta Degrees of Freedom.  The divisor used in calculations</span>
<span class="sd">        is ``N - ddof``, where ``N`` represents the number of non-NaN</span>
<span class="sd">        elements.  By default `ddof` is zero.</span>
<span class="sd">    keepdims : bool, optional</span>
<span class="sd">        If this is set to True, the axes which are reduced are left</span>
<span class="sd">        in the result as dimensions with size one. With this option,</span>
<span class="sd">        the result will broadcast correctly against the original `arr`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    standard_deviation : ndarray, see dtype parameter above.</span>
<span class="sd">        If `out` is None, return a new array containing the standard</span>
<span class="sd">        deviation, otherwise return a reference to the output array. If</span>
<span class="sd">        ddof is &gt;= the number of non-NaN elements in a slice or the slice</span>
<span class="sd">        contains only NaNs, then the result for that slice is NaN.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    var, mean, std</span>
<span class="sd">    nanvar, nanmean</span>
<span class="sd">    numpy.doc.ufuncs : Section &quot;Output arguments&quot;</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The standard deviation is the square root of the average of the squared</span>
<span class="sd">    deviations from the mean: ``std = sqrt(mean(abs(x - x.mean())**2))``.</span>

<span class="sd">    The average squared deviation is normally calculated as</span>
<span class="sd">    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is</span>
<span class="sd">    specified, the divisor ``N - ddof`` is used instead. In standard</span>
<span class="sd">    statistical practice, ``ddof=1`` provides an unbiased estimator of the</span>
<span class="sd">    variance of the infinite population. ``ddof=0`` provides a maximum</span>
<span class="sd">    likelihood estimate of the variance for normally distributed variables.</span>
<span class="sd">    The standard deviation computed in this function is the square root of</span>
<span class="sd">    the estimated variance, so even with ``ddof=1``, it will not be an</span>
<span class="sd">    unbiased estimate of the standard deviation per se.</span>

<span class="sd">    Note that, for complex numbers, `std` takes the absolute value before</span>
<span class="sd">    squaring, so that the result is always real and nonnegative.</span>

<span class="sd">    For floating-point input, the *std* is computed using the same</span>
<span class="sd">    precision the input has. Depending on the input data, this can cause</span>
<span class="sd">    the results to be inaccurate, especially for float32 (see example</span>
<span class="sd">    below).  Specifying a higher-accuracy accumulator using the `dtype`</span>
<span class="sd">    keyword can alleviate this issue.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; a = np.array([[1, np.nan], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; np.nanstd(a)</span>
<span class="sd">    1.247219128924647</span>
<span class="sd">    &gt;&gt;&gt; np.nanstd(a, axis=0)</span>
<span class="sd">    array([ 1.,  0.])</span>
<span class="sd">    &gt;&gt;&gt; np.nanstd(a, axis=1)</span>
<span class="sd">    array([ 0.,  0.5])</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">nanvar</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">,</span> <span class="n">ddof</span><span class="o">=</span><span class="n">ddof</span><span class="p">,</span>
                 <span class="n">keepdims</span><span class="o">=</span><span class="n">keepdims</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">var</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">std</span> <span class="o">=</span> <span class="n">var</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">std</span></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/copybutton.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>